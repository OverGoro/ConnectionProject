name: Java CI/CD with Allure Reports

on:
  push:
    branches: [ main, master, develop, feature/*, release/* ]
  pull_request:
    branches: [ main, master, develop ]

env:
  POSTGRES_HOST: localhost
  POSTGRES_PORT: 5434
  POSTGRES_DB: test_db
  POSTGRES_USER: test_user
  POSTGRES_PASSWORD: test_password

jobs:
  test-and-deploy:
    name: Run Tests and Deploy Allure Reports
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: ${{ env.POSTGRES_PASSWORD }}
          POSTGRES_USER: ${{ env.POSTGRES_USER }}
          POSTGRES_DB: ${{ env.POSTGRES_DB }}
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5434:5432
      
      zookeeper:
        image: confluentinc/cp-zookeeper:7.4.0
        env:
          ZOOKEEPER_CLIENT_PORT: 2181
          ZOOKEEPER_TICK_TIME: 2000
        ports:
          - 2181:2181
      
      kafka:
        image: confluentinc/cp-kafka:7.4.0
        env:
          KAFKA_BROKER_ID: 1
          KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
          KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092,PLAINTEXT_HOST://0.0.0.0:29092
          KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092,PLAINTEXT_HOST://localhost:29092
          KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
          KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT
          KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
          KAFKA_AUTO_CREATE_TOPICS_ENABLE: "true"
        ports:
          - 9092:9092
          - 29092:29092

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up JDK 21
      uses: actions/setup-java@v4
      with:
        java-version: '21'
        distribution: 'temurin'

    - name: Analyze project structure
      run: |
        echo "ðŸ“ Analyzing project structure..."
        cd code
        
        echo "Root directory content:"
        ls -la
        
        echo "Checking for Gradle Wrapper in root:"
        if [ -f "gradlew" ]; then
          echo "âœ… Root gradlew found"
          chmod +x gradlew
          ./gradlew --version || echo "âŒ Root gradlew failed"
        else
          echo "âŒ No root gradlew found"
        fi
        
        echo "Checking service directories:"
        find . -name "gradlew" -type f | head -10
        
        echo "Checking shared directories:"
        find ./shared -name "gradlew" -type f 2>/dev/null | head -10
        
        echo "Checking service directories:"
        find ./service -name "gradlew" -type f 2>/dev/null | head -10

    - name: Use root Gradle Wrapper or install Gradle
      run: |
        cd code
        
        # ÐŸÑ€Ð¾Ð±ÑƒÐµÐ¼ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ root gradlew ÐµÑÐ»Ð¸ Ð¾Ð½ ÐµÑÑ‚ÑŒ
        if [ -f "gradlew" ]; then
          echo "ðŸš€ Using root Gradle Wrapper"
          chmod +x gradlew
          ./gradlew --version
        else
          echo "ðŸ“¦ Installing Gradle system-wide"
          sudo apt-get update
          sudo apt-get install -y gradle
          gradle --version
          
          # Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ ÑÐ¸Ð¼Ð»Ð¸Ð½Ðº Ð´Ð»Ñ ÐµÐ´Ð¸Ð½Ð¾Ð¾Ð±Ñ€Ð°Ð·Ð¸Ñ
          ln -s $(which gradle) ./gradlew
          chmod +x ./gradlew
        fi

    - name: Wait for services to be ready
      run: |
        echo "Waiting for services to start..."
        # Ð–Ð´ÐµÐ¼ PostgreSQL
        timeout 120s bash -c 'until pg_isready -h localhost -p 5434 -U test_user -d test_db 2>/dev/null; do sleep 5; echo "Waiting for PostgreSQL..."; done'
        echo "âœ… PostgreSQL is ready!"
        
        # Ð–Ð´ÐµÐ¼ Kafka
        echo "Waiting for Kafka..."
        sleep 30

    - name: Setup PostgreSQL schema
      run: |
        # Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸ÑŽ Ð´Ð»Ñ SQL Ñ„Ð°Ð¹Ð»Ð¾Ð²
        mkdir -p db
        
        # Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ scheme-init.sql
        cat > db/scheme-init.sql << 'EOF'
        create schema if not exists core;
        create schema if not exists access;
        create schema if not exists transaction;
        create schema if not exists processing;
        EOF
        
        # Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ core-init.sql
        cat > db/core-init.sql << 'EOF'
        create table if not exists core.client(
          uid uuid primary key,
          email varchar not null unique,
          birth_date date,
          username varchar not null unique,
          password varchar not null
        );

        create table if not exists core.device(
          uid uuid primary key, 
          client_uuid uuid not null references core.client(uid),
          device_name varchar(100) not null, 
          device_description varchar(500) not null
        );

        create table if not exists core.tariff(
          uid uuid primary key, 
          tariff_name varchar(100) not null, 
          amount NUMERIC(20, 8) NOT NULL,
          currency_code CHAR(3) NOT NULL
        );
        EOF
        
        # Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ token-init.sql
        cat > db/token-init.sql << 'EOF'
        create  table if not exists access.refresh_token (
          uid uuid primary key,
          client_id uuid not null references core.client(uid) on delete cascade,
          token varchar(512) not null unique,
          
          created_at TIMESTAMP WITH TIME zone not null,
          expires_at TIMESTAMP WITH TIME zone not null,
          
          CONSTRAINT chk_refresh_token_expiry CHECK (expires_at > created_at)
        );

        create table if not exists access.device_token(
          uid uuid primary key, 
          device_uid uuid not null references core.device(uid) on delete cascade,
          token varchar(512) not null unique,	
          created_at TIMESTAMP WITH TIME zone not null,
          expires_at TIMESTAMP WITH TIME zone not null
        );

        create table if not exists access.device_access_token(
          uid uuid primary key,
          device_token_uid uuid not null references access.device_token(uid) on delete cascade,
          token varchar(512) not null unique,	
          created_at TIMESTAMP WITH TIME zone not null,
          expires_at TIMESTAMP WITH TIME zone not null
        );
        EOF
        
        # Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ transaction-init.sql
        cat > db/transaction-init.sql << 'EOF'
        create table if not exists transaction.client_transaction(
          uid uuid primary key, 
          client_uid uuid not null references core.client(uid),
          transaction_date TIMESTAMP WITH TIME zone not null,
          amount NUMERIC(20, 8) NOT NULL,
          currency_code CHAR(3) NOT NULL,
          description varchar
        );

        create table if not exists transaction.tariff_transaction(
          uid uuid primary key, 
          tariff_uid uuid not null references core.tariff(uid) on delete cascade,
          transaction_uid uuid not null references transaction.client_transaction(uid) on delete cascade,
          transaction_date TIMESTAMP WITH TIME zone not null,
          expires_at TIMESTAMP WITH TIME zone not null
        );
        EOF
        
        # Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ connection-init.sql
        cat > db/connection-init.sql << 'EOF'
        create table if not exists processing.connection_scheme(
          uid uuid primary key, 
          client_uid uuid not null references core.client(uid) on delete cascade,
          scheme_json jsonb not null
        );

        create table if not exists processing.buffer(
          uid uuid primary key, 
          device_uid uuid not null references core.device(uid) on delete cascade,
          max_messages_number integer not null CHECK (max_messages_number > 0),
          max_message_size integer not null CHECK ( max_message_size > 0 ),
          message_prototype varchar
        );

        create table if not exists processing.connection_scheme_buffer(
          uid uuid primary key,
          scheme_uid uuid not null references processing.connection_scheme(uid) on delete cascade,
          buffer_uid uuid not null references processing.buffer(uid) on delete cascade
        );

        create table if not exists processing.message(
          uid uuid primary key, 
          buffer_uid uuid not null references processing.buffer(uid) on delete cascade,
          content jsonb not null, 
          content_type varchar not null, -- incomming/outcomming
          created_at TIMESTAMP WITH TIME zone not null
        );
        EOF
        
        echo "Executing SQL files..."
        for sql_file in db/*.sql; do
          echo "ðŸ“„ Executing $sql_file"
          psql -h localhost -p 5434 -U test_user -d test_db -f "$sql_file" || echo "âš ï¸  Warning: $sql_file execution had issues"
        done
      env:
        PGPASSWORD: test_password

    - name: Cache Gradle packages
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
          code/.gradle
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-

    - name: Install Allure
      run: |
        sudo wget -q https://github.com/allure-framework/allure2/releases/download/2.29.0/allure-2.29.0.tgz
        sudo tar -zxvf allure-2.29.0.tgz -C /opt/
        sudo ln -sf /opt/allure-2.29.0/bin/allure /usr/bin/allure
        allure --version

    - name: Build and test shared modules
      run: |
        cd code
        echo "ðŸ—ï¸ Building shared modules..."
        
        # Ð¡Ð½Ð°Ñ‡Ð°Ð»Ð° ÑÐ¾Ð±Ð¸Ñ€Ð°ÐµÐ¼ shared Ð¼Ð¾Ð´ÑƒÐ»Ð¸ Ð² Ð¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¾Ð¼ Ð¿Ð¾Ñ€ÑÐ´ÐºÐµ
        SHARED_MODULES=(
          "shared:common-events"
          "shared:common-auth-events" 
          "shared:common-buffer-events"
          "shared:common-connection-scheme-events"
          "shared:common-device-auth-events"
          "shared:common-device-events"
          "shared:common-message-events"
          "shared:buffer-shared"
          "shared:client-shared"
          "shared:connection-scheme-shared"
          "shared:device-shared"
          "shared:device-token-shared"
          "shared:message-shared"
          "shared:token-shared"
        )
        
        for module in "${SHARED_MODULES[@]}"; do
          echo "ðŸ“¦ Building $module"
          ./gradlew ":$module:build" -x test --no-daemon || echo "âš ï¸  Build failed for $module, but continuing..."
        done

    - name: Publish shared modules
      run: |
        cd code
        echo "ðŸ“¤ Publishing shared modules..."
        ./gradlew publishAllShared --no-daemon --stacktrace || ./gradlew :shared:common-events:publishToMavenLocal :shared:common-auth-events:publishToMavenLocal --no-daemon

    - name: Build and test services
      run: |
        cd code
        echo "ðŸ”¨ Building service modules..."
        
        SERVICE_MODULES=(
          "service:auth-service"
          "service:buffer-service" 
          "service:connection-scheme-service"
          "service:device-auth-service"
          "service:device-service"
          "service:message-service"
        )
        
        for service in "${SERVICE_MODULES[@]}"; do
          echo "ðŸ—ï¸ Building $service"
          ./gradlew ":$service:build" --no-daemon --stacktrace --continue || echo "âš ï¸  Build failed for $service, but continuing..."
        done

    - name: Run all tests
      run: |
        cd code
        echo "ðŸ§ª Running all tests..."
        ./gradlew testAll --no-daemon --stacktrace --continue || echo "âš ï¸  Some tests failed, but continuing..."

    - name: Generate Allure report
      run: |
        cd code
        echo "ðŸ“Š Generating Allure reports..."
        ./gradlew collectAllureResults generateCombinedAllureReport --no-daemon --continue

    - name: Create branch-specific index
      run: |
        cd code
        BRANCH_NAME="${{ github.ref_name }}"
        cat > build/reports/allure-report/branch-index.html << EOF
        <!DOCTYPE html>
        <html>
        <head>
            <title>Allure Report - $BRANCH_NAME</title>
            <meta http-equiv="refresh" content="0;url=index.html">
        </head>
        <body>
            <p>Redirecting to <a href="index.html">Allure Report for $BRANCH_NAME</a></p>
        </body>
        </html>
        EOF

    - name: Deploy to GitHub Pages
      uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./code/build/reports/allure-report
        destination_dir: ./allure/${{ github.ref_name }}
        keep_files: true
        force_orphan: false

    - name: Upload test results artifact
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ github.ref_name }}-${{ github.run_id }}
        path: |
          code/build/reports
          code/build/test-results
        retention-days: 7
