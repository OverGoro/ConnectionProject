name: Java CI/CD with Allure Reports

on:
  push:
    branches: [ main, master, develop, feature/*, release/* ]
  pull_request:
    branches: [ main, master, develop ]

env:
  POSTGRES_HOST: localhost
  POSTGRES_PORT: 5434
  POSTGRES_DB: test_db
  POSTGRES_USER: test_user
  POSTGRES_PASSWORD: test_password

jobs:
  test-and-deploy:
    name: Run Tests and Deploy Allure Reports
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: ${{ env.POSTGRES_PASSWORD }}
          POSTGRES_USER: ${{ env.POSTGRES_USER }}
          POSTGRES_DB: ${{ env.POSTGRES_DB }}
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5434:5432
      
      zookeeper:
        image: confluentinc/cp-zookeeper:7.4.0
        env:
          ZOOKEEPER_CLIENT_PORT: 2181
          ZOOKEEPER_TICK_TIME: 2000
        ports:
          - 2181:2181
      
      kafka:
        image: confluentinc/cp-kafka:7.4.0
        env:
          KAFKA_BROKER_ID: 1
          KAFKA_ZOOKEEPER_CONNECT: zookeeper:2181
          KAFKA_LISTENERS: PLAINTEXT://0.0.0.0:9092,PLAINTEXT_HOST://0.0.0.0:29092
          KAFKA_ADVERTISED_LISTENERS: PLAINTEXT://kafka:9092,PLAINTEXT_HOST://localhost:29092
          KAFKA_LISTENER_SECURITY_PROTOCOL_MAP: PLAINTEXT:PLAINTEXT,PLAINTEXT_HOST:PLAINTEXT
          KAFKA_INTER_BROKER_LISTENER_NAME: PLAINTEXT
          KAFKA_OFFSETS_TOPIC_REPLICATION_FACTOR: 1
          KAFKA_AUTO_CREATE_TOPICS_ENABLE: "true"
        ports:
          - 9092:9092
          - 29092:29092

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Set up JDK 21
      uses: actions/setup-java@v4
      with:
        java-version: '21'
        distribution: 'temurin'

    - name: Verify and Fix Gradle Wrapper
      run: |
        cd code
        
        echo "ðŸ” Checking Gradle Wrapper integrity..."
        
        # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð½Ð°Ð»Ð¸Ñ‡Ð¸Ðµ Ð²ÑÐµÑ… Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ñ‹Ñ… Ñ„Ð°Ð¹Ð»Ð¾Ð²
        if [ -f "gradlew" ] && [ -f "gradle/wrapper/gradle-wrapper.jar" ] && [ -f "gradle/wrapper/gradle-wrapper.properties" ]; then
          echo "âœ… Gradle Wrapper files are present"
          chmod +x gradlew
          
          # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ñ‡Ñ‚Ð¾ wrapper Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚
          if ./gradlew --version > /dev/null 2>&1; then
            echo "âœ… Gradle Wrapper is functional"
          else
            echo "âŒ Gradle Wrapper is not functional, recreating..."
            rm -f gradlew gradlew.bat
            rm -rf gradle/wrapper
          fi
        else
          echo "âŒ Gradle Wrapper files are missing or incomplete"
        fi
        
        # Ð•ÑÐ»Ð¸ Ñ„Ð°Ð¹Ð»Ñ‹ Ð¾Ñ‚ÑÑƒÑ‚ÑÑ‚Ð²ÑƒÑŽÑ‚ Ð¸Ð»Ð¸ Ð½Ðµ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÑŽÑ‚, ÑÐ¾Ð·Ð´Ð°ÐµÐ¼ Ð¸Ñ… Ð·Ð°Ð½Ð¾Ð²Ð¾
        if [ ! -f "gradlew" ] || [ ! -f "gradle/wrapper/gradle-wrapper.jar" ]; then
          echo "ðŸ“¦ Recreating Gradle Wrapper..."
          
          # Ð£ÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ Gradle Ð´Ð»Ñ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ñ wrapper
          sudo apt-get update
          sudo apt-get install -y gradle
          
          # Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ wrapper
          gradle wrapper --gradle-version 8.5 --distribution-type all
          
          # ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ðµ
          if [ -f "gradlew" ] && [ -f "gradle/wrapper/gradle-wrapper.jar" ]; then
            echo "âœ… Gradle Wrapper recreated successfully"
            chmod +x gradlew
          else
            echo "âŒ Failed to recreate Gradle Wrapper"
            exit 1
          fi
        fi
        
        # Ð¤Ð¸Ð½Ð°Ð»ÑŒÐ½Ð°Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ°
        echo "ðŸŽ¯ Final verification:"
        ./gradlew --version

    - name: Wait for services to be ready
      run: |
        echo "Waiting for services to start..."
        # Ð–Ð´ÐµÐ¼ PostgreSQL
        timeout 120s bash -c 'until pg_isready -h localhost -p 5434 -U test_user -d test_db 2>/dev/null; do sleep 5; echo "Waiting for PostgreSQL..."; done'
        echo "âœ… PostgreSQL is ready!"
        
        # Ð–Ð´ÐµÐ¼ Kafka
        echo "Waiting for Kafka..."
        sleep 30

    - name: Setup PostgreSQL schema
      run: |
        # Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ Ð´Ð¸Ñ€ÐµÐºÑ‚Ð¾Ñ€Ð¸ÑŽ Ð´Ð»Ñ SQL Ñ„Ð°Ð¹Ð»Ð¾Ð²
        mkdir -p db
        
        # Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ scheme-init.sql
        cat > db/scheme-init.sql << 'EOF'
        create schema if not exists core;
        create schema if not exists access;
        create schema if not exists transaction;
        create schema if not exists processing;
        EOF
        
        # Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ core-init.sql
        cat > db/core-init.sql << 'EOF'
        create table if not exists core.client(
          uid uuid primary key,
          email varchar not null unique,
          birth_date date,
          username varchar not null unique,
          password varchar not null
        );

        create table if not exists core.device(
          uid uuid primary key, 
          client_uuid uuid not null references core.client(uid),
          device_name varchar(100) not null, 
          device_description varchar(500) not null
        );

        create table if not exists core.tariff(
          uid uuid primary key, 
          tariff_name varchar(100) not null, 
          amount NUMERIC(20, 8) NOT NULL,
          currency_code CHAR(3) NOT NULL
        );
        EOF
        
        # Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ token-init.sql
        cat > db/token-init.sql << 'EOF'
        create  table if not exists access.refresh_token (
          uid uuid primary key,
          client_id uuid not null references core.client(uid) on delete cascade,
          token varchar(512) not null unique,
          
          created_at TIMESTAMP WITH TIME zone not null,
          expires_at TIMESTAMP WITH TIME zone not null,
          
          CONSTRAINT chk_refresh_token_expiry CHECK (expires_at > created_at)
        );

        create table if not exists access.device_token(
          uid uuid primary key, 
          device_uid uuid not null references core.device(uid) on delete cascade,
          token varchar(512) not null unique,	
          created_at TIMESTAMP WITH TIME zone not null,
          expires_at TIMESTAMP WITH TIME zone not null
        );

        create table if not exists access.device_access_token(
          uid uuid primary key,
          device_token_uid uuid not null references access.device_token(uid) on delete cascade,
          token varchar(512) not null unique,	
          created_at TIMESTAMP WITH TIME zone not null,
          expires_at TIMESTAMP WITH TIME zone not null
        );
        EOF
        
        # Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ transaction-init.sql
        cat > db/transaction-init.sql << 'EOF'
        create table if not exists transaction.client_transaction(
          uid uuid primary key, 
          client_uid uuid not null references core.client(uid),
          transaction_date TIMESTAMP WITH TIME zone not null,
          amount NUMERIC(20, 8) NOT NULL,
          currency_code CHAR(3) NOT NULL,
          description varchar
        );

        create table if not exists transaction.tariff_transaction(
          uid uuid primary key, 
          tariff_uid uuid not null references core.tariff(uid) on delete cascade,
          transaction_uid uuid not null references transaction.client_transaction(uid) on delete cascade,
          transaction_date TIMESTAMP WITH TIME zone not null,
          expires_at TIMESTAMP WITH TIME zone not null
        );
        EOF
        
        # Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ connection-init.sql
        cat > db/connection-init.sql << 'EOF'
        create table if not exists processing.connection_scheme(
          uid uuid primary key, 
          client_uid uuid not null references core.client(uid) on delete cascade,
          scheme_json jsonb not null
        );

        create table if not exists processing.buffer(
          uid uuid primary key, 
          device_uid uuid not null references core.device(uid) on delete cascade,
          max_messages_number integer not null CHECK (max_messages_number > 0),
          max_message_size integer not null CHECK ( max_message_size > 0 ),
          message_prototype varchar
        );

        create table if not exists processing.connection_scheme_buffer(
          uid uuid primary key,
          scheme_uid uuid not null references processing.connection_scheme(uid) on delete cascade,
          buffer_uid uuid not null references processing.buffer(uid) on delete cascade
        );

        create table if not exists processing.message(
          uid uuid primary key, 
          buffer_uid uuid not null references processing.buffer(uid) on delete cascade,
          content jsonb not null, 
          content_type varchar not null, -- incomming/outcomming
          created_at TIMESTAMP WITH TIME zone not null
        );
        EOF
        
        echo "Executing SQL files..."
        for sql_file in db/*.sql; do
          echo "ðŸ“„ Executing $sql_file"
          psql -h localhost -p 5434 -U test_user -d test_db -f "$sql_file" || echo "âš ï¸  Warning: $sql_file execution had issues"
        done
      env:
        PGPASSWORD: test_password

    - name: Cache Gradle packages
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
          code/.gradle
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-

    - name: Install Allure
      run: |
        sudo wget -q https://github.com/allure-framework/allure2/releases/download/2.29.0/allure-2.29.0.tgz
        sudo tar -zxvf allure-2.29.0.tgz -C /opt/
        sudo ln -sf /opt/allure-2.29.0/bin/allure /usr/bin/allure
        allure --version

    - name: Build and test shared modules
      run: |
        cd code
        echo "ðŸ—ï¸ Building shared modules..."
        ./gradlew :shared:common-events:build :shared:common-auth-events:build :shared:common-buffer-events:build :shared:common-connection-scheme-events:build :shared:common-device-auth-events:build :shared:common-device-events:build :shared:common-message-events:build -x test --no-daemon --stacktrace

    - name: Publish shared modules
      run: |
        cd code
        echo "ðŸ“¤ Publishing shared modules..."
        ./gradlew publishAllShared --no-daemon --stacktrace

    - name: Build and test services
      run: |
        cd code
        echo "ðŸ”¨ Building and testing service modules..."
        ./gradlew build --no-daemon --stacktrace --continue

    - name: Run all tests
      run: |
        cd code
        echo "ðŸ§ª Running all tests..."
        ./gradlew testAll --no-daemon --stacktrace --continue

    - name: Generate Allure report
      run: |
        cd code
        echo "ðŸ“Š Generating Allure reports..."
        ./gradlew collectAllureResults generateCombinedAllureReport --no-daemon --continue

    - name: Create branch-specific index
      run: |
        cd code
        BRANCH_NAME="${{ github.ref_name }}"
        cat > build/reports/allure-report/branch-index.html << EOF
        <!DOCTYPE html>
        <html>
        <head>
            <title>Allure Report - $BRANCH_NAME</title>
            <meta http-equiv="refresh" content="0;url=index.html">
        </head>
        <body>
            <p>Redirecting to <a href="index.html">Allure Report for $BRANCH_NAME</a></p>
        </body>
        </html>
        EOF

    - name: Deploy to GitHub Pages
      uses: peaceiris/actions-gh-pages@v3
      with:
        github_token: ${{ secrets.GITHUB_TOKEN }}
        publish_dir: ./code/build/reports/allure-report
        destination_dir: ./allure/${{ github.ref_name }}
        keep_files: true
        force_orphan: false

    - name: Upload test results artifact
      uses: actions/upload-artifact@v4
      with:
        name: test-results-${{ github.ref_name }}-${{ github.run_id }}
        path: |
          code/build/reports
          code/build/test-results
        retention-days: 7
