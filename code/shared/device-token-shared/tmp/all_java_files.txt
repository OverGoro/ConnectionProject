package com.connection.token.exception;

public class AccessTokenValidateException extends BaseTokenException{
    String descriptionString;
    public AccessTokenValidateException(String tokenString, String description){
        super(tokenString);
        this.descriptionString = description;
    }

    public String toString(){
        String res = super.toString();
        res += "\n" + "description: Access token is invalid";
        res += "\n" + descriptionString;
        return res;
    }
}
package com.connection.token.exception;

public class RefreshTokenAddException extends BaseTokenException{
    public RefreshTokenAddException(String tokenString){
        super(tokenString);
    }

    public String toString(){
        String res = super.toString();
        res += "\n" + "description: cannot add refresh token";
        return res;
    }
}
package com.connection.token.exception;

public class RefreshTokenNotFoundException extends BaseTokenException {
    public RefreshTokenNotFoundException(String tokenString) {
        super(tokenString);
    }

    public String toString() {
        String res = super.toString();
        res += "\n" + "description: refresh token not found";
        return res;
    }
}
package com.connection.token.exception;

public class RefreshTokenExpiredException extends BaseTokenException {
    public RefreshTokenExpiredException(String tokenString) {
        super(tokenString);
    }

    public String toString() {
        String res = super.toString();
        res += "\n" + "description: refresh token is expired";
        return res;
    }
}
package com.connection.token.exception;

public class RefreshTokenValidateException extends BaseTokenException{
    String descriptionString;
    public RefreshTokenValidateException(String tokenString, String description){
        super(tokenString);
        this.descriptionString = description;
    }

    public String toString(){
        String res = super.toString();
        res += "\n" + "description: refresh token is invalid";
        res += "\n" + descriptionString;
        return res;
    }
}
package com.connection.token.exception;

public class BaseTokenException extends RuntimeException{
    private final String tokenString;

    public BaseTokenException(String tokenDescription){
        super("token");
        tokenString = tokenDescription;
    }

    public String toString(){
        String res = super.toString();
        res += "\n" + "token: " + tokenString;
        return res;
    }
}
package com.connection.token.exception;

public class RefreshTokenAlreadyExisistsException extends BaseTokenException{
    private final String descriptionString = "refresh token already exists";
    public RefreshTokenAlreadyExisistsException(String tokenString){
        super(tokenString);
    }

    public String toString(){
        String res = super.toString();
        res += "\n" + "description: " + descriptionString;
        return res;
    }
}
package com.connection.token.generator;

import java.util.Date;
import java.util.UUID;

import javax.crypto.SecretKey;

import com.connection.token.model.AccessTokenBLM;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import io.jsonwebtoken.Jwts;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class AccessTokenGenerator {
    @NonNull
    private final SecretKey jwtSecretKey;

    @NonNull
    private final String appNameString;

    @NonNull
    private final String jwtSubjecString;

    public String generateAccessToken(UUID clientUuid, Date createdAtDate, Date expiresAtDate) {
        String token = Jwts.builder()
                .issuer(appNameString)
                .subject(jwtSubjecString)
                .claim("clientUid", clientUuid.toString())
                .issuedAt(createdAtDate)
                .expiration(expiresAtDate)
                .signWith(jwtSecretKey)
                .compact();
        return token;
    }

    public AccessTokenBLM getAccessTokenBLM(String token) {
        Jws<Claims> jws = Jwts.parser()
                .verifyWith(jwtSecretKey)
                .build()
                .parseSignedClaims(token);

        Claims claims = jws.getPayload();

        UUID clientUid = UUID.fromString(claims.get("clientUid", String.class));
        Date issuedAt = claims.getIssuedAt();
        Date expiration = claims.getExpiration();

        if (!jwtSubjecString.equals(claims.getSubject())) {
            throw new RuntimeException("Invalid token subject");
        }

        return new AccessTokenBLM(token, clientUid, issuedAt, expiration);
    }
}
package com.connection.token.generator;

import java.util.Date;
import java.util.UUID;

import javax.crypto.SecretKey;

import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDALM;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import io.jsonwebtoken.Jwts;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class RefreshTokenGenerator {
    @NonNull
    private final SecretKey jwtSecretKey;

    @NonNull
    private final String appNameString;

    @NonNull
    private final String jwtSubjecString;

    public String generateRefreshToken(RefreshTokenDALM dalm) {
        String token = Jwts.builder()
                .issuer(appNameString)
                .subject(jwtSubjecString)
                .claim("uid", dalm.getUid().toString())
                .claim("clientUid", dalm.getClientUID().toString())
                .issuedAt(dalm.getCreatedAt())
                .expiration(dalm.getExpiresAt())
                .signWith(jwtSecretKey)
                .compact();
        return token;
    }

    public String generateRefreshToken(UUID uid, UUID clientUuid, Date createdAt, Date expiresAt) {
        String token = Jwts.builder()
                .issuer(appNameString)
                .subject(jwtSubjecString)
                .claim("uid", uid.toString())
                .claim("clientUid", clientUuid.toString())
                .issuedAt(createdAt)
                .expiration(expiresAt)
                .signWith(jwtSecretKey)
                .compact();
        return token;
    }

    public RefreshTokenBLM getRefreshToken(String token) {
        Jws<Claims> jws = Jwts.parser()
                .verifyWith(jwtSecretKey)
                .build()
                .parseSignedClaims(token);

        Claims claims = jws.getPayload();

        UUID uid = UUID.fromString(claims.get("uid", String.class));
        UUID clientUid = UUID.fromString(claims.get("clientUid", String.class));
        Date issuedAt = claims.getIssuedAt();
        Date expiration = claims.getExpiration();

        if (!jwtSubjecString.equals(claims.getSubject())) {
            throw new RuntimeException("Invalid token subject");
        }

        return new RefreshTokenBLM(token, uid, clientUid, issuedAt, expiration);
    }
}
package com.connection.token.model;

import java.util.Date;
import java.util.UUID;

import jakarta.persistence.Entity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Builder
public class RefreshTokenBLM {
    protected String token;
    protected UUID uid;
    protected UUID clientUID;
    
    protected Date createdAt;
    protected Date expiresAt;
}
package com.connection.token.model;

import java.util.Date;
import java.util.UUID;

import jakarta.persistence.Entity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Builder
public class RefreshTokenDALM {
    protected String token;

    
    protected UUID uid;
    
    protected UUID clientUID;
    
    protected Date createdAt;
    
    protected Date expiresAt;
}
package com.connection.token.model;
import jakarta.persistence.Entity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Builder
public class AccessTokenDTO {
    protected String token;
}
package com.connection.token.model;

import jakarta.persistence.Entity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Builder
public class RefreshTokenDTO {
    protected String token;
}
package com.connection.token.model;

import java.util.Date;
import java.util.UUID;

import jakarta.persistence.Entity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Builder
public class AccessTokenBLM {
    protected String token;
    protected UUID clientUID;
    protected Date createdAt;
    protected Date expiresAt;
}
package com.connection.token.model;

import java.util.Date;
import java.util.UUID;

import jakarta.persistence.Entity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Builder
public class AccessTokenDALM {
    protected UUID clientUID;
    protected Date createdAt;
    protected Date expiresAt;
}
package com.connection.token.converter;

import com.connection.token.generator.RefreshTokenGenerator;
import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDALM;
import com.connection.token.model.RefreshTokenDTO;

import io.jsonwebtoken.JwtException;
import jakarta.annotation.Nonnull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class RefreshTokenConverter {
    @Nonnull
    private final RefreshTokenGenerator tokenGenerator;
    public RefreshTokenBLM toBLM(RefreshTokenDALM dalm) {
        String token  = tokenGenerator.generateRefreshToken(dalm);
        return new RefreshTokenBLM(token,
                dalm.getUid(),
                dalm.getClientUID(),
                dalm.getCreatedAt(),
                dalm.getExpiresAt());
    }

    public RefreshTokenBLM toBLM(RefreshTokenDTO dto) {
        try {
            RefreshTokenBLM tokenBLM = tokenGenerator.getRefreshToken(dto.getToken());
            return tokenBLM;
        } catch (JwtException e) {
            throw new RuntimeException("Invalid JWT token: " + e.getMessage(), e);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException("Malformed JWT token", e);
        }
    }

    public RefreshTokenDTO toDTO(RefreshTokenBLM blm){
        return new RefreshTokenDTO(blm.getToken());
    }

    public RefreshTokenDALM toDALM(RefreshTokenBLM blm){
        return new RefreshTokenDALM(blm.getToken(), 
                                    blm.getUid(),
                                    blm.getClientUID(), 
                                    blm.getCreatedAt(), 
                                    blm.getExpiresAt());
    }
}

package com.connection.token.converter;

import com.connection.token.generator.AccessTokenGenerator;
import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.AccessTokenDALM;
import com.connection.token.model.AccessTokenDTO;

import io.jsonwebtoken.JwtException;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class AccessTokenConverter {
    @NonNull
    private final AccessTokenGenerator accessTokenGenerator;

    public AccessTokenBLM toBLM(AccessTokenDALM dalm) {
        try {
            String token = accessTokenGenerator.generateAccessToken(dalm.getClientUID(), dalm.getCreatedAt(),
                    dalm.getExpiresAt());
            return new AccessTokenBLM(token,
                    dalm.getClientUID(),
                    dalm.getCreatedAt(),
                    dalm.getExpiresAt());
        } catch (JwtException e) {
            throw new RuntimeException("Invalid JWT token: " + e.getMessage(), e);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException("Malformed JWT token", e);
        }
    }

    public AccessTokenBLM toBLM(AccessTokenDTO dto) {
        try {
            AccessTokenBLM blm = accessTokenGenerator.getAccessTokenBLM(dto.getToken());
            return blm;
        } catch (JwtException e) {
            throw new RuntimeException("Invalid JWT token: " + e.getMessage(), e);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException("Malformed JWT token", e);
        }
    }

    public AccessTokenDTO toDTO(AccessTokenBLM blm) {
        return new AccessTokenDTO(blm.getToken());
    }

    public AccessTokenDALM toDALM(AccessTokenBLM blm) {
        return new AccessTokenDALM(blm.getClientUID(), blm.getCreatedAt(), blm.getExpiresAt());
    }
}
package com.connection.token.validator;

import java.util.Date;
import java.util.UUID;

import com.connection.token.exception.RefreshTokenValidateException;
import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDALM;
import com.connection.token.model.RefreshTokenDTO;

public class RefreshTokenValidator {
    public void validate(RefreshTokenDTO refreshToken) {
        if (refreshToken == null) {
            throw new RefreshTokenValidateException("null", "Refresh token is null");
        }
        try {
            validateToken(refreshToken.getToken());
        } catch (IllegalArgumentException e) {
            throw new RefreshTokenValidateException("refreshToken", e.getMessage());
        }
    }

    public void validate(RefreshTokenBLM refreshToken) {
        if (refreshToken == null) {
            throw new RefreshTokenValidateException("null", "Refresh token is null");
        }
        try {
            validateToken(refreshToken.getToken());
            validateUID(refreshToken.getUid());
            validateClientUID(refreshToken.getClientUID());
            validateCreatedAt(refreshToken.getCreatedAt());
            validateExpiresAt(refreshToken.getExpiresAt());
        } catch (IllegalArgumentException e) {
            if (refreshToken.getUid() != null)
                throw new RefreshTokenValidateException(refreshToken.getUid().toString(), e.getMessage());
            else
                throw new RefreshTokenValidateException("null", e.getMessage());
        }
    }

    public void validate(RefreshTokenDALM refreshToken) {
        if (refreshToken == null) {
            throw new RefreshTokenValidateException("null", "Refresh token is null");
        }
        try {
            validateUID(refreshToken.getUid());
            validateClientUID(refreshToken.getClientUID());
            validateCreatedAt(refreshToken.getCreatedAt());
            validateExpiresAt(refreshToken.getExpiresAt());
        } catch (IllegalArgumentException e) {
            if (refreshToken.getUid() != null)
                throw new RefreshTokenValidateException(refreshToken.getUid().toString(), e.getMessage());
            else
                throw new RefreshTokenValidateException("null", e.getMessage());
        }
    }

    private void validateToken(String token) {
        if (token == null || token.trim().isEmpty()) {
            throw new IllegalArgumentException("Token cannot be empty");
        }
    }

    private void validateUID(UUID UID) {
        if (UID == null) {
            throw new IllegalArgumentException("UID cannot be null");
        }
    }

    private void validateClientUID(UUID clientUID) {
        if (clientUID == null) {
            throw new IllegalArgumentException("Client UID cannot be null");
        }
    }

    private void validateCreatedAt(Date createdAt) {
        if (createdAt == null) {
            throw new IllegalArgumentException("Creation date cannot be null");
        }

        Date now = new Date();
        if (createdAt.after(now)) {
            throw new IllegalArgumentException("Creation date cannot be in the future");
        }
    }

    private void validateExpiresAt(Date expiresAt) {
        if (expiresAt == null) {
            throw new IllegalArgumentException("Expiration date cannot be null");
        }

        Date now = new Date();
        if (expiresAt.before(now)) {
            throw new IllegalArgumentException("Token has already expired");
        }
    }

}
package com.connection.token.validator;

import java.util.Date;
import java.util.UUID;

import com.connection.token.exception.AccessTokenValidateException;
import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.AccessTokenDALM;
import com.connection.token.model.AccessTokenDTO;

public class AccessTokenValidator {
    public void validate(AccessTokenDTO accessToken) {
        if (accessToken == null) {
            throw new AccessTokenValidateException("null", "Access token is null");
        }
        try {
            validateToken(accessToken.getToken());
        } catch (IllegalArgumentException e) {
            throw new AccessTokenValidateException("accessToken", e.getMessage());
        }
    }

    public void validate(AccessTokenBLM accessToken) {
        if (accessToken == null) {
            throw new AccessTokenValidateException("null", "Access token is null");
        }
        try {
            validateToken(accessToken.getToken());
            validateClientUID(accessToken.getClientUID());
            validateCreatedAt(accessToken.getCreatedAt());
            validateExpiresAt(accessToken.getExpiresAt());
        } catch (IllegalArgumentException e) {
            throw new AccessTokenValidateException("accessToken", e.getMessage());
        }
    }

    public void validate(AccessTokenDALM accessToken) {
        if (accessToken == null) {
            throw new AccessTokenValidateException("null", "Access token is null");
        }
        try {
            validateClientUID(accessToken.getClientUID());
            validateCreatedAt(accessToken.getCreatedAt());
            validateExpiresAt(accessToken.getExpiresAt());
        } catch (IllegalArgumentException e) {
            throw new AccessTokenValidateException("accessToken", e.getMessage());
        }
    }

    private void validateToken(String token) {
        if (token == null || token.trim().isEmpty()) {
            throw new IllegalArgumentException("Token cannot be empty");
        }
    }

    private void validateClientUID(UUID clientUID) {
        if (clientUID == null) {
            throw new IllegalArgumentException("Client UID cannot be null");
        }
    }

    private void validateCreatedAt(Date createdAt) {
        if (createdAt == null) {
            throw new IllegalArgumentException("Creation date cannot be null");
        }

        Date now = new Date();
        if (createdAt.after(now)) {
            throw new IllegalArgumentException("Creation date cannot be in the future");
        }
    }

    private void validateExpiresAt(Date expiresAt) {
        if (expiresAt == null) {
            throw new IllegalArgumentException("Expiration date cannot be null");
        }

        Date now = new Date();
        if (expiresAt.before(now)) {
            throw new IllegalArgumentException("Token has already expired");
        }
    }

}
package com.connection.token.repository;

import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Timestamp;
import java.util.Date;
import java.util.UUID;

import com.connection.token.exception.RefreshTokenAlreadyExisistsException;
import com.connection.token.exception.RefreshTokenNotFoundException;
import com.connection.token.model.RefreshTokenDALM;

@Repository
public class RefreshTokenRepositorySQLImpl implements RefreshTokenRepository {

    private static final String SELECT_REFRESH_TOKEN = "SELECT uid, client_id, token, created_at, expires_at";
    private static final String FROM_REFRESH_TOKEN = " FROM \"access\".refresh_token";

    private static final String SELECT_TOKEN_BY_UID = SELECT_REFRESH_TOKEN + FROM_REFRESH_TOKEN + " WHERE uid = :uid";
    private static final String SELECT_TOKEN_BY_TOKEN = SELECT_REFRESH_TOKEN + FROM_REFRESH_TOKEN + " WHERE token = :token";

    private static final String INSERT_REFRESH_TOKEN = "INSERT INTO \"access\".refresh_token (uid, client_id, token, created_at, expires_at) " +
            "VALUES (:uid, :client_id, :token, :created_at, :expires_at)";

    private static final String UPDATE_TOKEN = "UPDATE \"access\".refresh_token SET token = :new_token, expires_at = :new_expires_at, created_at = :new_created_at " +
            "WHERE uid = :uid";

    private static final String REVOKE_TOKEN = "DELETE FROM \"access\".refresh_token WHERE uid = :uid";
    private static final String REVOKE_ALL_CLIENT_TOKENS = "DELETE FROM \"access\".refresh_token WHERE client_id = :client_id";
    private static final String CLEANUP_EXPIRED_TOKENS = "DELETE FROM \"access\".refresh_token WHERE expires_at < NOW()";

    private final NamedParameterJdbcTemplate jdbcTemplate;

    private final RowMapper<RefreshTokenDALM> refreshTokenRowMapper = (rs, rowNum) -> {
        RefreshTokenDALM token = new RefreshTokenDALM();
        token.setUid(UUID.fromString(rs.getString("uid")));
        token.setClientUID(UUID.fromString(rs.getString("client_id")));
        token.setToken(rs.getString("token"));
        token.setCreatedAt(rs.getTimestamp("created_at"));
        token.setExpiresAt(rs.getTimestamp("expires_at"));
        return token;
    };

    public RefreshTokenRepositorySQLImpl(NamedParameterJdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    @Transactional
    public void add(RefreshTokenDALM refreshTokenDALM) throws RefreshTokenAlreadyExisistsException {
        // Проверяем существование по token
        if (tokenExists(refreshTokenDALM.getToken())) {
            throw new RefreshTokenAlreadyExisistsException("Refresh token already exists");
        }

        // Проверяем существование по uid
        if (uidExists(refreshTokenDALM.getUid())) {
            throw new RefreshTokenAlreadyExisistsException("Refresh token with UID " + refreshTokenDALM.getUid() + " already exists");
        }

        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", refreshTokenDALM.getUid());
        params.addValue("client_id", refreshTokenDALM.getClientUID());
        params.addValue("token", refreshTokenDALM.getToken());
        params.addValue("created_at", new Timestamp(refreshTokenDALM.getCreatedAt().getTime()));
        params.addValue("expires_at", new Timestamp(refreshTokenDALM.getExpiresAt().getTime()));

        jdbcTemplate.update(INSERT_REFRESH_TOKEN, params);
    }

    @Override
    @Transactional
    public void updateToken(RefreshTokenDALM refreshTokenDALM, RefreshTokenDALM newRefreshTokenDALM) 
            throws RefreshTokenNotFoundException {
        // Проверяем существование старого токена
        if (!uidExists(refreshTokenDALM.getUid())) {
            throw new RefreshTokenNotFoundException("Refresh token with UID " + refreshTokenDALM.getUid() + " not found");
        }

        // Проверяем что новый токен не существует
        if (tokenExists(newRefreshTokenDALM.getToken())) {
            throw new RefreshTokenAlreadyExisistsException("Refresh token already exists");
        }

        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", refreshTokenDALM.getUid());
        params.addValue("new_token", newRefreshTokenDALM.getToken());
        params.addValue("new_created_at", new Timestamp(newRefreshTokenDALM.getCreatedAt().getTime()));
        params.addValue("new_expires_at", new Timestamp(newRefreshTokenDALM.getExpiresAt().getTime()));

        jdbcTemplate.update(UPDATE_TOKEN, params);
    }

    @Override
    @Transactional
    public void revoke(RefreshTokenDALM refreshTokenDALM) throws RefreshTokenNotFoundException {
        // Проверяем существование токена
        if (!uidExists(refreshTokenDALM.getUid())) {
            throw new RefreshTokenNotFoundException("Refresh token with UID " + refreshTokenDALM.getUid() + " not found");
        }

        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", refreshTokenDALM.getUid());

        jdbcTemplate.update(REVOKE_TOKEN, params);
    }

    @Override
    @Transactional
    public void revokeAll(UUID clientUUID) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("client_id", clientUUID);

        jdbcTemplate.update(REVOKE_ALL_CLIENT_TOKENS, params);
    }

    @Override
    @Transactional
    public void cleanUpExpired() {
        jdbcTemplate.update(CLEANUP_EXPIRED_TOKENS, new MapSqlParameterSource());
    }

    // Вспомогательные методы
    @Transactional(readOnly = true)
    boolean uidExists(UUID uid) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", uid);
        try {
            jdbcTemplate.queryForObject(SELECT_TOKEN_BY_UID, params, refreshTokenRowMapper);
            return true;
        } catch (EmptyResultDataAccessException e) {
            return false;
        }
    }

    @Transactional(readOnly = true)
    boolean tokenExists(String token) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("token", token);
        try {
            jdbcTemplate.queryForObject(SELECT_TOKEN_BY_TOKEN, params, refreshTokenRowMapper);
            return true;
        } catch (EmptyResultDataAccessException e) {
            return false;
        }
    }

    // Дополнительные методы для внутреннего использования
    @Transactional(readOnly = true)
    RefreshTokenDALM findByUid(UUID uid) throws RefreshTokenNotFoundException {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", uid);
        try {
            return jdbcTemplate.queryForObject(SELECT_TOKEN_BY_UID, params, refreshTokenRowMapper);
        } catch (EmptyResultDataAccessException e) {
            throw new RefreshTokenNotFoundException("Refresh token with UID " + uid + " not found");
        }
    }

    @Transactional(readOnly = true)
    RefreshTokenDALM findByToken(String token) throws RefreshTokenNotFoundException {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("token", token);
        try {
            return jdbcTemplate.queryForObject(SELECT_TOKEN_BY_TOKEN, params, refreshTokenRowMapper);
        } catch (EmptyResultDataAccessException e) {
            throw new RefreshTokenNotFoundException("Refresh token not found");
        }
    }

    @Transactional(readOnly = true)
    boolean isTokenValid(String token) {
        try {
            RefreshTokenDALM refreshToken = findByToken(token);
            return refreshToken.getExpiresAt().after(new Date());
        } catch (RefreshTokenNotFoundException e) {
            return false;
        }
    }
}package com.connection.token.repository;

import java.util.UUID;

import com.connection.token.exception.RefreshTokenAlreadyExisistsException;
import com.connection.token.exception.RefreshTokenNotFoundException;
import com.connection.token.model.RefreshTokenDALM;

public interface RefreshTokenRepository {
    /**
     * Лобавить новый refreshToken
     * 
     * @param refreshTokenDALM Новый токен
     */
    public void add(RefreshTokenDALM refreshTokenDALM) throws RefreshTokenAlreadyExisistsException;

    /**
     * Обновить токен
     * Создается новый токен взамен старого, старый отзывается
     * 
     * @param refreshTokenDALM Старый токен
     * @return Новый сохраненный токен
     * @throws RefreshTokenNotFoundException Если токен с таким uid не существует
     */
    public void updateToken(RefreshTokenDALM refreshTokenDALM, RefreshTokenDALM newRefreshTokenDALM)
            throws RefreshTokenNotFoundException;

    /**
     * Отозвать токен
     * 
     * @param refreshTokenDALM Токен для отзыва
     * @throws RefreshTokenNotFoundException Если токен с таким uid не существует
     */
    public void revoke(RefreshTokenDALM refreshTokenDALM) throws RefreshTokenNotFoundException;

    /**
     * Отозвать все токены клиента
     * 
     * @param clientDALM Клиент
     */
    public void revokeAll(UUID clientUUID);

    /**
     * Отозвать все закончившиеся токены
     */
    public void cleanUpExpired();
}
package com.connection.token.exception;

import static org.assertj.core.api.Assertions.assertThat;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Token Exception Tests")
class TokenExceptionTest {

    @Test
    @DisplayName("BaseTokenException toString format")
    void testBaseTokenExceptionToString() {
        String tokenUid = "test-token-123";
        BaseTokenException exception = new BaseTokenException(tokenUid);
        String result = exception.toString();
        assertThat(result).contains(tokenUid);
    }

    @Test
    @DisplayName("RefreshTokenValidateException toString format")
    void testRefreshTokenValidateExceptionToString() {
        String tokenUid = "test-token-456";
        String description = "Validation failed";
        RefreshTokenValidateException exception = new RefreshTokenValidateException(tokenUid, description);
        String result = exception.toString();
        assertThat(result).contains(tokenUid);
        assertThat(result).contains(description);
    }

    @Test
    @DisplayName("AccessTokenValidateException toString format")
    void testAccessTokenValidateExceptionToString() {
        String tokenUid = "test-token-789";
        String description = "Validation failed";
        AccessTokenValidateException exception = new AccessTokenValidateException(tokenUid, description);
        String result = exception.toString();
        assertThat(result).contains(tokenUid);
        assertThat(result).contains(description);
    }

    @Test
    @DisplayName("RefreshTokenAlreadyExistsException toString format")
    void testRefreshTokenAlreadyExistsExceptionToString() {
        String tokenUid = "test-token-012";
        RefreshTokenAlreadyExisistsException exception = new RefreshTokenAlreadyExisistsException(tokenUid);
        String result = exception.toString();
        assertThat(result).contains(tokenUid);
    }

    @Test
    @DisplayName("RefreshTokenNotFoundException toString format")
    void testRefreshTokenNotFoundExceptionToString() {
        String tokenUid = "test-token-345";
        RefreshTokenNotFoundException exception = new RefreshTokenNotFoundException(tokenUid);
        String result = exception.toString();
        assertThat(result).contains(tokenUid);
    }

    @Test
    @DisplayName("RefreshTokenExpiredException toString format")
    void testRefreshTokenExpiredExceptionToString() {
        String tokenUid = "test-token-678";
        RefreshTokenExpiredException exception = new RefreshTokenExpiredException(tokenUid);
        String result = exception.toString();
        assertThat(result).contains(tokenUid);
    }

    @Test
    @DisplayName("RefreshTokenAddException toString format")
    void testRefreshTokenAddExceptionToString() {
        String tokenUid = "test-token-901";
        RefreshTokenAddException exception = new RefreshTokenAddException(tokenUid);
        String result = exception.toString();
        assertThat(result).contains(tokenUid);
    }

    @Test
    @DisplayName("Exception inheritance hierarchy")
    void testExceptionInheritance() {
        RefreshTokenValidateException validateException = new RefreshTokenValidateException("uid", "desc");
        RefreshTokenAlreadyExisistsException existsException = new RefreshTokenAlreadyExisistsException("uid");
        RefreshTokenNotFoundException notFoundException = new RefreshTokenNotFoundException("uid");
        RefreshTokenExpiredException expiredException = new RefreshTokenExpiredException("uid");
        RefreshTokenAddException addException = new RefreshTokenAddException("uid");
        AccessTokenValidateException accessValidateException = new AccessTokenValidateException("uid", "desc");

        assertThat(validateException).isInstanceOf(BaseTokenException.class);
        assertThat(existsException).isInstanceOf(BaseTokenException.class);
        assertThat(notFoundException).isInstanceOf(BaseTokenException.class);
        assertThat(expiredException).isInstanceOf(BaseTokenException.class);
        assertThat(addException).isInstanceOf(BaseTokenException.class);
        assertThat(accessValidateException).isInstanceOf(BaseTokenException.class);
        assertThat(validateException).isInstanceOf(RuntimeException.class);
    }
}package com.connection.token.generator;

import static com.connection.token.mother.TokenObjectMother.createValidRefreshTokenDALM;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

import javax.crypto.SecretKey;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

import com.connection.token.model.RefreshTokenDALM;

import io.jsonwebtoken.security.Keys;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Refresh Token Generator Tests")
class RefreshTokenGeneratorTest {

    private RefreshTokenGenerator generator;
    private SecretKey secretKey;

    @BeforeEach
    void setUp() {
        secretKey = Keys.hmacShaKeyFor("test-secret-key-1234567890-1234567890".getBytes());
        generator = new RefreshTokenGenerator(secretKey, "test-app", "refresh-token");
    }

    @Test
    @DisplayName("Generate refresh token from DALM - Positive")
    void testGenerateRefreshTokenFromDALM_Positive() {
        RefreshTokenDALM dalM = createValidRefreshTokenDALM();
        String token = generator.generateRefreshToken(dalM);
        assertThat(token).isNotNull().isNotEmpty();
    }

    @Test
    @DisplayName("Generate refresh token from parameters - Positive")
    void testGenerateRefreshTokenFromParameters_Positive() {
        String token = generator.generateRefreshToken(
            createValidRefreshTokenDALM().getUid(),
            createValidRefreshTokenDALM().getClientUID(),
            createValidRefreshTokenDALM().getCreatedAt(),
            createValidRefreshTokenDALM().getExpiresAt()
        );
        assertThat(token).isNotNull().isNotEmpty();
    }

    @Test
    @DisplayName("Parse valid refresh token - Positive")
    void testGetRefreshToken_Positive() {
        RefreshTokenDALM dalM = createValidRefreshTokenDALM();
        String tokenString = generator.generateRefreshToken(dalM);
        
        var result = generator.getRefreshToken(tokenString);
        assertThat(result).isNotNull();
        assertThat(result.getUid()).isEqualTo(dalM.getUid());
        assertThat(result.getClientUID()).isEqualTo(dalM.getClientUID());
    }

    @Test
    @DisplayName("Parse invalid refresh token - Negative")
    void testGetRefreshTokenWithInvalidToken_Negative() {
        assertThatThrownBy(() -> generator.getRefreshToken("invalid.token.here"))
                .isInstanceOf(RuntimeException.class);
    }
}package com.connection.token.generator;

import static com.connection.token.mother.TokenObjectMother.createValidAccessTokenDALM;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

import java.util.Date;

import javax.crypto.SecretKey;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.AccessTokenDALM;

import io.jsonwebtoken.security.Keys;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Access Token Generator Tests")
class AccessTokenGeneratorTest {
    private AccessTokenGenerator generator;
    private SecretKey secretKey;

    @BeforeEach
    void setUp() {
        secretKey = Keys.hmacShaKeyFor("test-secret-key-1234567890-1234567890".getBytes());
        generator = new AccessTokenGenerator(secretKey, "test-app", "access-token");
    }

    @Test
    @DisplayName("Generate access token - Positive")
    void testGenerateAccessToken_Positive() {
        AccessTokenDALM dalM = createValidAccessTokenDALM();
        String token = generator.generateAccessToken(
            dalM.getClientUID(),
            dalM.getCreatedAt(),
            dalM.getExpiresAt()
        );
        assertThat(token).isNotNull().isNotEmpty();
    }

    @Test
    @DisplayName("Parse valid access token - Positive")
    void testGetAccessTokenBLM_Positive() {
        AccessTokenDALM dalM = createValidAccessTokenDALM();
        String tokenString = generator.generateAccessToken(
            dalM.getClientUID(),
            dalM.getCreatedAt(),
            dalM.getExpiresAt()
        );
        
        AccessTokenBLM result = generator.getAccessTokenBLM(tokenString);
        assertThat(result).isNotNull();
        assertThat(result.getClientUID()).isEqualTo(dalM.getClientUID());
        
        // Сравниваем время в секундах (миллисекунды игнорируются)
        assertThat(result.getCreatedAt().getTime() / 1000).isEqualTo(dalM.getCreatedAt().getTime() / 1000);
        assertThat(result.getExpiresAt().getTime() / 1000).isEqualTo(dalM.getExpiresAt().getTime() / 1000);
    }

    @Test
    @DisplayName("Parse invalid access token - Negative")
    void testGetAccessTokenBLMWithInvalidToken_Negative() {
        assertThatThrownBy(() -> generator.getAccessTokenBLM("invalid.token.here"))
                .isInstanceOf(RuntimeException.class);
    }

    @Test
    @DisplayName("Parse access token with wrong subject - Negative")
    void testGetAccessTokenBLMWithWrongSubject_Negative() {
        AccessTokenGenerator wrongSubjectGenerator = new AccessTokenGenerator(secretKey, "test-app", "wrong-subject");
        AccessTokenDALM dalM = createValidAccessTokenDALM();
        
        String tokenString = generator.generateAccessToken(
            dalM.getClientUID(),
            dalM.getCreatedAt(),
            dalM.getExpiresAt()
        );
        
        assertThatThrownBy(() -> wrongSubjectGenerator.getAccessTokenBLM(tokenString))
                .isInstanceOf(RuntimeException.class)
                .hasMessageContaining("Invalid token subject");
    }

    @Test
    @DisplayName("Generate and parse round trip - Positive")
    void testGenerateAndParseRoundTrip_Positive() {
        AccessTokenDALM original = createValidAccessTokenDALM();
        
        String token = generator.generateAccessToken(
            original.getClientUID(),
            original.getCreatedAt(),
            original.getExpiresAt()
        );
        
        AccessTokenBLM parsed = generator.getAccessTokenBLM(token);
        
        assertThat(parsed.getClientUID()).isEqualTo(original.getClientUID());
        
        // Сравниваем время в секундах (миллисекунды игнорируются)
        assertThat(parsed.getCreatedAt().getTime() / 1000).isEqualTo(original.getCreatedAt().getTime() / 1000);
        assertThat(parsed.getExpiresAt().getTime() / 1000).isEqualTo(original.getExpiresAt().getTime() / 1000);
        assertThat(parsed.getToken()).isEqualTo(token);
    }

    @Test
    @DisplayName("Generate token with different dates - Positive")
    void testGenerateAccessTokenWithDifferentDates_Positive() {
        Date createdAt = new Date(System.currentTimeMillis() - 1000L * 60 * 10);
        Date expiresAt = new Date(System.currentTimeMillis() + 1000L * 60 * 30);
        
        String token = generator.generateAccessToken(
            createValidAccessTokenDALM().getClientUID(),
            createdAt,
            expiresAt
        );
        
        AccessTokenBLM result = generator.getAccessTokenBLM(token);
        
        // Сравниваем время в секундах (миллисекунды игнорируются)
        assertThat(result.getCreatedAt().getTime() / 1000).isEqualTo(createdAt.getTime() / 1000);
        assertThat(result.getExpiresAt().getTime() / 1000).isEqualTo(expiresAt.getTime() / 1000);
    }

    @Test
    @DisplayName("Generate token and verify time precision - Milliseconds ignored")
    void testGenerateAccessToken_MillisecondsIgnored() {
        // Создаем даты с разными миллисекундами
        long baseTime = System.currentTimeMillis();
        Date createdAt = new Date(baseTime + 123); // +123 мс
        Date expiresAt = new Date(baseTime + 3600000 + 456); // +456 мс
        
        String token = generator.generateAccessToken(
            createValidAccessTokenDALM().getClientUID(),
            createdAt,
            expiresAt
        );
        
        AccessTokenBLM result = generator.getAccessTokenBLM(token);
        
        // Проверяем, что миллисекунды игнорируются при сравнении
        assertThat(result.getCreatedAt().getTime() / 1000).isEqualTo(createdAt.getTime() / 1000);
        assertThat(result.getExpiresAt().getTime() / 1000).isEqualTo(expiresAt.getTime() / 1000);
        
        // Но фактически миллисекунды могут быть разными
        assertThat(result.getCreatedAt().getTime()).isNotEqualTo(createdAt.getTime());
        assertThat(result.getExpiresAt().getTime()).isNotEqualTo(expiresAt.getTime());
    }
}package com.connection.token.converter;

import static com.connection.token.mother.TokenObjectMother.createValidAccessTokenBLM;
import static com.connection.token.mother.TokenObjectMother.createValidAccessTokenDALM;
import static com.connection.token.mother.TokenObjectMother.createValidAccessTokenDTO;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

import java.util.Date;
import java.util.UUID;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import com.connection.token.generator.AccessTokenGenerator;
import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.AccessTokenDALM;
import com.connection.token.model.AccessTokenDTO;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Access Token Converter Tests")
class AccessTokenConverterTest {

    @Mock
    private AccessTokenGenerator accessTokenGenerator;

    @InjectMocks
    private AccessTokenConverter converter;

    private AccessTokenDALM testDALM;
    private AccessTokenDTO testDTO;
    private AccessTokenBLM testBLM;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        testDALM = createValidAccessTokenDALM();
        testDTO = createValidAccessTokenDTO();
        testBLM = createValidAccessTokenBLM();

        when(accessTokenGenerator.generateAccessToken(any(UUID.class), any(Date.class), any(Date.class)))
                .thenReturn("generated-access-token");
        when(accessTokenGenerator.getAccessTokenBLM(any(String.class))).thenReturn(testBLM);
    }

    @Test
    @DisplayName("Convert DALM to BLM - Positive")
    void testToBLMFromDALM_Positive() {
        AccessTokenBLM result = converter.toBLM(testDALM);
        assertThat(result).isNotNull();
        assertThat(result.getToken()).isEqualTo("generated-access-token");
    }

    @Test
    @DisplayName("Convert DTO to BLM - Positive")
    void testToBLMFromDTO_Positive() {
        AccessTokenBLM result = converter.toBLM(testDTO);
        assertThat(result).isNotNull();
        assertThat(result.getToken()).isEqualTo(testBLM.getToken());
    }

    @Test
    @DisplayName("Convert BLM to DTO - Positive")
    void testToDTOFromBLM_Positive() {
        AccessTokenDTO result = converter.toDTO(testBLM);
        assertThat(result).isNotNull();
        assertThat(result.getToken()).isEqualTo(testBLM.getToken());
    }

    @Test
    @DisplayName("Convert BLM to DALM - Positive")
    void testToDALMFromBLM_Positive() {
        AccessTokenDALM result = converter.toDALM(testBLM);
        assertThat(result).isNotNull();
        assertThat(result.getClientUID()).isEqualTo(testBLM.getClientUID());
        assertThat(result.getCreatedAt()).isEqualTo(testBLM.getCreatedAt());
        assertThat(result.getExpiresAt()).isEqualTo(testBLM.getExpiresAt());
    }
}package com.connection.token.converter;

import static com.connection.token.mother.TokenObjectMother.createValidRefreshTokenBLM;
import static com.connection.token.mother.TokenObjectMother.createValidRefreshTokenDALM;
import static com.connection.token.mother.TokenObjectMother.createValidRefreshTokenDTO;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import com.connection.token.generator.RefreshTokenGenerator;
import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDALM;
import com.connection.token.model.RefreshTokenDTO;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Refresh Token Converter Tests")
class RefreshTokenConverterTest {

    @Mock
    private RefreshTokenGenerator tokenGenerator;

    @InjectMocks
    private RefreshTokenConverter converter;

    private RefreshTokenDALM testDALM;
    private RefreshTokenDTO testDTO;
    private RefreshTokenBLM testBLM;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        testDALM = createValidRefreshTokenDALM();
        testDTO = createValidRefreshTokenDTO();
        testBLM = createValidRefreshTokenBLM();

        when(tokenGenerator.generateRefreshToken(any(RefreshTokenDALM.class))).thenReturn("generated-token");
        when(tokenGenerator.getRefreshToken(any(String.class))).thenReturn(testBLM);
    }

    @Test
    @DisplayName("Convert DALM to BLM - Positive")
    void testToBLMFromDALM_Positive() {
        RefreshTokenBLM result = converter.toBLM(testDALM);
        assertThat(result).isNotNull();
        assertThat(result.getToken()).isEqualTo("generated-token");
    }

    @Test
    @DisplayName("Convert DTO to BLM - Positive")
    void testToBLMFromDTO_Positive() {
        RefreshTokenBLM result = converter.toBLM(testDTO);
        assertThat(result).isNotNull();
        assertThat(result.getToken()).isEqualTo(testBLM.getToken());
    }

    @Test
    @DisplayName("Convert BLM to DTO - Positive")
    void testToDTOFromBLM_Positive() {
        RefreshTokenDTO result = converter.toDTO(testBLM);
        assertThat(result).isNotNull();
        assertThat(result.getToken()).isEqualTo(testBLM.getToken());
    }

    @Test
    @DisplayName("Convert BLM to DALM - Positive")
    void testToDALMFromBLM_Positive() {
        RefreshTokenDALM result = converter.toDALM(testBLM);
        assertThat(result).isNotNull();
        assertThat(result.getUid()).isEqualTo(testBLM.getUid());
        assertThat(result.getClientUID()).isEqualTo(testBLM.getClientUID());
        assertThat(result.getCreatedAt()).isEqualTo(testBLM.getCreatedAt());
        assertThat(result.getExpiresAt()).isEqualTo(testBLM.getExpiresAt());
    }
}package com.connection.token.validator;

import static com.connection.token.mother.TokenObjectMother.*;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

import com.connection.token.exception.RefreshTokenValidateException;
import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDALM;
import com.connection.token.model.RefreshTokenDTO;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Refresh Token Validator Tests")
class RefreshTokenValidatorTest {

    private RefreshTokenValidator validator;

    @BeforeEach
    void setUp() {
        validator = new RefreshTokenValidator();
    }

    @Test
    @DisplayName("Validate valid RefreshTokenDTO - Positive")
    void testValidateRefreshTokenDTO_Positive() {
        RefreshTokenDTO token = createValidRefreshTokenDTO();
        assertThat(token).isNotNull();
        validator.validate(token);
    }

    @Test
    @DisplayName("Validate valid RefreshTokenBLM - Positive")
    void testValidateRefreshTokenBLM_Positive() {
        RefreshTokenBLM token = createValidRefreshTokenBLM();
        assertThat(token).isNotNull();
        validator.validate(token);
    }

    @Test
    @DisplayName("Validate valid RefreshTokenDALM - Positive")
    void testValidateRefreshTokenDALM_Positive() {
        RefreshTokenDALM token = createValidRefreshTokenDALM();
        assertThat(token).isNotNull();
        validator.validate(token);
    }

    @Test
    @DisplayName("Validate null RefreshTokenDTO - Negative")
    void testValidateNullRefreshTokenDTO_Negative() {
        RefreshTokenDTO token = null;
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(RefreshTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate RefreshTokenDTO with empty token - Negative")
    void testValidateRefreshTokenDTOWithEmptyToken_Negative() {
        RefreshTokenDTO token = createRefreshTokenDTOWithEmptyToken();
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(RefreshTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate null RefreshTokenBLM - Negative")
    void testValidateNullRefreshTokenBLM_Negative() {
        RefreshTokenBLM token = null;
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(RefreshTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate RefreshTokenBLM with null fields - Negative")
    void testValidateRefreshTokenBLMWithNullFields_Negative() {
        RefreshTokenBLM token = createRefreshTokenBLMWithNullFields();
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(RefreshTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate null RefreshTokenDALM - Negative")
    void testValidateNullRefreshTokenDALM_Negative() {
        RefreshTokenDALM token = null;
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(RefreshTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate RefreshTokenDALM with null fields - Negative")
    void testValidateRefreshTokenDALMWithNullFields_Negative() {
        RefreshTokenDALM token = createRefreshTokenDALMWithNullFields();
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(RefreshTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate RefreshTokenBLM with expired token - Negative")
    void testValidateRefreshTokenBLMWithExpiredToken_Negative() {
        RefreshTokenBLM token = createRefreshTokenBLMWithExpiredToken();
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(RefreshTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate RefreshTokenDALM with future created date - Negative")
    void testValidateRefreshTokenDALMWithFutureCreatedAt_Negative() {
        RefreshTokenDALM token = createRefreshTokenDALMWithFutureCreatedAt();
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(RefreshTokenValidateException.class);
    }
}package com.connection.token.validator;

import static com.connection.token.mother.TokenObjectMother.*;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

import java.util.Date;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

import com.connection.token.exception.AccessTokenValidateException;
import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.AccessTokenDALM;
import com.connection.token.model.AccessTokenDTO;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Access Token Validator Tests")
class AccessTokenValidatorTest {

    private AccessTokenValidator validator;

    @BeforeEach
    void setUp() {
        validator = new AccessTokenValidator();
    }

    @Test
    @DisplayName("Validate valid AccessTokenDTO - Positive")
    void testValidateAccessTokenDTO_Positive() {
        AccessTokenDTO token = createValidAccessTokenDTO();
        assertThat(token).isNotNull();
        validator.validate(token);
    }

    @Test
    @DisplayName("Validate valid AccessTokenBLM - Positive")
    void testValidateAccessTokenBLM_Positive() {
        AccessTokenBLM token = createValidAccessTokenBLM();
        assertThat(token).isNotNull();
        validator.validate(token);
    }

    @Test
    @DisplayName("Validate valid AccessTokenDALM - Positive")
    void testValidateAccessTokenDALM_Positive() {
        AccessTokenDALM token = createValidAccessTokenDALM();
        assertThat(token).isNotNull();
        validator.validate(token);
    }

    @Test
    @DisplayName("Validate null AccessTokenDTO - Negative")
    void testValidateNullAccessTokenDTO_Negative() {
        AccessTokenDTO token = null;
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(AccessTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate AccessTokenDTO with empty token - Negative")
    void testValidateAccessTokenDTOWithEmptyToken_Negative() {
        AccessTokenDTO token = new AccessTokenDTO("");
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(AccessTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate null AccessTokenBLM - Negative")
    void testValidateNullAccessTokenBLM_Negative() {
        AccessTokenBLM token = null;
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(AccessTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate AccessTokenBLM with expired token - Negative")
    void testValidateAccessTokenBLMWithExpiredToken_Negative() {
        Date expiredDate = new Date(System.currentTimeMillis() - 1000L * 60 * 60);
        AccessTokenBLM token = new AccessTokenBLM(
            "test-token",
            createValidAccessTokenBLM().getClientUID(),
            createValidAccessTokenBLM().getCreatedAt(),
            expiredDate
        );
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(AccessTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate AccessTokenBLM with future created date - Negative")
    void testValidateAccessTokenBLMWithFutureCreatedAt_Negative() {
        Date futureDate = new Date(System.currentTimeMillis() + 1000L * 60 * 60);
        AccessTokenBLM token = new AccessTokenBLM(
            "test-token",
            createValidAccessTokenBLM().getClientUID(),
            futureDate,
            createValidAccessTokenBLM().getExpiresAt()
        );
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(AccessTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate null AccessTokenDALM - Negative")
    void testValidateNullAccessTokenDALM_Negative() {
        AccessTokenDALM token = null;
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(AccessTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate AccessTokenDALM with null client UID - Negative")
    void testValidateAccessTokenDALMWithNullClientUID_Negative() {
        AccessTokenDALM token = new AccessTokenDALM(
            null,
            createValidAccessTokenDALM().getCreatedAt(),
            createValidAccessTokenDALM().getExpiresAt()
        );
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(AccessTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate AccessTokenDALM with expired token - Negative")
    void testValidateAccessTokenDALMWithExpiredToken_Negative() {
        Date expiredDate = new Date(System.currentTimeMillis() - 1000L * 60 * 60);
        AccessTokenDALM token = new AccessTokenDALM(
            createValidAccessTokenDALM().getClientUID(),
            createValidAccessTokenDALM().getCreatedAt(),
            expiredDate
        );
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(AccessTokenValidateException.class);
    }
}package com.connection.token.mother;

import java.util.Date;
import java.util.UUID;

import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.AccessTokenDALM;
import com.connection.token.model.AccessTokenDTO;
import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDALM;
import com.connection.token.model.RefreshTokenDTO;

public class TokenObjectMother {

    private static final UUID DEFAULT_UID = UUID.fromString("123e4567-e89b-12d3-a456-426614174000");
    private static final UUID DEFAULT_CLIENT_UID = UUID.fromString("123e4567-e89b-12d3-a456-426614174001");
    private static final String DEFAULT_TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c";
    private static final Date DEFAULT_CREATED_AT = new Date(System.currentTimeMillis() - 1000L * 60 * 5);
    private static final Date DEFAULT_EXPIRES_AT = new Date(System.currentTimeMillis() + 1000L * 60 * 60 * 24);

    public static RefreshTokenDTO createValidRefreshTokenDTO() {
        return new RefreshTokenDTO(DEFAULT_TOKEN);
    }

    public static RefreshTokenBLM createValidRefreshTokenBLM() {
        return new RefreshTokenBLM(DEFAULT_TOKEN, DEFAULT_UID, DEFAULT_CLIENT_UID, DEFAULT_CREATED_AT, DEFAULT_EXPIRES_AT);
    }

    public static RefreshTokenDALM createValidRefreshTokenDALM() {
        return new RefreshTokenDALM(DEFAULT_TOKEN, DEFAULT_UID, DEFAULT_CLIENT_UID, DEFAULT_CREATED_AT, DEFAULT_EXPIRES_AT);
    }

    public static AccessTokenDTO createValidAccessTokenDTO() {
        return new AccessTokenDTO(DEFAULT_TOKEN);
    }

    public static AccessTokenBLM createValidAccessTokenBLM() {
        return new AccessTokenBLM(DEFAULT_TOKEN, DEFAULT_CLIENT_UID, DEFAULT_CREATED_AT, DEFAULT_EXPIRES_AT);
    }

    public static AccessTokenDALM createValidAccessTokenDALM() {
        return new AccessTokenDALM(DEFAULT_CLIENT_UID, DEFAULT_CREATED_AT, DEFAULT_EXPIRES_AT);
    }

    public static RefreshTokenDTO createRefreshTokenDTOWithEmptyToken() {
        return new RefreshTokenDTO("");
    }

    public static RefreshTokenBLM createRefreshTokenBLMWithNullFields() {
        return new RefreshTokenBLM(null, null, null, null, null);
    }

    public static RefreshTokenDALM createRefreshTokenDALMWithNullFields() {
        return new RefreshTokenDALM(null, null, null, null, null);
    }

    public static RefreshTokenBLM createRefreshTokenBLMWithExpiredToken() {
        Date expiredDate = new Date(System.currentTimeMillis() - 1000L * 60 * 60);
        return new RefreshTokenBLM(DEFAULT_TOKEN, DEFAULT_UID, DEFAULT_CLIENT_UID, DEFAULT_CREATED_AT, expiredDate);
    }

    public static RefreshTokenDALM createRefreshTokenDALMWithFutureCreatedAt() {
        Date futureDate = new Date(System.currentTimeMillis() + 1000L * 60 * 60);
        return new RefreshTokenDALM(DEFAULT_TOKEN, DEFAULT_UID, DEFAULT_CLIENT_UID, futureDate, DEFAULT_EXPIRES_AT);
    }

    public static RefreshTokenDALM createRefreshTokenForClient(UUID clientUid) {
        return new RefreshTokenDALM(DEFAULT_TOKEN, UUID.randomUUID(), clientUid, DEFAULT_CREATED_AT, DEFAULT_EXPIRES_AT);
    }
}package com.connection.token.repository;

import static com.connection.token.mother.TokenObjectMother.createValidRefreshTokenDALM;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.connection.token.exception.RefreshTokenAlreadyExisistsException;
import com.connection.token.exception.RefreshTokenNotFoundException;
import com.connection.token.model.RefreshTokenDALM;

@TestMethodOrder(MethodOrderer.Random.class)
@DisplayName("Refresh Token Repository Tests - SQL implementation tests")
class RefreshTokenRepositorySQLImplTest {

    @Mock
    private NamedParameterJdbcTemplate jdbcTemplate;

    @InjectMocks
    private RefreshTokenRepositorySQLImpl repository;

    private RefreshTokenDALM testToken;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        testToken = createValidRefreshTokenDALM();
    }

    @SuppressWarnings("unchecked")
@Test
    @DisplayName("Add refresh token - Positive")
    void testAddRefreshToken_Positive() {
        when(jdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenThrow(new EmptyResultDataAccessException(1));
        when(jdbcTemplate.update(anyString(), any(MapSqlParameterSource.class))).thenReturn(1);

        repository.add(testToken);

        verify(jdbcTemplate, times(2)).queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class));
        verify(jdbcTemplate, times(1)).update(anyString(), any(MapSqlParameterSource.class));
    }

    @SuppressWarnings("unchecked")
@Test
    @DisplayName("Add existing refresh token - Negative")
    void testAddExistingRefreshToken_Negative() {
        when(jdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenReturn(testToken);

        assertThatThrownBy(() -> repository.add(testToken))
                .isInstanceOf(RefreshTokenAlreadyExisistsException.class);

        verify(jdbcTemplate, never()).update(anyString(), any(MapSqlParameterSource.class));
    }

    @SuppressWarnings("unchecked")
@Test
    @DisplayName("Revoke refresh token - Positive")
    void testRevokeRefreshToken_Positive() {
        when(jdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenReturn(testToken);
        when(jdbcTemplate.update(anyString(), any(MapSqlParameterSource.class))).thenReturn(1);

        repository.revoke(testToken);

        verify(jdbcTemplate, times(1)).update(
                eq("DELETE FROM \"access\".refresh_token WHERE uid = :uid"),
                any(MapSqlParameterSource.class));
    }

    @SuppressWarnings("unchecked")
@Test
    @DisplayName("Revoke non-existent refresh token - Negative")
    void testRevokeNonExistentRefreshToken_Negative() {
        when(jdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenThrow(new EmptyResultDataAccessException(1));

        assertThatThrownBy(() -> repository.revoke(testToken))
                .isInstanceOf(RefreshTokenNotFoundException.class);

        verify(jdbcTemplate, never()).update(anyString(), any(MapSqlParameterSource.class));
    }

    @Test
    @DisplayName("Revoke all client tokens - Positive")
    void testRevokeAllClientTokens_Positive() {
        when(jdbcTemplate.update(anyString(), any(MapSqlParameterSource.class))).thenReturn(1);

        repository.revokeAll(testToken.getClientUID());

        verify(jdbcTemplate, times(1)).update(
                eq("DELETE FROM \"access\".refresh_token WHERE client_id = :client_id"),
                any(MapSqlParameterSource.class));
    }

    @Test
    @DisplayName("Cleanup expired tokens - Positive")
    void testCleanupExpiredTokens_Positive() {
        when(jdbcTemplate.update(anyString(), any(MapSqlParameterSource.class))).thenReturn(1);

        repository.cleanUpExpired();

        verify(jdbcTemplate, times(1)).update(
                eq("DELETE FROM \"access\".refresh_token WHERE expires_at < NOW()"),
                any(MapSqlParameterSource.class));
    }

    @SuppressWarnings("unchecked")
@Test
    @DisplayName("Check token exists - Positive")
    void testTokenExists_Positive() {
        when(jdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenReturn(testToken);

        boolean result = repository.tokenExists(testToken.getToken());

        assertThat(result).isTrue();
    }

    @SuppressWarnings("unchecked")
@Test
    @DisplayName("Check token exists - Negative")
    void testTokenExists_Negative() {
        when(jdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenThrow(new EmptyResultDataAccessException(1));

        boolean result = repository.tokenExists(testToken.getToken());

        assertThat(result).isFalse();
    }
}package com.connection.token.exception;

public class AccessTokenValidateException extends BaseTokenException{
    String descriptionString;
    public AccessTokenValidateException(String tokenString, String description){
        super(tokenString);
        this.descriptionString = description;
    }

    public String toString(){
        String res = super.toString();
        res += "\n" + "description: Access token is invalid";
        res += "\n" + descriptionString;
        return res;
    }
}
package com.connection.token.exception;

import static org.assertj.core.api.Assertions.assertThat;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Token Exception Tests")
class TokenExceptionTest {

    @Test
    @DisplayName("BaseTokenException toString format")
    void testBaseTokenExceptionToString() {
        String tokenUid = "test-token-123";
        BaseTokenException exception = new BaseTokenException(tokenUid);
        String result = exception.toString();
        assertThat(result).contains(tokenUid);
    }

    @Test
    @DisplayName("RefreshTokenValidateException toString format")
    void testRefreshTokenValidateExceptionToString() {
        String tokenUid = "test-token-456";
        String description = "Validation failed";
        RefreshTokenValidateException exception = new RefreshTokenValidateException(tokenUid, description);
        String result = exception.toString();
        assertThat(result).contains(tokenUid);
        assertThat(result).contains(description);
    }

    @Test
    @DisplayName("AccessTokenValidateException toString format")
    void testAccessTokenValidateExceptionToString() {
        String tokenUid = "test-token-789";
        String description = "Validation failed";
        AccessTokenValidateException exception = new AccessTokenValidateException(tokenUid, description);
        String result = exception.toString();
        assertThat(result).contains(tokenUid);
        assertThat(result).contains(description);
    }

    @Test
    @DisplayName("RefreshTokenAlreadyExistsException toString format")
    void testRefreshTokenAlreadyExistsExceptionToString() {
        String tokenUid = "test-token-012";
        RefreshTokenAlreadyExisistsException exception = new RefreshTokenAlreadyExisistsException(tokenUid);
        String result = exception.toString();
        assertThat(result).contains(tokenUid);
    }

    @Test
    @DisplayName("RefreshTokenNotFoundException toString format")
    void testRefreshTokenNotFoundExceptionToString() {
        String tokenUid = "test-token-345";
        RefreshTokenNotFoundException exception = new RefreshTokenNotFoundException(tokenUid);
        String result = exception.toString();
        assertThat(result).contains(tokenUid);
    }

    @Test
    @DisplayName("RefreshTokenExpiredException toString format")
    void testRefreshTokenExpiredExceptionToString() {
        String tokenUid = "test-token-678";
        RefreshTokenExpiredException exception = new RefreshTokenExpiredException(tokenUid);
        String result = exception.toString();
        assertThat(result).contains(tokenUid);
    }

    @Test
    @DisplayName("RefreshTokenAddException toString format")
    void testRefreshTokenAddExceptionToString() {
        String tokenUid = "test-token-901";
        RefreshTokenAddException exception = new RefreshTokenAddException(tokenUid);
        String result = exception.toString();
        assertThat(result).contains(tokenUid);
    }

    @Test
    @DisplayName("Exception inheritance hierarchy")
    void testExceptionInheritance() {
        RefreshTokenValidateException validateException = new RefreshTokenValidateException("uid", "desc");
        RefreshTokenAlreadyExisistsException existsException = new RefreshTokenAlreadyExisistsException("uid");
        RefreshTokenNotFoundException notFoundException = new RefreshTokenNotFoundException("uid");
        RefreshTokenExpiredException expiredException = new RefreshTokenExpiredException("uid");
        RefreshTokenAddException addException = new RefreshTokenAddException("uid");
        AccessTokenValidateException accessValidateException = new AccessTokenValidateException("uid", "desc");

        assertThat(validateException).isInstanceOf(BaseTokenException.class);
        assertThat(existsException).isInstanceOf(BaseTokenException.class);
        assertThat(notFoundException).isInstanceOf(BaseTokenException.class);
        assertThat(expiredException).isInstanceOf(BaseTokenException.class);
        assertThat(addException).isInstanceOf(BaseTokenException.class);
        assertThat(accessValidateException).isInstanceOf(BaseTokenException.class);
        assertThat(validateException).isInstanceOf(RuntimeException.class);
    }
}package com.connection.token.repository;

import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Timestamp;
import java.util.Date;
import java.util.UUID;

import com.connection.token.exception.RefreshTokenAlreadyExisistsException;
import com.connection.token.exception.RefreshTokenNotFoundException;
import com.connection.token.model.RefreshTokenDALM;

@Repository
public class RefreshTokenRepositorySQLImpl implements RefreshTokenRepository {

    private static final String SELECT_REFRESH_TOKEN = "SELECT uid, client_id, token, family_id, created_at, expires_at";
    private static final String FROM_REFRESH_TOKEN = " FROM public.refresh_token";

    private static final String SELECT_TOKEN_BY_UID = SELECT_REFRESH_TOKEN + FROM_REFRESH_TOKEN + " WHERE uid = :uid";
    private static final String SELECT_TOKEN_BY_TOKEN = SELECT_REFRESH_TOKEN + FROM_REFRESH_TOKEN + " WHERE token = :token";
    // private static final String SELECT_TOKENS_BY_CLIENT = SELECT_REFRESH_TOKEN + FROM_REFRESH_TOKEN + " WHERE client_id = :client_id";
    // private static final String SELECT_TOKEN_BY_FAMILY = SELECT_REFRESH_TOKEN + FROM_REFRESH_TOKEN + " WHERE family_id = :family_id";

    private static final String INSERT_REFRESH_TOKEN = "INSERT INTO public.refresh_token (uid, client_id, token, family_id, created_at, expires_at) " +
            "VALUES (:uid, :client_id, :token, :family_id, :created_at, :expires_at)";

    private static final String UPDATE_TOKEN = "UPDATE public.refresh_token SET token = :new_token, expires_at = :new_expires_at, created_at = :new_created_at " +
            "WHERE uid = :uid";

    private static final String REVOKE_TOKEN = "DELETE FROM public.refresh_token WHERE uid = :uid";
    private static final String REVOKE_ALL_CLIENT_TOKENS = "DELETE FROM public.refresh_token WHERE client_id = :client_id";
    private static final String CLEANUP_EXPIRED_TOKENS = "DELETE FROM public.refresh_token WHERE expires_at < NOW()";

    private final NamedParameterJdbcTemplate jdbcTemplate;

    private final RowMapper<RefreshTokenDALM> refreshTokenRowMapper = (rs, rowNum) -> {
        RefreshTokenDALM token = new RefreshTokenDALM();
        token.setUid(UUID.fromString(rs.getString("uid")));
        token.setClientUID(UUID.fromString(rs.getString("client_id")));
        token.setToken(rs.getString("token"));
        token.setCreatedAt(rs.getTimestamp("created_at"));
        token.setExpiresAt(rs.getTimestamp("expires_at"));
        return token;
    };

    public RefreshTokenRepositorySQLImpl(NamedParameterJdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    @Transactional
    public void add(RefreshTokenDALM refreshTokenDALM) throws RefreshTokenAlreadyExisistsException {
        // Проверяем существование по token
        if (tokenExists(refreshTokenDALM.getToken())) {
            throw new RefreshTokenAlreadyExisistsException("Refresh token already exists");
        }

        // Проверяем существование по uid
        if (uidExists(refreshTokenDALM.getUid())) {
            throw new RefreshTokenAlreadyExisistsException("Refresh token with UID " + refreshTokenDALM.getUid() + " already exists");
        }

        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", refreshTokenDALM.getUid());
        params.addValue("client_id", refreshTokenDALM.getClientUID());
        params.addValue("token", refreshTokenDALM.getToken());
        params.addValue("family_id", refreshTokenDALM.getUid()); // Используем uid как family_id для простоты
        params.addValue("created_at", new Timestamp(refreshTokenDALM.getCreatedAt().getTime()));
        params.addValue("expires_at", new Timestamp(refreshTokenDALM.getExpiresAt().getTime()));

        jdbcTemplate.update(INSERT_REFRESH_TOKEN, params);
    }

    @Override
    @Transactional
    public void updateToken(RefreshTokenDALM refreshTokenDALM, RefreshTokenDALM newRefreshTokenDALM) 
            throws RefreshTokenNotFoundException {
        // Проверяем существование старого токена
        if (!uidExists(refreshTokenDALM.getUid())) {
            throw new RefreshTokenNotFoundException("Refresh token with UID " + refreshTokenDALM.getUid() + " not found");
        }

        // Проверяем что новый токен не существует
        if (tokenExists(newRefreshTokenDALM.getToken())) {
            throw new RefreshTokenAlreadyExisistsException("Refresh token already exists");
        }

        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", refreshTokenDALM.getUid());
        params.addValue("new_token", newRefreshTokenDALM.getToken());
        params.addValue("new_created_at", new Timestamp(newRefreshTokenDALM.getCreatedAt().getTime()));
        params.addValue("new_expires_at", new Timestamp(newRefreshTokenDALM.getExpiresAt().getTime()));

        jdbcTemplate.update(UPDATE_TOKEN, params);
    }

    @Override
    @Transactional
    public void revoke(RefreshTokenDALM refreshTokenDALM) throws RefreshTokenNotFoundException {
        // Проверяем существование токена
        if (!uidExists(refreshTokenDALM.getUid())) {
            throw new RefreshTokenNotFoundException("Refresh token with UID " + refreshTokenDALM.getUid() + " not found");
        }

        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", refreshTokenDALM.getUid());

        jdbcTemplate.update(REVOKE_TOKEN, params);
    }

    @Override
    @Transactional
    public void revokeAll(UUID clientUUID) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("client_id", clientUUID);

        jdbcTemplate.update(REVOKE_ALL_CLIENT_TOKENS, params);
    }

    @Override
    @Transactional
    public void cleanUpExpired() {
        jdbcTemplate.update(CLEANUP_EXPIRED_TOKENS, new MapSqlParameterSource());
    }

    // Вспомогательные методы
    @Transactional(readOnly = true)
    boolean uidExists(UUID uid) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", uid);
        try {
            jdbcTemplate.queryForObject(SELECT_TOKEN_BY_UID, params, refreshTokenRowMapper);
            return true;
        } catch (EmptyResultDataAccessException e) {
            return false;
        }
    }

    @Transactional(readOnly = true)
    boolean tokenExists(String token) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("token", token);
        try {
            jdbcTemplate.queryForObject(SELECT_TOKEN_BY_TOKEN, params, refreshTokenRowMapper);
            return true;
        } catch (EmptyResultDataAccessException e) {
            return false;
        }
    }

    // Дополнительные методы для внутреннего использования
    @Transactional(readOnly = true)
    RefreshTokenDALM findByUid(UUID uid) throws RefreshTokenNotFoundException {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", uid);
        try {
            return jdbcTemplate.queryForObject(SELECT_TOKEN_BY_UID, params, refreshTokenRowMapper);
        } catch (EmptyResultDataAccessException e) {
            throw new RefreshTokenNotFoundException("Refresh token with UID " + uid + " not found");
        }
    }

    @Transactional(readOnly = true)
    RefreshTokenDALM findByToken(String token) throws RefreshTokenNotFoundException {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("token", token);
        try {
            return jdbcTemplate.queryForObject(SELECT_TOKEN_BY_TOKEN, params, refreshTokenRowMapper);
        } catch (EmptyResultDataAccessException e) {
            throw new RefreshTokenNotFoundException("Refresh token not found");
        }
    }

    @Transactional(readOnly = true)
    boolean isTokenValid(String token) {
        try {
            RefreshTokenDALM refreshToken = findByToken(token);
            return refreshToken.getExpiresAt().after(new Date());
        } catch (RefreshTokenNotFoundException e) {
            return false;
        }
    }
}package com.connection.token.model;

import java.util.Date;
import java.util.UUID;

import jakarta.persistence.Entity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Builder
public class RefreshTokenBLM {
    protected String token;
    protected UUID uid;
    protected UUID clientUID;
    
    protected Date createdAt;
    protected Date expiresAt;
}
package com.connection.token.converter;

import com.connection.token.generator.RefreshTokenGenerator;
import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDALM;
import com.connection.token.model.RefreshTokenDTO;

import io.jsonwebtoken.JwtException;
import jakarta.annotation.Nonnull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class RefreshTokenConverter {
    @Nonnull
    private final RefreshTokenGenerator tokenGenerator;
    public RefreshTokenBLM toBLM(RefreshTokenDALM dalm) {
        String token  = tokenGenerator.generateRefreshToken(dalm);
        return new RefreshTokenBLM(token,
                dalm.getUid(),
                dalm.getClientUID(),
                dalm.getCreatedAt(),
                dalm.getExpiresAt());
    }

    public RefreshTokenBLM toBLM(RefreshTokenDTO dto) {
        try {
            RefreshTokenBLM tokenBLM = tokenGenerator.getRefreshToken(dto.getToken());
            return tokenBLM;
        } catch (JwtException e) {
            throw new RuntimeException("Invalid JWT token: " + e.getMessage(), e);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException("Malformed JWT token", e);
        }
    }

    public RefreshTokenDTO toDTO(RefreshTokenBLM blm){
        return new RefreshTokenDTO(blm.getToken());
    }

    public RefreshTokenDALM toDALM(RefreshTokenBLM blm){
        return new RefreshTokenDALM(blm.getToken(), 
                                    blm.getUid(),
                                    blm.getClientUID(), 
                                    blm.getCreatedAt(), 
                                    blm.getExpiresAt());
    }
}

package com.connection.token.mother;

import java.util.Date;
import java.util.UUID;

import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.AccessTokenDALM;
import com.connection.token.model.AccessTokenDTO;
import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDALM;
import com.connection.token.model.RefreshTokenDTO;

public class TokenObjectMother {

    private static final UUID DEFAULT_UID = UUID.fromString("123e4567-e89b-12d3-a456-426614174000");
    private static final UUID DEFAULT_CLIENT_UID = UUID.fromString("123e4567-e89b-12d3-a456-426614174001");
    private static final String DEFAULT_TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c";
    private static final Date DEFAULT_CREATED_AT = new Date(System.currentTimeMillis() - 1000L * 60 * 5);
    private static final Date DEFAULT_EXPIRES_AT = new Date(System.currentTimeMillis() + 1000L * 60 * 60 * 24);

    public static RefreshTokenDTO createValidRefreshTokenDTO() {
        return new RefreshTokenDTO(DEFAULT_TOKEN);
    }

    public static RefreshTokenBLM createValidRefreshTokenBLM() {
        return new RefreshTokenBLM(DEFAULT_TOKEN, DEFAULT_UID, DEFAULT_CLIENT_UID, DEFAULT_CREATED_AT, DEFAULT_EXPIRES_AT);
    }

    public static RefreshTokenDALM createValidRefreshTokenDALM() {
        return new RefreshTokenDALM(DEFAULT_TOKEN, DEFAULT_UID, DEFAULT_CLIENT_UID, DEFAULT_CREATED_AT, DEFAULT_EXPIRES_AT);
    }

    public static AccessTokenDTO createValidAccessTokenDTO() {
        return new AccessTokenDTO(DEFAULT_TOKEN);
    }

    public static AccessTokenBLM createValidAccessTokenBLM() {
        return new AccessTokenBLM(DEFAULT_TOKEN, DEFAULT_CLIENT_UID, DEFAULT_CREATED_AT, DEFAULT_EXPIRES_AT);
    }

    public static AccessTokenDALM createValidAccessTokenDALM() {
        return new AccessTokenDALM(DEFAULT_CLIENT_UID, DEFAULT_CREATED_AT, DEFAULT_EXPIRES_AT);
    }

    public static RefreshTokenDTO createRefreshTokenDTOWithEmptyToken() {
        return new RefreshTokenDTO("");
    }

    public static RefreshTokenBLM createRefreshTokenBLMWithNullFields() {
        return new RefreshTokenBLM(null, null, null, null, null);
    }

    public static RefreshTokenDALM createRefreshTokenDALMWithNullFields() {
        return new RefreshTokenDALM(null, null, null, null, null);
    }

    public static RefreshTokenBLM createRefreshTokenBLMWithExpiredToken() {
        Date expiredDate = new Date(System.currentTimeMillis() - 1000L * 60 * 60);
        return new RefreshTokenBLM(DEFAULT_TOKEN, DEFAULT_UID, DEFAULT_CLIENT_UID, DEFAULT_CREATED_AT, expiredDate);
    }

    public static RefreshTokenDALM createRefreshTokenDALMWithFutureCreatedAt() {
        Date futureDate = new Date(System.currentTimeMillis() + 1000L * 60 * 60);
        return new RefreshTokenDALM(DEFAULT_TOKEN, DEFAULT_UID, DEFAULT_CLIENT_UID, futureDate, DEFAULT_EXPIRES_AT);
    }

    public static RefreshTokenDALM createRefreshTokenForClient(UUID clientUid) {
        return new RefreshTokenDALM(DEFAULT_TOKEN, UUID.randomUUID(), clientUid, DEFAULT_CREATED_AT, DEFAULT_EXPIRES_AT);
    }
}package com.connection.token.exception;

public class RefreshTokenAddException extends BaseTokenException{
    public RefreshTokenAddException(String tokenString){
        super(tokenString);
    }

    public String toString(){
        String res = super.toString();
        res += "\n" + "description: cannot add refresh token";
        return res;
    }
}
package com.connection.token.generator;

import java.util.Date;
import java.util.UUID;

import javax.crypto.SecretKey;

import com.connection.token.model.AccessTokenBLM;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import io.jsonwebtoken.Jwts;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class AccessTokenGenerator {
    @NonNull
    private final SecretKey jwtSecretKey;

    @NonNull
    private final String appNameString;

    @NonNull
    private final String jwtSubjecString;

    public String generateAccessToken(UUID clientUuid, Date createdAtDate, Date expiresAtDate) {
        String token = Jwts.builder()
                .issuer(appNameString)
                .subject(jwtSubjecString)
                .claim("clientUid", clientUuid.toString())
                .issuedAt(createdAtDate)
                .expiration(expiresAtDate)
                .signWith(jwtSecretKey)
                .compact();
        return token;
    }

    public AccessTokenBLM getAccessTokenBLM(String token) {
        Jws<Claims> jws = Jwts.parser()
                .verifyWith(jwtSecretKey)
                .build()
                .parseSignedClaims(token);

        Claims claims = jws.getPayload();

        UUID clientUid = UUID.fromString(claims.get("clientUid", String.class));
        Date issuedAt = claims.getIssuedAt();
        Date expiration = claims.getExpiration();

        if (!jwtSubjecString.equals(claims.getSubject())) {
            throw new RuntimeException("Invalid token subject");
        }

        return new AccessTokenBLM(token, clientUid, issuedAt, expiration);
    }
}
package com.connection.token.exception;

public class RefreshTokenNotFoundException extends BaseTokenException {
    public RefreshTokenNotFoundException(String tokenString) {
        super(tokenString);
    }

    public String toString() {
        String res = super.toString();
        res += "\n" + "description: refresh token not found";
        return res;
    }
}
package com.connection.token.model;

import java.util.Date;
import java.util.UUID;

import jakarta.persistence.Entity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Builder
public class RefreshTokenDALM {
    protected String token;

    
    protected UUID uid;
    
    protected UUID clientUID;
    
    protected Date createdAt;
    
    protected Date expiresAt;
}
package com.connection.token.model;
import jakarta.persistence.Entity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Builder
public class AccessTokenDTO {
    protected String token;
}
package com.connection.token.model;

import jakarta.persistence.Entity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Builder
public class RefreshTokenDTO {
    protected String token;
}
package com.connection.token.repository;

import static com.connection.token.mother.TokenObjectMother.createValidRefreshTokenDALM;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.connection.token.exception.RefreshTokenAlreadyExisistsException;
import com.connection.token.exception.RefreshTokenNotFoundException;
import com.connection.token.model.RefreshTokenDALM;

@TestMethodOrder(MethodOrderer.Random.class)
@DisplayName("Refresh Token Repository Tests - SQL implementation tests")
class RefreshTokenRepositorySQLImplTest {

    @Mock
    private NamedParameterJdbcTemplate jdbcTemplate;

    @InjectMocks
    private RefreshTokenRepositorySQLImpl repository;

    private RefreshTokenDALM testToken;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        testToken = createValidRefreshTokenDALM();
    }

    @SuppressWarnings("unchecked")
@Test
    @DisplayName("Add refresh token - Positive")
    void testAddRefreshToken_Positive() {
        when(jdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenThrow(new EmptyResultDataAccessException(1));
        when(jdbcTemplate.update(anyString(), any(MapSqlParameterSource.class))).thenReturn(1);

        repository.add(testToken);

        verify(jdbcTemplate, times(2)).queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class));
        verify(jdbcTemplate, times(1)).update(anyString(), any(MapSqlParameterSource.class));
    }

    @SuppressWarnings("unchecked")
@Test
    @DisplayName("Add existing refresh token - Negative")
    void testAddExistingRefreshToken_Negative() {
        when(jdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenReturn(testToken);

        assertThatThrownBy(() -> repository.add(testToken))
                .isInstanceOf(RefreshTokenAlreadyExisistsException.class);

        verify(jdbcTemplate, never()).update(anyString(), any(MapSqlParameterSource.class));
    }

    @SuppressWarnings("unchecked")
@Test
    @DisplayName("Revoke refresh token - Positive")
    void testRevokeRefreshToken_Positive() {
        when(jdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenReturn(testToken);
        when(jdbcTemplate.update(anyString(), any(MapSqlParameterSource.class))).thenReturn(1);

        repository.revoke(testToken);

        verify(jdbcTemplate, times(1)).update(
                eq("DELETE FROM public.refresh_token WHERE uid = :uid"),
                any(MapSqlParameterSource.class));
    }

    @SuppressWarnings("unchecked")
@Test
    @DisplayName("Revoke non-existent refresh token - Negative")
    void testRevokeNonExistentRefreshToken_Negative() {
        when(jdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenThrow(new EmptyResultDataAccessException(1));

        assertThatThrownBy(() -> repository.revoke(testToken))
                .isInstanceOf(RefreshTokenNotFoundException.class);

        verify(jdbcTemplate, never()).update(anyString(), any(MapSqlParameterSource.class));
    }

    @Test
    @DisplayName("Revoke all client tokens - Positive")
    void testRevokeAllClientTokens_Positive() {
        when(jdbcTemplate.update(anyString(), any(MapSqlParameterSource.class))).thenReturn(1);

        repository.revokeAll(testToken.getClientUID());

        verify(jdbcTemplate, times(1)).update(
                eq("DELETE FROM public.refresh_token WHERE client_id = :client_id"),
                any(MapSqlParameterSource.class));
    }

    @Test
    @DisplayName("Cleanup expired tokens - Positive")
    void testCleanupExpiredTokens_Positive() {
        when(jdbcTemplate.update(anyString(), any(MapSqlParameterSource.class))).thenReturn(1);

        repository.cleanUpExpired();

        verify(jdbcTemplate, times(1)).update(
                eq("DELETE FROM public.refresh_token WHERE expires_at < NOW()"),
                any(MapSqlParameterSource.class));
    }

    @SuppressWarnings("unchecked")
@Test
    @DisplayName("Check token exists - Positive")
    void testTokenExists_Positive() {
        when(jdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenReturn(testToken);

        boolean result = repository.tokenExists(testToken.getToken());

        assertThat(result).isTrue();
    }

    @SuppressWarnings("unchecked")
@Test
    @DisplayName("Check token exists - Negative")
    void testTokenExists_Negative() {
        when(jdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenThrow(new EmptyResultDataAccessException(1));

        boolean result = repository.tokenExists(testToken.getToken());

        assertThat(result).isFalse();
    }
}package com.connection.token.model;

import java.util.Date;
import java.util.UUID;

import jakarta.persistence.Entity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Builder
public class AccessTokenBLM {
    protected String token;
    protected UUID clientUID;
    protected Date createdAt;
    protected Date expiresAt;
}
package com.connection.token.exception;

public class RefreshTokenExpiredException extends BaseTokenException {
    public RefreshTokenExpiredException(String tokenString) {
        super(tokenString);
    }

    public String toString() {
        String res = super.toString();
        res += "\n" + "description: refresh token is expired";
        return res;
    }
}
package com.connection.token.converter;

import static com.connection.token.mother.TokenObjectMother.*;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

import java.util.Date;
import java.util.UUID;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import com.connection.token.generator.AccessTokenGenerator;
import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.AccessTokenDALM;
import com.connection.token.model.AccessTokenDTO;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Access Token Converter Tests")
class AccessTokenConverterTest {

    @Mock
    private AccessTokenGenerator accessTokenGenerator;

    @InjectMocks
    private AccessTokenConverter converter;

    private AccessTokenDALM testDALM;
    private AccessTokenDTO testDTO;
    private AccessTokenBLM testBLM;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        testDALM = createValidAccessTokenDALM();
        testDTO = createValidAccessTokenDTO();
        testBLM = createValidAccessTokenBLM();

        when(accessTokenGenerator.generateAccessToken(any(UUID.class), any(Date.class), any(Date.class)))
                .thenReturn("generated-access-token");
        when(accessTokenGenerator.getAccessTokenBLM(any(String.class))).thenReturn(testBLM);
    }

    @Test
    @DisplayName("Convert DALM to BLM - Positive")
    void testToBLMFromDALM_Positive() {
        AccessTokenBLM result = converter.toBLM(testDALM);
        assertThat(result).isNotNull();
        assertThat(result.getToken()).isEqualTo("generated-access-token");
    }

    @Test
    @DisplayName("Convert DTO to BLM - Positive")
    void testToBLMFromDTO_Positive() {
        AccessTokenBLM result = converter.toBLM(testDTO);
        assertThat(result).isNotNull();
        assertThat(result.getToken()).isEqualTo(testBLM.getToken());
    }

    @Test
    @DisplayName("Convert BLM to DTO - Positive")
    void testToDTOFromBLM_Positive() {
        AccessTokenDTO result = converter.toDTO(testBLM);
        assertThat(result).isNotNull();
        assertThat(result.getToken()).isEqualTo(testBLM.getToken());
    }

    @Test
    @DisplayName("Convert BLM to DALM - Positive")
    void testToDALMFromBLM_Positive() {
        AccessTokenDALM result = converter.toDALM(testBLM);
        assertThat(result).isNotNull();
        assertThat(result.getClientUID()).isEqualTo(testBLM.getClientUID());
        assertThat(result.getCreatedAt()).isEqualTo(testBLM.getCreatedAt());
        assertThat(result.getExpiresAt()).isEqualTo(testBLM.getExpiresAt());
    }
}package com.connection.token.exception;

public class RefreshTokenValidateException extends BaseTokenException{
    String descriptionString;
    public RefreshTokenValidateException(String tokenString, String description){
        super(tokenString);
        this.descriptionString = description;
    }

    public String toString(){
        String res = super.toString();
        res += "\n" + "description: refresh token is invalid";
        res += "\n" + descriptionString;
        return res;
    }
}
package com.connection.token.exception;

public class BaseTokenException extends RuntimeException{
    private final String tokenString;

    public BaseTokenException(String tokenDescription){
        super("token");
        tokenString = tokenDescription;
    }

    public String toString(){
        String res = super.toString();
        res += "\n" + "token: " + tokenString;
        return res;
    }
}
package com.connection.token.validator;

import static com.connection.token.mother.TokenObjectMother.*;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

import com.connection.token.exception.RefreshTokenValidateException;
import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDALM;
import com.connection.token.model.RefreshTokenDTO;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Refresh Token Validator Tests")
class RefreshTokenValidatorTest {

    private RefreshTokenValidator validator;

    @BeforeEach
    void setUp() {
        validator = new RefreshTokenValidator();
    }

    @Test
    @DisplayName("Validate valid RefreshTokenDTO - Positive")
    void testValidateRefreshTokenDTO_Positive() {
        RefreshTokenDTO token = createValidRefreshTokenDTO();
        assertThat(token).isNotNull();
        validator.validate(token);
    }

    @Test
    @DisplayName("Validate valid RefreshTokenBLM - Positive")
    void testValidateRefreshTokenBLM_Positive() {
        RefreshTokenBLM token = createValidRefreshTokenBLM();
        assertThat(token).isNotNull();
        validator.validate(token);
    }

    @Test
    @DisplayName("Validate valid RefreshTokenDALM - Positive")
    void testValidateRefreshTokenDALM_Positive() {
        RefreshTokenDALM token = createValidRefreshTokenDALM();
        assertThat(token).isNotNull();
        validator.validate(token);
    }

    @Test
    @DisplayName("Validate null RefreshTokenDTO - Negative")
    void testValidateNullRefreshTokenDTO_Negative() {
        RefreshTokenDTO token = null;
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(RefreshTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate RefreshTokenDTO with empty token - Negative")
    void testValidateRefreshTokenDTOWithEmptyToken_Negative() {
        RefreshTokenDTO token = createRefreshTokenDTOWithEmptyToken();
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(RefreshTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate null RefreshTokenBLM - Negative")
    void testValidateNullRefreshTokenBLM_Negative() {
        RefreshTokenBLM token = null;
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(RefreshTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate RefreshTokenBLM with null fields - Negative")
    void testValidateRefreshTokenBLMWithNullFields_Negative() {
        RefreshTokenBLM token = createRefreshTokenBLMWithNullFields();
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(RefreshTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate null RefreshTokenDALM - Negative")
    void testValidateNullRefreshTokenDALM_Negative() {
        RefreshTokenDALM token = null;
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(RefreshTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate RefreshTokenDALM with null fields - Negative")
    void testValidateRefreshTokenDALMWithNullFields_Negative() {
        RefreshTokenDALM token = createRefreshTokenDALMWithNullFields();
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(RefreshTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate RefreshTokenBLM with expired token - Negative")
    void testValidateRefreshTokenBLMWithExpiredToken_Negative() {
        RefreshTokenBLM token = createRefreshTokenBLMWithExpiredToken();
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(RefreshTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate RefreshTokenDALM with future created date - Negative")
    void testValidateRefreshTokenDALMWithFutureCreatedAt_Negative() {
        RefreshTokenDALM token = createRefreshTokenDALMWithFutureCreatedAt();
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(RefreshTokenValidateException.class);
    }
}package com.connection.token.repository;

import java.util.UUID;

import com.connection.token.exception.RefreshTokenAlreadyExisistsException;
import com.connection.token.exception.RefreshTokenNotFoundException;
import com.connection.token.model.RefreshTokenDALM;

public interface RefreshTokenRepository {
    /**
     * Лобавить новый refreshToken
     * 
     * @param refreshTokenDALM Новый токен
     */
    public void add(RefreshTokenDALM refreshTokenDALM) throws RefreshTokenAlreadyExisistsException;

    /**
     * Обновить токен
     * Создается новый токен взамен старого, старый отзывается
     * 
     * @param refreshTokenDALM Старый токен
     * @return Новый сохраненный токен
     * @throws RefreshTokenNotFoundException Если токен с таким uid не существует
     */
    public void updateToken(RefreshTokenDALM refreshTokenDALM, RefreshTokenDALM newRefreshTokenDALM)
            throws RefreshTokenNotFoundException;

    /**
     * Отозвать токен
     * 
     * @param refreshTokenDALM Токен для отзыва
     * @throws RefreshTokenNotFoundException Если токен с таким uid не существует
     */
    public void revoke(RefreshTokenDALM refreshTokenDALM) throws RefreshTokenNotFoundException;

    /**
     * Отозвать все токены клиента
     * 
     * @param clientDALM Клиент
     */
    public void revokeAll(UUID clientUUID);

    /**
     * Отозвать все закончившиеся токены
     */
    public void cleanUpExpired();
}
package com.connection.token.exception;

public class RefreshTokenAlreadyExisistsException extends BaseTokenException{
    private final String descriptionString = "refresh token already exists";
    public RefreshTokenAlreadyExisistsException(String tokenString){
        super(tokenString);
    }

    public String toString(){
        String res = super.toString();
        res += "\n" + "description: " + descriptionString;
        return res;
    }
}
package com.connection.token.validator;

import java.util.Date;
import java.util.UUID;

import com.connection.token.exception.RefreshTokenValidateException;
import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDALM;
import com.connection.token.model.RefreshTokenDTO;

public class RefreshTokenValidator {
    public void validate(RefreshTokenDTO refreshToken) {
        if (refreshToken == null) {
            throw new RefreshTokenValidateException("null", "Refresh token is null");
        }
        try {
            validateToken(refreshToken.getToken());
        } catch (IllegalArgumentException e) {
            throw new RefreshTokenValidateException("refreshToken", e.getMessage());
        }
    }

    public void validate(RefreshTokenBLM refreshToken) {
        if (refreshToken == null) {
            throw new RefreshTokenValidateException("null", "Refresh token is null");
        }
        try {
            validateToken(refreshToken.getToken());
            validateUID(refreshToken.getUid());
            validateClientUID(refreshToken.getClientUID());
            validateCreatedAt(refreshToken.getCreatedAt());
            validateExpiresAt(refreshToken.getExpiresAt());
        } catch (IllegalArgumentException e) {
            if (refreshToken.getUid() != null)
                throw new RefreshTokenValidateException(refreshToken.getUid().toString(), e.getMessage());
            else
                throw new RefreshTokenValidateException("null", e.getMessage());
        }
    }

    public void validate(RefreshTokenDALM refreshToken) {
        if (refreshToken == null) {
            throw new RefreshTokenValidateException("null", "Refresh token is null");
        }
        try {
            validateUID(refreshToken.getUid());
            validateClientUID(refreshToken.getClientUID());
            validateCreatedAt(refreshToken.getCreatedAt());
            validateExpiresAt(refreshToken.getExpiresAt());
        } catch (IllegalArgumentException e) {
            if (refreshToken.getUid() != null)
                throw new RefreshTokenValidateException(refreshToken.getUid().toString(), e.getMessage());
            else
                throw new RefreshTokenValidateException("null", e.getMessage());
        }
    }

    private void validateToken(String token) {
        if (token == null || token.trim().isEmpty()) {
            throw new IllegalArgumentException("Token cannot be empty");
        }
    }

    private void validateUID(UUID UID) {
        if (UID == null) {
            throw new IllegalArgumentException("UID cannot be null");
        }
    }

    private void validateClientUID(UUID clientUID) {
        if (clientUID == null) {
            throw new IllegalArgumentException("Client UID cannot be null");
        }
    }

    private void validateCreatedAt(Date createdAt) {
        if (createdAt == null) {
            throw new IllegalArgumentException("Creation date cannot be null");
        }

        Date now = new Date();
        if (createdAt.after(now)) {
            throw new IllegalArgumentException("Creation date cannot be in the future");
        }
    }

    private void validateExpiresAt(Date expiresAt) {
        if (expiresAt == null) {
            throw new IllegalArgumentException("Expiration date cannot be null");
        }

        Date now = new Date();
        if (expiresAt.before(now)) {
            throw new IllegalArgumentException("Token has already expired");
        }
    }

}
package com.connection.token.validator;

import java.util.Date;
import java.util.UUID;

import com.connection.token.exception.AccessTokenValidateException;
import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.AccessTokenDALM;
import com.connection.token.model.AccessTokenDTO;

public class AccessTokenValidator {
    public void validate(AccessTokenDTO accessToken) {
        if (accessToken == null) {
            throw new AccessTokenValidateException("null", "Access token is null");
        }
        try {
            validateToken(accessToken.getToken());
        } catch (IllegalArgumentException e) {
            throw new AccessTokenValidateException("accessToken", e.getMessage());
        }
    }

    public void validate(AccessTokenBLM accessToken) {
        if (accessToken == null) {
            throw new AccessTokenValidateException("null", "Access token is null");
        }
        try {
            validateToken(accessToken.getToken());
            validateClientUID(accessToken.getClientUID());
            validateCreatedAt(accessToken.getCreatedAt());
            validateExpiresAt(accessToken.getExpiresAt());
        } catch (IllegalArgumentException e) {
            throw new AccessTokenValidateException("accessToken", e.getMessage());
        }
    }

    public void validate(AccessTokenDALM accessToken) {
        if (accessToken == null) {
            throw new AccessTokenValidateException("null", "Access token is null");
        }
        try {
            validateClientUID(accessToken.getClientUID());
            validateCreatedAt(accessToken.getCreatedAt());
            validateExpiresAt(accessToken.getExpiresAt());
        } catch (IllegalArgumentException e) {
            throw new AccessTokenValidateException("accessToken", e.getMessage());
        }
    }

    private void validateToken(String token) {
        if (token == null || token.trim().isEmpty()) {
            throw new IllegalArgumentException("Token cannot be empty");
        }
    }

    private void validateClientUID(UUID clientUID) {
        if (clientUID == null) {
            throw new IllegalArgumentException("Client UID cannot be null");
        }
    }

    private void validateCreatedAt(Date createdAt) {
        if (createdAt == null) {
            throw new IllegalArgumentException("Creation date cannot be null");
        }

        Date now = new Date();
        if (createdAt.after(now)) {
            throw new IllegalArgumentException("Creation date cannot be in the future");
        }
    }

    private void validateExpiresAt(Date expiresAt) {
        if (expiresAt == null) {
            throw new IllegalArgumentException("Expiration date cannot be null");
        }

        Date now = new Date();
        if (expiresAt.before(now)) {
            throw new IllegalArgumentException("Token has already expired");
        }
    }

}
package com.connection.token.validator;

import static com.connection.token.mother.TokenObjectMother.*;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

import java.util.Date;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

import com.connection.token.exception.AccessTokenValidateException;
import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.AccessTokenDALM;
import com.connection.token.model.AccessTokenDTO;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Access Token Validator Tests")
class AccessTokenValidatorTest {

    private AccessTokenValidator validator;

    @BeforeEach
    void setUp() {
        validator = new AccessTokenValidator();
    }

    @Test
    @DisplayName("Validate valid AccessTokenDTO - Positive")
    void testValidateAccessTokenDTO_Positive() {
        AccessTokenDTO token = createValidAccessTokenDTO();
        assertThat(token).isNotNull();
        validator.validate(token);
    }

    @Test
    @DisplayName("Validate valid AccessTokenBLM - Positive")
    void testValidateAccessTokenBLM_Positive() {
        AccessTokenBLM token = createValidAccessTokenBLM();
        assertThat(token).isNotNull();
        validator.validate(token);
    }

    @Test
    @DisplayName("Validate valid AccessTokenDALM - Positive")
    void testValidateAccessTokenDALM_Positive() {
        AccessTokenDALM token = createValidAccessTokenDALM();
        assertThat(token).isNotNull();
        validator.validate(token);
    }

    @Test
    @DisplayName("Validate null AccessTokenDTO - Negative")
    void testValidateNullAccessTokenDTO_Negative() {
        AccessTokenDTO token = null;
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(AccessTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate AccessTokenDTO with empty token - Negative")
    void testValidateAccessTokenDTOWithEmptyToken_Negative() {
        AccessTokenDTO token = new AccessTokenDTO("");
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(AccessTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate null AccessTokenBLM - Negative")
    void testValidateNullAccessTokenBLM_Negative() {
        AccessTokenBLM token = null;
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(AccessTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate AccessTokenBLM with expired token - Negative")
    void testValidateAccessTokenBLMWithExpiredToken_Negative() {
        Date expiredDate = new Date(System.currentTimeMillis() - 1000L * 60 * 60);
        AccessTokenBLM token = new AccessTokenBLM(
            "test-token",
            createValidAccessTokenBLM().getClientUID(),
            createValidAccessTokenBLM().getCreatedAt(),
            expiredDate
        );
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(AccessTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate AccessTokenBLM with future created date - Negative")
    void testValidateAccessTokenBLMWithFutureCreatedAt_Negative() {
        Date futureDate = new Date(System.currentTimeMillis() + 1000L * 60 * 60);
        AccessTokenBLM token = new AccessTokenBLM(
            "test-token",
            createValidAccessTokenBLM().getClientUID(),
            futureDate,
            createValidAccessTokenBLM().getExpiresAt()
        );
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(AccessTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate null AccessTokenDALM - Negative")
    void testValidateNullAccessTokenDALM_Negative() {
        AccessTokenDALM token = null;
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(AccessTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate AccessTokenDALM with null client UID - Negative")
    void testValidateAccessTokenDALMWithNullClientUID_Negative() {
        AccessTokenDALM token = new AccessTokenDALM(
            null,
            createValidAccessTokenDALM().getCreatedAt(),
            createValidAccessTokenDALM().getExpiresAt()
        );
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(AccessTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate AccessTokenDALM with expired token - Negative")
    void testValidateAccessTokenDALMWithExpiredToken_Negative() {
        Date expiredDate = new Date(System.currentTimeMillis() - 1000L * 60 * 60);
        AccessTokenDALM token = new AccessTokenDALM(
            createValidAccessTokenDALM().getClientUID(),
            createValidAccessTokenDALM().getCreatedAt(),
            expiredDate
        );
        assertThatThrownBy(() -> validator.validate(token))
                .isInstanceOf(AccessTokenValidateException.class);
    }
}package com.connection.token.generator;

import static com.connection.token.mother.TokenObjectMother.*;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

import java.util.Date;

import javax.crypto.SecretKey;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

import com.connection.token.model.RefreshTokenDALM;

import io.jsonwebtoken.security.Keys;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Refresh Token Generator Tests")
class RefreshTokenGeneratorTest {

    private RefreshTokenGenerator generator;
    private SecretKey secretKey;

    @BeforeEach
    void setUp() {
        secretKey = Keys.hmacShaKeyFor("test-secret-key-1234567890-1234567890".getBytes());
        generator = new RefreshTokenGenerator(secretKey, "test-app", "refresh-token");
    }

    @Test
    @DisplayName("Generate refresh token from DALM - Positive")
    void testGenerateRefreshTokenFromDALM_Positive() {
        RefreshTokenDALM dalM = createValidRefreshTokenDALM();
        String token = generator.generateRefreshToken(dalM);
        assertThat(token).isNotNull().isNotEmpty();
    }

    @Test
    @DisplayName("Generate refresh token from parameters - Positive")
    void testGenerateRefreshTokenFromParameters_Positive() {
        String token = generator.generateRefreshToken(
            createValidRefreshTokenDALM().getUid(),
            createValidRefreshTokenDALM().getClientUID(),
            createValidRefreshTokenDALM().getCreatedAt(),
            createValidRefreshTokenDALM().getExpiresAt()
        );
        assertThat(token).isNotNull().isNotEmpty();
    }

    @Test
    @DisplayName("Parse valid refresh token - Positive")
    void testGetRefreshToken_Positive() {
        RefreshTokenDALM dalM = createValidRefreshTokenDALM();
        String tokenString = generator.generateRefreshToken(dalM);
        
        var result = generator.getRefreshToken(tokenString);
        assertThat(result).isNotNull();
        assertThat(result.getUid()).isEqualTo(dalM.getUid());
        assertThat(result.getClientUID()).isEqualTo(dalM.getClientUID());
    }

    @Test
    @DisplayName("Parse invalid refresh token - Negative")
    void testGetRefreshTokenWithInvalidToken_Negative() {
        assertThatThrownBy(() -> generator.getRefreshToken("invalid.token.here"))
                .isInstanceOf(RuntimeException.class);
    }
}package com.connection.token.converter;

import static com.connection.token.mother.TokenObjectMother.*;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import com.connection.token.generator.RefreshTokenGenerator;
import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDALM;
import com.connection.token.model.RefreshTokenDTO;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Refresh Token Converter Tests")
class RefreshTokenConverterTest {

    @Mock
    private RefreshTokenGenerator tokenGenerator;

    @InjectMocks
    private RefreshTokenConverter converter;

    private RefreshTokenDALM testDALM;
    private RefreshTokenDTO testDTO;
    private RefreshTokenBLM testBLM;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        testDALM = createValidRefreshTokenDALM();
        testDTO = createValidRefreshTokenDTO();
        testBLM = createValidRefreshTokenBLM();

        when(tokenGenerator.generateRefreshToken(any(RefreshTokenDALM.class))).thenReturn("generated-token");
        when(tokenGenerator.getRefreshToken(any(String.class))).thenReturn(testBLM);
    }

    @Test
    @DisplayName("Convert DALM to BLM - Positive")
    void testToBLMFromDALM_Positive() {
        RefreshTokenBLM result = converter.toBLM(testDALM);
        assertThat(result).isNotNull();
        assertThat(result.getToken()).isEqualTo("generated-token");
    }

    @Test
    @DisplayName("Convert DTO to BLM - Positive")
    void testToBLMFromDTO_Positive() {
        RefreshTokenBLM result = converter.toBLM(testDTO);
        assertThat(result).isNotNull();
        assertThat(result.getToken()).isEqualTo(testBLM.getToken());
    }

    @Test
    @DisplayName("Convert BLM to DTO - Positive")
    void testToDTOFromBLM_Positive() {
        RefreshTokenDTO result = converter.toDTO(testBLM);
        assertThat(result).isNotNull();
        assertThat(result.getToken()).isEqualTo(testBLM.getToken());
    }

    @Test
    @DisplayName("Convert BLM to DALM - Positive")
    void testToDALMFromBLM_Positive() {
        RefreshTokenDALM result = converter.toDALM(testBLM);
        assertThat(result).isNotNull();
        assertThat(result.getUid()).isEqualTo(testBLM.getUid());
        assertThat(result.getClientUID()).isEqualTo(testBLM.getClientUID());
        assertThat(result.getCreatedAt()).isEqualTo(testBLM.getCreatedAt());
        assertThat(result.getExpiresAt()).isEqualTo(testBLM.getExpiresAt());
    }
}package com.connection.token.generator;

import java.util.Date;
import java.util.UUID;

import javax.crypto.SecretKey;

import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDALM;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import io.jsonwebtoken.Jwts;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class RefreshTokenGenerator {
    @NonNull
    private final SecretKey jwtSecretKey;

    @NonNull
    private final String appNameString;

    @NonNull
    private final String jwtSubjecString;

    public String generateRefreshToken(RefreshTokenDALM dalm) {
        String token = Jwts.builder()
                .issuer(appNameString)
                .subject(jwtSubjecString)
                .claim("uid", dalm.getUid().toString())
                .claim("clientUid", dalm.getClientUID().toString())
                .issuedAt(dalm.getCreatedAt())
                .expiration(dalm.getExpiresAt())
                .signWith(jwtSecretKey)
                .compact();
        return token;
    }

    public String generateRefreshToken(UUID uid, UUID clientUuid, Date createdAt, Date expiresAt) {
        String token = Jwts.builder()
                .issuer(appNameString)
                .subject(jwtSubjecString)
                .claim("uid", uid.toString())
                .claim("clientUid", clientUuid.toString())
                .issuedAt(createdAt)
                .expiration(expiresAt)
                .signWith(jwtSecretKey)
                .compact();
        return token;
    }

    public RefreshTokenBLM getRefreshToken(String token) {
        Jws<Claims> jws = Jwts.parser()
                .verifyWith(jwtSecretKey)
                .build()
                .parseSignedClaims(token);

        Claims claims = jws.getPayload();

        UUID uid = UUID.fromString(claims.get("uid", String.class));
        UUID clientUid = UUID.fromString(claims.get("clientUid", String.class));
        Date issuedAt = claims.getIssuedAt();
        Date expiration = claims.getExpiration();

        if (!jwtSubjecString.equals(claims.getSubject())) {
            throw new RuntimeException("Invalid token subject");
        }

        return new RefreshTokenBLM(token, uid, clientUid, issuedAt, expiration);
    }
}
package com.connection.token.converter;

import com.connection.token.generator.AccessTokenGenerator;
import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.AccessTokenDALM;
import com.connection.token.model.AccessTokenDTO;

import io.jsonwebtoken.JwtException;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class AccessTokenConverter {
    @NonNull
    private final AccessTokenGenerator accessTokenGenerator;

    public AccessTokenBLM toBLM(AccessTokenDALM dalm) {
        try {
            String token = accessTokenGenerator.generateAccessToken(dalm.getClientUID(), dalm.getCreatedAt(),
                    dalm.getExpiresAt());
            return new AccessTokenBLM(token,
                    dalm.getClientUID(),
                    dalm.getCreatedAt(),
                    dalm.getExpiresAt());
        } catch (JwtException e) {
            throw new RuntimeException("Invalid JWT token: " + e.getMessage(), e);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException("Malformed JWT token", e);
        }
    }

    public AccessTokenBLM toBLM(AccessTokenDTO dto) {
        try {
            AccessTokenBLM blm = accessTokenGenerator.getAccessTokenBLM(dto.getToken());
            return blm;
        } catch (JwtException e) {
            throw new RuntimeException("Invalid JWT token: " + e.getMessage(), e);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException("Malformed JWT token", e);
        }
    }

    public AccessTokenDTO toDTO(AccessTokenBLM blm) {
        return new AccessTokenDTO(blm.getToken());
    }

    public AccessTokenDALM toDALM(AccessTokenBLM blm) {
        return new AccessTokenDALM(blm.getClientUID(), blm.getCreatedAt(), blm.getExpiresAt());
    }
}
package com.connection.token.generator;

import static com.connection.token.mother.TokenObjectMother.*;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.assertj.core.api.Assertions.within;

import java.util.Date;
import java.util.concurrent.TimeUnit;

import javax.crypto.SecretKey;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.AccessTokenDALM;

import io.jsonwebtoken.security.Keys;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Access Token Generator Tests")
class AccessTokenGeneratorTest {

    private AccessTokenGenerator generator;
    private SecretKey secretKey;

    @BeforeEach
    void setUp() {
        secretKey = Keys.hmacShaKeyFor("test-secret-key-1234567890-1234567890".getBytes());
        generator = new AccessTokenGenerator(secretKey, "test-app", "access-token");
    }

    @Test
    @DisplayName("Generate access token - Positive")
    void testGenerateAccessToken_Positive() {
        AccessTokenDALM dalM = createValidAccessTokenDALM();
        String token = generator.generateAccessToken(
            dalM.getClientUID(),
            dalM.getCreatedAt(),
            dalM.getExpiresAt()
        );
        assertThat(token).isNotNull().isNotEmpty();
    }

    @Test
    @DisplayName("Parse valid access token - Positive")
    void testGetAccessTokenBLM_Positive() {
        AccessTokenDALM dalM = createValidAccessTokenDALM();
        String tokenString = generator.generateAccessToken(
            dalM.getClientUID(),
            dalM.getCreatedAt(),
            dalM.getExpiresAt()
        );
        
        AccessTokenBLM result = generator.getAccessTokenBLM(tokenString);
        assertThat(result).isNotNull();
        assertThat(result.getClientUID()).isEqualTo(dalM.getClientUID());
        
        // Сравниваем время в секундах (миллисекунды игнорируются)
        assertThat(result.getCreatedAt().getTime() / 1000).isEqualTo(dalM.getCreatedAt().getTime() / 1000);
        assertThat(result.getExpiresAt().getTime() / 1000).isEqualTo(dalM.getExpiresAt().getTime() / 1000);
    }

    @Test
    @DisplayName("Parse invalid access token - Negative")
    void testGetAccessTokenBLMWithInvalidToken_Negative() {
        assertThatThrownBy(() -> generator.getAccessTokenBLM("invalid.token.here"))
                .isInstanceOf(RuntimeException.class);
    }

    @Test
    @DisplayName("Parse access token with wrong subject - Negative")
    void testGetAccessTokenBLMWithWrongSubject_Negative() {
        AccessTokenGenerator wrongSubjectGenerator = new AccessTokenGenerator(secretKey, "test-app", "wrong-subject");
        AccessTokenDALM dalM = createValidAccessTokenDALM();
        
        String tokenString = generator.generateAccessToken(
            dalM.getClientUID(),
            dalM.getCreatedAt(),
            dalM.getExpiresAt()
        );
        
        assertThatThrownBy(() -> wrongSubjectGenerator.getAccessTokenBLM(tokenString))
                .isInstanceOf(RuntimeException.class)
                .hasMessageContaining("Invalid token subject");
    }

    @Test
    @DisplayName("Generate and parse round trip - Positive")
    void testGenerateAndParseRoundTrip_Positive() {
        AccessTokenDALM original = createValidAccessTokenDALM();
        
        String token = generator.generateAccessToken(
            original.getClientUID(),
            original.getCreatedAt(),
            original.getExpiresAt()
        );
        
        AccessTokenBLM parsed = generator.getAccessTokenBLM(token);
        
        assertThat(parsed.getClientUID()).isEqualTo(original.getClientUID());
        
        // Сравниваем время в секундах (миллисекунды игнорируются)
        assertThat(parsed.getCreatedAt().getTime() / 1000).isEqualTo(original.getCreatedAt().getTime() / 1000);
        assertThat(parsed.getExpiresAt().getTime() / 1000).isEqualTo(original.getExpiresAt().getTime() / 1000);
        assertThat(parsed.getToken()).isEqualTo(token);
    }

    @Test
    @DisplayName("Generate token with different dates - Positive")
    void testGenerateAccessTokenWithDifferentDates_Positive() {
        Date createdAt = new Date(System.currentTimeMillis() - 1000L * 60 * 10);
        Date expiresAt = new Date(System.currentTimeMillis() + 1000L * 60 * 30);
        
        String token = generator.generateAccessToken(
            createValidAccessTokenDALM().getClientUID(),
            createdAt,
            expiresAt
        );
        
        AccessTokenBLM result = generator.getAccessTokenBLM(token);
        
        // Сравниваем время в секундах (миллисекунды игнорируются)
        assertThat(result.getCreatedAt().getTime() / 1000).isEqualTo(createdAt.getTime() / 1000);
        assertThat(result.getExpiresAt().getTime() / 1000).isEqualTo(expiresAt.getTime() / 1000);
    }

    @Test
    @DisplayName("Generate token and verify time precision - Milliseconds ignored")
    void testGenerateAccessToken_MillisecondsIgnored() {
        // Создаем даты с разными миллисекундами
        long baseTime = System.currentTimeMillis();
        Date createdAt = new Date(baseTime + 123); // +123 мс
        Date expiresAt = new Date(baseTime + 3600000 + 456); // +456 мс
        
        String token = generator.generateAccessToken(
            createValidAccessTokenDALM().getClientUID(),
            createdAt,
            expiresAt
        );
        
        AccessTokenBLM result = generator.getAccessTokenBLM(token);
        
        // Проверяем, что миллисекунды игнорируются при сравнении
        assertThat(result.getCreatedAt().getTime() / 1000).isEqualTo(createdAt.getTime() / 1000);
        assertThat(result.getExpiresAt().getTime() / 1000).isEqualTo(expiresAt.getTime() / 1000);
        
        // Но фактически миллисекунды могут быть разными
        assertThat(result.getCreatedAt().getTime()).isNotEqualTo(createdAt.getTime());
        assertThat(result.getExpiresAt().getTime()).isNotEqualTo(expiresAt.getTime());
    }
}package com.connection.token.model;

import java.util.Date;
import java.util.UUID;

import jakarta.persistence.Entity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Builder
public class AccessTokenDALM {
    protected UUID clientUID;
    protected Date createdAt;
    protected Date expiresAt;
}
// ActiveTokenExistsException.java
package com.connection.device.token.exception;

public class DeviceAccessTokenExistsException extends BaseTokenException {
    public DeviceAccessTokenExistsException(String tokenString) {
        super(tokenString);
    }

    public String toString() {
        String res = super.toString();
        res += "\n" + "description: active device access token already exists";
        return res;
    }
}// DeviceTokenValidateException.java
package com.connection.device.token.exception;

public class DeviceTokenValidateException extends BaseTokenException {
    private final String descriptionString;
    
    public DeviceTokenValidateException(String tokenString, String description) {
        super(tokenString);
        this.descriptionString = description;
    }

    public String toString() {
        String res = super.toString();
        res += "\n" + "description: device token is invalid";
        res += "\n" + descriptionString;
        return res;
    }
}// DeviceAccessTokenNotFoundException.java
package com.connection.device.token.exception;

public class DeviceAccessTokenNotFoundException extends BaseTokenException {
    public DeviceAccessTokenNotFoundException(String tokenString) {
        super(tokenString);
    }

    public String toString() {
        String res = super.toString();
        res += "\n" + "description: device access token not found";
        return res;
    }
}// DeviceTokenAlreadyExistsException.java
package com.connection.device.token.exception;

public class DeviceTokenAlreadyExistsException extends BaseTokenException {
    public DeviceTokenAlreadyExistsException(String tokenString) {
        super(tokenString);
    }

    public String toString() {
        String res = super.toString();
        res += "\n" + "description: device token already exists";
        return res;
    }
}// DeviceTokenNotFoundException.java
package com.connection.device.token.exception;

public class DeviceTokenNotFoundException extends BaseTokenException {
    public DeviceTokenNotFoundException(String tokenString) {
        super(tokenString);
    }

    public String toString() {
        String res = super.toString();
        res += "\n" + "description: device token not found";
        return res;
    }
}package com.connection.device.token.exception;

public class BaseTokenException extends RuntimeException{
    private final String tokenString;

    public BaseTokenException(String tokenDescription){
        super("token");
        tokenString = tokenDescription;
    }

    public String toString(){
        String res = super.toString();
        res += "\n" + "token: " + tokenString;
        return res;
    }
}
// DeviceTokenValidateException.java
package com.connection.device.token.exception;

public class DeviceAccessTokenValidateException extends BaseTokenException {
    private final String descriptionString;
    
    public DeviceAccessTokenValidateException(String tokenString, String description) {
        super(tokenString);
        this.descriptionString = description;
    }

    public String toString() {
        String res = super.toString();
        res += "\n" + "description: device access token is invalid";
        res += "\n" + descriptionString;
        return res;
    }
}// DeviceTokenGenerator.java
package com.connection.device.token.generator;

import java.util.Date;
import java.util.UUID;

import javax.crypto.SecretKey;

import com.connection.device.token.model.DeviceTokenBLM;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import io.jsonwebtoken.Jwts;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class DeviceTokenGenerator {
    @NonNull
    private final SecretKey jwtSecretKey;

    @NonNull
    private final String appNameString;

    @NonNull
    private final String jwtSubjectString;

    public String generateDeviceToken(UUID deviceUid, Date createdAt, Date expiresAt) {
        String token = Jwts.builder()
                .issuer(appNameString)
                .subject(jwtSubjectString)
                .claim("deviceUid", deviceUid.toString())
                .claim("type", "device_token")
                .issuedAt(createdAt)
                .expiration(expiresAt)
                .signWith(jwtSecretKey)
                .compact();
        return token;
    }

    public DeviceTokenBLM getDeviceTokenBLM(String token) {
        Jws<Claims> jws = Jwts.parser()
                .verifyWith(jwtSecretKey)
                .build()
                .parseSignedClaims(token);

        Claims claims = jws.getPayload();

        UUID deviceUid = UUID.fromString(claims.get("deviceUid", String.class));
        Date issuedAt = claims.getIssuedAt();
        Date expiration = claims.getExpiration();

        if (!jwtSubjectString.equals(claims.getSubject())) {
            throw new RuntimeException("Invalid token subject");
        }

        if (!"device_token".equals(claims.get("type", String.class))) {
            throw new RuntimeException("Invalid token type");
        }

        return DeviceTokenBLM.builder()
                .token(token)
                .deviceUid(deviceUid)
                .createdAt(issuedAt)
                .expiresAt(expiration)
                .build();
    }
}// DeviceAccessTokenGenerator.java
package com.connection.device.token.generator;

import java.util.Date;
import java.util.UUID;

import javax.crypto.SecretKey;

import com.connection.device.token.model.DeviceAccessTokenBLM;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import io.jsonwebtoken.Jwts;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class DeviceAccessTokenGenerator {
    @NonNull
    private final SecretKey jwtSecretKey;

    @NonNull
    private final String appNameString;

    @NonNull
    private final String jwtSubjectString;

    public String generateDeviceAccessToken(UUID deviceTokenUid, Date createdAt, Date expiresAt) {
        String token = Jwts.builder()
                .issuer(appNameString)
                .subject(jwtSubjectString)
                .claim("deviceTokenUid", deviceTokenUid.toString())
                .claim("type", "device_access_token")
                .issuedAt(createdAt)
                .expiration(expiresAt)
                .signWith(jwtSecretKey)
                .compact();
        return token;
    }

    public DeviceAccessTokenBLM getDeviceAccessTokenBLM(String token) {
        Jws<Claims> jws = Jwts.parser()
                .verifyWith(jwtSecretKey)
                .build()
                .parseSignedClaims(token);

        Claims claims = jws.getPayload();

        UUID deviceTokenUid = UUID.fromString(claims.get("deviceTokenUid", String.class));
        Date issuedAt = claims.getIssuedAt();
        Date expiration = claims.getExpiration();

        if (!jwtSubjectString.equals(claims.getSubject())) {
            throw new RuntimeException("Invalid token subject");
        }

        if (!"device_access_token".equals(claims.get("type", String.class))) {
            throw new RuntimeException("Invalid token type");
        }

        return DeviceAccessTokenBLM.builder()
                .token(token)
                .deviceTokenUid(deviceTokenUid)
                .createdAt(issuedAt)
                .expiresAt(expiration)
                .build();
    }
}// DeviceAccessTokenDALM.java
package com.connection.device.token.model;

import java.util.Date;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Builder
public class DeviceAccessTokenDALM {
    protected UUID uid;
    protected UUID deviceTokenUid;
    protected String token;
    protected Date createdAt;
    protected Date expiresAt;
}// DeviceAccessTokenBLM.java
package com.connection.device.token.model;

import java.util.Date;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Builder
public class DeviceAccessTokenBLM {
    protected String token;
    protected UUID uid;
    protected UUID deviceTokenUid;
    protected Date createdAt;
    protected Date expiresAt;
}// DeviceTokenBLM.java
package com.connection.device.token.model;

import java.util.Date;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Builder
public class DeviceTokenBLM {
    protected String token;
    protected UUID uid;
    protected UUID deviceUid;
    protected Date createdAt;
    protected Date expiresAt;
}// DeviceAccessTokenDTO.java
package com.connection.device.token.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Builder
public class DeviceAccessTokenDTO {
    protected String token;
}// DeviceTokenDALM.java
package com.connection.device.token.model;

import java.util.Date;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Builder
public class DeviceTokenDALM {
    protected UUID uid;
    protected UUID deviceUid;
    protected String token;
    protected Date createdAt;
    protected Date expiresAt;
}// DeviceTokenDTO.java
package com.connection.device.token.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Builder
public class DeviceTokenDTO {
    protected String token;
}// DeviceAccessTokenConverter.java
package com.connection.device.token.converter;

import com.connection.device.token.generator.DeviceAccessTokenGenerator;
import com.connection.device.token.model.DeviceAccessTokenBLM;
import com.connection.device.token.model.DeviceAccessTokenDALM;
import com.connection.device.token.model.DeviceAccessTokenDTO;

import io.jsonwebtoken.JwtException;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class DeviceAccessTokenConverter {
    @NonNull
    private final DeviceAccessTokenGenerator deviceTokenGenerator;

    public DeviceAccessTokenBLM toBLM(DeviceAccessTokenDALM dalm) {
        try {
            String token = deviceTokenGenerator.generateDeviceAccessToken(
                dalm.getDeviceTokenUid(), dalm.getCreatedAt(), dalm.getExpiresAt());
            
            return DeviceAccessTokenBLM.builder()
                    .token(token)
                    .uid(dalm.getUid())
                    .deviceTokenUid(dalm.getDeviceTokenUid())
                    .createdAt(dalm.getCreatedAt())
                    .expiresAt(dalm.getExpiresAt())
                    .build();
        } catch (JwtException e) {
            throw new RuntimeException("Invalid JWT token: " + e.getMessage(), e);
        }
    }

    public DeviceAccessTokenBLM toBLM(DeviceAccessTokenDTO dto) {
        try {
            return deviceTokenGenerator.getDeviceAccessTokenBLM(dto.getToken());
        } catch (JwtException e) {
            throw new RuntimeException("Invalid JWT token: " + e.getMessage(), e);
        }
    }

    public DeviceAccessTokenDTO toDTO(DeviceAccessTokenBLM blm) {
        return DeviceAccessTokenDTO.builder()
                .token(blm.getToken())
                .build();
    }

    public DeviceAccessTokenDALM toDALM(DeviceAccessTokenBLM blm) {
        return DeviceAccessTokenDALM.builder()
                .uid(blm.getUid())
                .deviceTokenUid(blm.getDeviceTokenUid())
                .token(blm.getToken()) // Сохраняем сгенерированный токен
                .createdAt(blm.getCreatedAt())
                .expiresAt(blm.getExpiresAt())
                .build();
    }
}// DeviceTokenConverter.java
package com.connection.device.token.converter;

import com.connection.device.token.generator.DeviceTokenGenerator;
import com.connection.device.token.model.DeviceTokenBLM;
import com.connection.device.token.model.DeviceTokenDALM;
import com.connection.device.token.model.DeviceTokenDTO;

import io.jsonwebtoken.JwtException;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class DeviceTokenConverter {
    @NonNull
    private final DeviceTokenGenerator deviceTokenGenerator;

    public DeviceTokenBLM toBLM(DeviceTokenDALM dalm) {
        try {
            String token = deviceTokenGenerator.generateDeviceToken(
                dalm.getDeviceUid(), dalm.getCreatedAt(), dalm.getExpiresAt());
            
            return DeviceTokenBLM.builder()
                    .token(token)
                    .uid(dalm.getUid())
                    .deviceUid(dalm.getDeviceUid())
                    .createdAt(dalm.getCreatedAt())
                    .expiresAt(dalm.getExpiresAt())
                    .build();
        } catch (JwtException e) {
            throw new RuntimeException("Invalid JWT token: " + e.getMessage(), e);
        }
    }

    public DeviceTokenBLM toBLM(DeviceTokenDTO dto) {
        try {
            return deviceTokenGenerator.getDeviceTokenBLM(dto.getToken());
        } catch (JwtException e) {
            throw new RuntimeException("Invalid JWT token: " + e.getMessage(), e);
        }
    }

    public DeviceTokenDTO toDTO(DeviceTokenBLM blm) {
        return DeviceTokenDTO.builder()
                .token(blm.getToken())
                .build();
    }

    public DeviceTokenDALM toDALM(DeviceTokenBLM blm) {
        return DeviceTokenDALM.builder()
                .uid(blm.getUid())
                .deviceUid(blm.getDeviceUid())
                .token(blm.getToken()) // Сохраняем сгенерированный токен
                .createdAt(blm.getCreatedAt())
                .expiresAt(blm.getExpiresAt())
                .build();
    }
}// DeviceAccessTokenValidator.java
package com.connection.device.token.validator;

import java.util.Date;

import com.connection.device.token.exception.DeviceAccessTokenValidateException;
import com.connection.device.token.model.DeviceAccessTokenBLM;
import com.connection.device.token.model.DeviceAccessTokenDALM;
import com.connection.device.token.model.DeviceAccessTokenDTO;

public class DeviceAccessTokenValidator {
    
    public void validate(DeviceAccessTokenDTO deviceToken) {
        if (deviceToken == null) {
            throw new DeviceAccessTokenValidateException("null", "Device token is null");
        }
        validateToken(deviceToken.getToken());
    }

    public void validate(DeviceAccessTokenBLM deviceToken) {
        if (deviceToken == null) {
            throw new DeviceAccessTokenValidateException("null", "Device token is null");
        }
        validateToken(deviceToken.getToken());
        validateDeviceTokenUid(deviceToken.getDeviceTokenUid());
        validateDates(deviceToken.getCreatedAt(), deviceToken.getExpiresAt());
    }

    public void validate(DeviceAccessTokenDALM deviceToken) {
        if (deviceToken == null) {
            throw new DeviceAccessTokenValidateException("null", "Device token is null");
        }
        validateUid(deviceToken.getUid());
        validateDeviceTokenUid(deviceToken.getDeviceTokenUid());
        validateDates(deviceToken.getCreatedAt(), deviceToken.getExpiresAt());
    }

    private void validateToken(String token) {
        if (token == null || token.trim().isEmpty()) {
            throw new IllegalArgumentException("Token cannot be empty");
        }
        if (token.length() > 512) {
            throw new IllegalArgumentException("Token exceeds maximum length");
        }
    }

    private void validateUid(java.util.UUID uid) {
        if (uid == null) {
            throw new IllegalArgumentException("UID cannot be null");
        }
    }

    private void validateDeviceTokenUid(java.util.UUID deviceUid) {
        if (deviceUid == null) {
            throw new IllegalArgumentException("Device UID cannot be null");
        }
    }

    private void validateDates(Date createdAt, Date expiresAt) {
        if (createdAt == null || expiresAt == null) {
            throw new IllegalArgumentException("Dates cannot be null");
        }
        
        Date now = new Date();
        if (createdAt.after(now)) {
            throw new IllegalArgumentException("Creation date cannot be in the future");
        }
        if (expiresAt.before(now)) {
            throw new IllegalArgumentException("Token has already expired");
        }
        if (expiresAt.before(createdAt)) {
            throw new IllegalArgumentException("Expiration date cannot be before creation date");
        }
    }
}// DeviceTokenValidator.java
package com.connection.device.token.validator;

import java.util.Date;

import com.connection.device.token.exception.DeviceTokenValidateException;
import com.connection.device.token.model.DeviceTokenBLM;
import com.connection.device.token.model.DeviceTokenDALM;
import com.connection.device.token.model.DeviceTokenDTO;

public class DeviceTokenValidator {
    
    public void validate(DeviceTokenDTO deviceToken) {
        if (deviceToken == null) {
            throw new DeviceTokenValidateException("null", "Device token is null");
        }
        validateToken(deviceToken.getToken());
    }

    public void validate(DeviceTokenBLM deviceToken) {
        if (deviceToken == null) {
            throw new DeviceTokenValidateException("null", "Device token is null");
        }
        validateToken(deviceToken.getToken());
        validateDeviceUid(deviceToken.getDeviceUid());
        validateDates(deviceToken.getCreatedAt(), deviceToken.getExpiresAt());
    }

    public void validate(DeviceTokenDALM deviceToken) {
        if (deviceToken == null) {
            throw new DeviceTokenValidateException("null", "Device token is null");
        }
        validateUid(deviceToken.getUid());
        validateDeviceUid(deviceToken.getDeviceUid());
        validateDates(deviceToken.getCreatedAt(), deviceToken.getExpiresAt());
    }

    private void validateToken(String token) {
        if (token == null || token.trim().isEmpty()) {
            throw new IllegalArgumentException("Token cannot be empty");
        }
        if (token.length() > 512) {
            throw new IllegalArgumentException("Token exceeds maximum length");
        }
    }

    private void validateUid(java.util.UUID uid) {
        if (uid == null) {
            throw new IllegalArgumentException("UID cannot be null");
        }
    }

    private void validateDeviceUid(java.util.UUID deviceUid) {
        if (deviceUid == null) {
            throw new IllegalArgumentException("Device UID cannot be null");
        }
    }

    private void validateDates(Date createdAt, Date expiresAt) {
        if (createdAt == null || expiresAt == null) {
            throw new IllegalArgumentException("Dates cannot be null");
        }
        
        Date now = new Date();
        if (createdAt.after(now)) {
            throw new IllegalArgumentException("Creation date cannot be in the future");
        }
        if (expiresAt.before(now)) {
            throw new IllegalArgumentException("Token has already expired");
        }
        if (expiresAt.before(createdAt)) {
            throw new IllegalArgumentException("Expiration date cannot be before creation date");
        }
    }
}package com.connection.device.token.repository;

import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Timestamp;
import java.util.Date;
import java.util.UUID;

import com.connection.device.token.exception.DeviceAccessTokenExistsException;
import com.connection.device.token.exception.DeviceAccessTokenNotFoundException;
import com.connection.device.token.model.DeviceAccessTokenDALM;

@Repository
public class DeviceAccessTokenRepositorySQLImpl implements DeviceAccessTokenRepository {

    private static final String SELECT_DEVICE_ACCESS_TOKEN = "SELECT uid, device_token_uid, token, created_at, expires_at";
    private static final String FROM_DEVICE_ACCESS_TOKEN = " FROM access.device_access_token";

    private static final String SELECT_TOKEN_BY_UID = SELECT_DEVICE_ACCESS_TOKEN + FROM_DEVICE_ACCESS_TOKEN + " WHERE uid = :uid";
    private static final String SELECT_TOKEN_BY_TOKEN = SELECT_DEVICE_ACCESS_TOKEN + FROM_DEVICE_ACCESS_TOKEN + " WHERE token = :token";
    private static final String SELECT_TOKEN_BY_DEVICE_TOKEN_UID = SELECT_DEVICE_ACCESS_TOKEN + FROM_DEVICE_ACCESS_TOKEN + " WHERE device_token_uid = :device_token_uid";

    private static final String INSERT_DEVICE_ACCESS_TOKEN = "INSERT INTO access.device_access_token (uid, device_token_uid, token, created_at, expires_at) " +
            "VALUES (:uid, :device_token_uid, :token, :created_at, :expires_at)";

    private static final String REVOKE_TOKEN = "DELETE FROM access.device_access_token WHERE uid = :uid";
    private static final String REVOKE_BY_DEVICE_TOKEN_UID = "DELETE FROM access.device_access_token WHERE device_token_uid = :device_token_uid";
    private static final String CLEANUP_EXPIRED_TOKENS = "DELETE FROM access.device_access_token WHERE expires_at < NOW()";
    private static final String HAS_ACTIVE_TOKEN = "SELECT COUNT(*) FROM access.device_access_token WHERE device_token_uid = :device_token_uid AND expires_at > NOW()";

    private final NamedParameterJdbcTemplate jdbcTemplate;

    private final RowMapper<DeviceAccessTokenDALM> deviceAccessTokenRowMapper = (rs, rowNum) -> {
        DeviceAccessTokenDALM token = new DeviceAccessTokenDALM();
        token.setUid(UUID.fromString(rs.getString("uid")));
        token.setDeviceTokenUid(UUID.fromString(rs.getString("device_token_uid")));
        token.setToken(rs.getString("token"));
        token.setCreatedAt(rs.getTimestamp("created_at"));
        token.setExpiresAt(rs.getTimestamp("expires_at"));
        return token;
    };

    public DeviceAccessTokenRepositorySQLImpl(NamedParameterJdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    @Transactional
    public void add(DeviceAccessTokenDALM deviceAccessTokenDALM) throws DeviceAccessTokenExistsException {
        // Проверяем, что нет активного токена для этого device_token_uid
        if (hasDeviceAccessToken(deviceAccessTokenDALM.getDeviceTokenUid())) {
            throw new DeviceAccessTokenExistsException("DeviceAccess device access token already exists for device token UID " + deviceAccessTokenDALM.getDeviceTokenUid());
        }

        // Проверяем существование по token
        if (tokenExists(deviceAccessTokenDALM.getToken())) {
            throw new DeviceAccessTokenExistsException("Device access token already exists");
        }

        // Проверяем существование по uid
        if (uidExists(deviceAccessTokenDALM.getUid())) {
            throw new DeviceAccessTokenExistsException("Device access token with UID " + deviceAccessTokenDALM.getUid() + " already exists");
        }

        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", deviceAccessTokenDALM.getUid());
        params.addValue("device_token_uid", deviceAccessTokenDALM.getDeviceTokenUid());
        params.addValue("token", deviceAccessTokenDALM.getToken());
        params.addValue("created_at", new Timestamp(deviceAccessTokenDALM.getCreatedAt().getTime()));
        params.addValue("expires_at", new Timestamp(deviceAccessTokenDALM.getExpiresAt().getTime()));

        jdbcTemplate.update(INSERT_DEVICE_ACCESS_TOKEN, params);
    }

    @Override
    @Transactional(readOnly = true)
    public DeviceAccessTokenDALM findByUid(UUID uid) throws DeviceAccessTokenNotFoundException {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", uid);
        try {
            return jdbcTemplate.queryForObject(SELECT_TOKEN_BY_UID, params, deviceAccessTokenRowMapper);
        } catch (EmptyResultDataAccessException e) {
            throw new DeviceAccessTokenNotFoundException("Device access token with UID " + uid + " not found");
        }
    }

    @Override
    @Transactional(readOnly = true)
    public DeviceAccessTokenDALM findByToken(String token) throws DeviceAccessTokenNotFoundException {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("token", token);
        try {
            return jdbcTemplate.queryForObject(SELECT_TOKEN_BY_TOKEN, params, deviceAccessTokenRowMapper);
        } catch (EmptyResultDataAccessException e) {
            throw new DeviceAccessTokenNotFoundException("Device access token not found");
        }
    }

    @Override
    @Transactional(readOnly = true)
    public DeviceAccessTokenDALM findByDeviceTokenUid(UUID deviceTokenUid) throws DeviceAccessTokenNotFoundException {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("device_token_uid", deviceTokenUid);
        try {
            return jdbcTemplate.queryForObject(SELECT_TOKEN_BY_DEVICE_TOKEN_UID, params, deviceAccessTokenRowMapper);
        } catch (EmptyResultDataAccessException e) {
            throw new DeviceAccessTokenNotFoundException("Device access token for device token UID " + deviceTokenUid + " not found");
        }
    }

    @Override
    @Transactional
    public void revoke(UUID uid) throws DeviceAccessTokenNotFoundException {
        // Проверяем существование токена
        if (!uidExists(uid)) {
            throw new DeviceAccessTokenNotFoundException("Device access token with UID " + uid + " not found");
        }

        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", uid);

        jdbcTemplate.update(REVOKE_TOKEN, params);
    }

    @Override
    @Transactional
    public void revokeByDeviceTokenUid(UUID deviceTokenUid) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("device_token_uid", deviceTokenUid);

        jdbcTemplate.update(REVOKE_BY_DEVICE_TOKEN_UID, params);
    }

    @Override
    @Transactional
    public void revokeAllExpired() {
        jdbcTemplate.update(CLEANUP_EXPIRED_TOKENS, new MapSqlParameterSource());
    }

    @Override
    @Transactional(readOnly = true)
    public boolean hasDeviceAccessToken(UUID deviceTokenUid) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("device_token_uid", deviceTokenUid);
        Integer count = jdbcTemplate.queryForObject(HAS_ACTIVE_TOKEN, params, Integer.class);
        return count != null && count > 0;
    }

    // Вспомогательные методы
    @Transactional(readOnly = true)
    boolean uidExists(UUID uid) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", uid);
        try {
            jdbcTemplate.queryForObject(SELECT_TOKEN_BY_UID, params, deviceAccessTokenRowMapper);
            return true;
        } catch (EmptyResultDataAccessException e) {
            return false;
        }
    }

    @Transactional(readOnly = true)
    boolean tokenExists(String token) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("token", token);
        try {
            jdbcTemplate.queryForObject(SELECT_TOKEN_BY_TOKEN, params, deviceAccessTokenRowMapper);
            return true;
        } catch (EmptyResultDataAccessException e) {
            return false;
        }
    }

    // Дополнительные методы для внутреннего использования
    @Transactional(readOnly = true)
    boolean isTokenValid(String token) {
        try {
            DeviceAccessTokenDALM deviceAccessToken = findByToken(token);
            return deviceAccessToken.getExpiresAt().after(new Date());
        } catch (DeviceAccessTokenNotFoundException e) {
            return false;
        }
    }

    @Transactional(readOnly = true)
    boolean isTokenValid(UUID uid) {
        try {
            DeviceAccessTokenDALM deviceAccessToken = findByUid(uid);
            return deviceAccessToken.getExpiresAt().after(new Date());
        } catch (DeviceAccessTokenNotFoundException e) {
            return false;
        }
    }
}package com.connection.device.token.repository;

import java.util.UUID;

import com.connection.device.token.exception.DeviceAccessTokenExistsException;
import com.connection.device.token.exception.DeviceAccessTokenNotFoundException;
import com.connection.device.token.model.DeviceAccessTokenDALM;

public interface DeviceAccessTokenRepository {
    /**
     * Добавить новый device access token
     * 
     * @param deviceAccessTokenDALM Новый токен
     * @throws DeviceAccessTokenExistsException Если активный токен уже существует
     */
    void add(DeviceAccessTokenDALM deviceAccessTokenDALM) throws DeviceAccessTokenExistsException;

    /**
     * Найти токен по UID
     * 
     * @param uid UID токена
     * @return Найденный токен
     * @throws DeviceAccessTokenNotFoundException Если токен не найден
     */
    DeviceAccessTokenDALM findByUid(UUID uid) throws DeviceAccessTokenNotFoundException;

    /**
     * Найти токен по значению токена
     * 
     * @param token Значение токена
     * @return Найденный токен
     * @throws DeviceAccessTokenNotFoundException Если токен не найден
     */
    DeviceAccessTokenDALM findByToken(String token) throws DeviceAccessTokenNotFoundException;

    /**
     * Найти токен по UID device token
     * 
     * @param deviceTokenUid UID device token
     * @return Найденный токен
     * @throws DeviceAccessTokenNotFoundException Если токен не найден
     */
    DeviceAccessTokenDALM findByDeviceTokenUid(UUID deviceTokenUid) throws DeviceAccessTokenNotFoundException;

    /**
     * Отозвать токен по UID
     * 
     * @param uid UID токена
     * @throws DeviceAccessTokenNotFoundException Если токен не найден
     */
    void revoke(UUID uid) throws DeviceAccessTokenNotFoundException;

    /**
     * Отозвать все токены по UID device token
     * 
     * @param deviceTokenUid UID device token
     */
    void revokeByDeviceTokenUid(UUID deviceTokenUid);

    /**
     * Отозвать все истекшие токены
     */
    void revokeAllExpired();

    /**
     * Проверить наличие активного токена для device token
     * 
     * @param deviceTokenUid UID device token
     * @return true если активный токен существует
     */
    boolean hasDeviceAccessToken(UUID deviceTokenUid);
}package com.connection.device.token.repository;

import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Timestamp;
import java.util.Date;
import java.util.UUID;

import com.connection.device.token.exception.DeviceTokenAlreadyExistsException;
import com.connection.device.token.exception.DeviceTokenNotFoundException;
import com.connection.device.token.model.DeviceTokenDALM;

@Repository
public class DeviceTokenRepositorySQLImpl implements DeviceTokenRepository {

    private static final String SELECT_DEVICE_TOKEN = "SELECT uid, device_uid, token, created_at, expires_at";
    private static final String FROM_DEVICE_TOKEN = " FROM access.device_token";

    private static final String SELECT_TOKEN_BY_UID = SELECT_DEVICE_TOKEN + FROM_DEVICE_TOKEN + " WHERE uid = :uid";
    private static final String SELECT_TOKEN_BY_TOKEN = SELECT_DEVICE_TOKEN + FROM_DEVICE_TOKEN + " WHERE token = :token";
    private static final String SELECT_TOKEN_BY_DEVICE_UID = SELECT_DEVICE_TOKEN + FROM_DEVICE_TOKEN + " WHERE device_uid = :device_uid";

    private static final String INSERT_DEVICE_TOKEN = "INSERT INTO access.device_token (uid, device_uid, token, created_at, expires_at) " +
            "VALUES (:uid, :device_uid, :token, :created_at, :expires_at)";

    private static final String UPDATE_TOKEN = "UPDATE access.device_token SET token = :token, expires_at = :expires_at " +
            "WHERE uid = :uid";

    private static final String REVOKE_TOKEN = "DELETE FROM access.device_token WHERE uid = :uid";
    private static final String REVOKE_BY_DEVICE_UID = "DELETE FROM access.device_token WHERE device_uid = :device_uid";
    private static final String CLEANUP_EXPIRED_TOKENS = "DELETE FROM access.device_token WHERE expires_at < NOW()";
    private static final String EXISTS_BY_DEVICE_UID = "SELECT COUNT(*) FROM access.device_token WHERE device_uid = :device_uid AND expires_at > NOW()";

    private final NamedParameterJdbcTemplate jdbcTemplate;

    private final RowMapper<DeviceTokenDALM> deviceTokenRowMapper = (rs, rowNum) -> {
        DeviceTokenDALM token = new DeviceTokenDALM();
        token.setUid(UUID.fromString(rs.getString("uid")));
        token.setDeviceUid(UUID.fromString(rs.getString("device_uid")));
        token.setToken(rs.getString("token"));
        token.setCreatedAt(rs.getTimestamp("created_at"));
        token.setExpiresAt(rs.getTimestamp("expires_at"));
        return token;
    };

    public DeviceTokenRepositorySQLImpl(NamedParameterJdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    @Transactional
    public void add(DeviceTokenDALM deviceTokenDALM) throws DeviceTokenAlreadyExistsException {
        // Проверяем существование по token
        if (tokenExists(deviceTokenDALM.getToken())) {
            throw new DeviceTokenAlreadyExistsException("Device token already exists");
        }

        // Проверяем существование по uid
        if (uidExists(deviceTokenDALM.getUid())) {
            throw new DeviceTokenAlreadyExistsException("Device token with UID " + deviceTokenDALM.getUid() + " already exists");
        }

        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", deviceTokenDALM.getUid());
        params.addValue("device_uid", deviceTokenDALM.getDeviceUid());
        params.addValue("token", deviceTokenDALM.getToken());
        params.addValue("created_at", new Timestamp(deviceTokenDALM.getCreatedAt().getTime()));
        params.addValue("expires_at", new Timestamp(deviceTokenDALM.getExpiresAt().getTime()));

        jdbcTemplate.update(INSERT_DEVICE_TOKEN, params);
    }

    @Override
    @Transactional(readOnly = true)
    public DeviceTokenDALM findByUid(UUID uid) throws DeviceTokenNotFoundException {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", uid);
        try {
            return jdbcTemplate.queryForObject(SELECT_TOKEN_BY_UID, params, deviceTokenRowMapper);
        } catch (EmptyResultDataAccessException e) {
            throw new DeviceTokenNotFoundException("Device token with UID " + uid + " not found");
        }
    }

    @Override
    @Transactional(readOnly = true)
    public DeviceTokenDALM findByToken(String token) throws DeviceTokenNotFoundException {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("token", token);
        try {
            return jdbcTemplate.queryForObject(SELECT_TOKEN_BY_TOKEN, params, deviceTokenRowMapper);
        } catch (EmptyResultDataAccessException e) {
            throw new DeviceTokenNotFoundException("Device token not found");
        }
    }

    @Override
    @Transactional(readOnly = true)
    public DeviceTokenDALM findByDeviceUid(UUID deviceUid) throws DeviceTokenNotFoundException {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("device_uid", deviceUid);
        try {
            return jdbcTemplate.queryForObject(SELECT_TOKEN_BY_DEVICE_UID, params, deviceTokenRowMapper);
        } catch (EmptyResultDataAccessException e) {
            throw new DeviceTokenNotFoundException("Device token for device UID " + deviceUid + " not found");
        }
    }

    @Override
    @Transactional
    public void revoke(UUID uid) throws DeviceTokenNotFoundException {
        // Проверяем существование токена
        if (!uidExists(uid)) {
            throw new DeviceTokenNotFoundException("Device token with UID " + uid + " not found");
        }

        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", uid);

        jdbcTemplate.update(REVOKE_TOKEN, params);
    }

    @Override
    @Transactional
    public void revokeByDeviceUid(UUID deviceUid) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("device_uid", deviceUid);

        jdbcTemplate.update(REVOKE_BY_DEVICE_UID, params);
    }

    @Override
    @Transactional
    public void cleanUpExpired() {
        jdbcTemplate.update(CLEANUP_EXPIRED_TOKENS, new MapSqlParameterSource());
    }

    @Override
    @Transactional(readOnly = true)
    public boolean existsByDeviceUid(UUID deviceUid) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("device_uid", deviceUid);
        Integer count = jdbcTemplate.queryForObject(EXISTS_BY_DEVICE_UID, params, Integer.class);
        return count != null && count > 0;
    }

    // Вспомогательные методы
    @Transactional(readOnly = true)
    boolean uidExists(UUID uid) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", uid);
        try {
            jdbcTemplate.queryForObject(SELECT_TOKEN_BY_UID, params, deviceTokenRowMapper);
            return true;
        } catch (EmptyResultDataAccessException e) {
            return false;
        }
    }

    @Transactional(readOnly = true)
    boolean tokenExists(String token) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("token", token);
        try {
            jdbcTemplate.queryForObject(SELECT_TOKEN_BY_TOKEN, params, deviceTokenRowMapper);
            return true;
        } catch (EmptyResultDataAccessException e) {
            return false;
        }
    }

    // Дополнительные методы для внутреннего использования
    @Transactional(readOnly = true)
    boolean isTokenValid(String token) {
        try {
            DeviceTokenDALM deviceToken = findByToken(token);
            return deviceToken.getExpiresAt().after(new Date());
        } catch (DeviceTokenNotFoundException e) {
            return false;
        }
    }

    @Transactional(readOnly = true)
    boolean isTokenValid(UUID uid) {
        try {
            DeviceTokenDALM deviceToken = findByUid(uid);
            return deviceToken.getExpiresAt().after(new Date());
        } catch (DeviceTokenNotFoundException e) {
            return false;
        }
    }
}package com.connection.device.token.repository;

import java.util.UUID;

import com.connection.device.token.exception.DeviceTokenAlreadyExistsException;
import com.connection.device.token.exception.DeviceTokenNotFoundException;
import com.connection.device.token.model.DeviceTokenDALM;

public interface DeviceTokenRepository {
    /**
     * Добавить новый device token
     * 
     * @param deviceTokenDALM Новый токен
     * @throws DeviceTokenAlreadyExistsException Если токен уже существует
     */
    void add(DeviceTokenDALM deviceTokenDALM) throws DeviceTokenAlreadyExistsException;

    /**
     * Найти токен по UID
     * 
     * @param uid UID токена
     * @return Найденный токен
     * @throws DeviceTokenNotFoundException Если токен не найден
     */
    DeviceTokenDALM findByUid(UUID uid) throws DeviceTokenNotFoundException;

    /**
     * Найти токен по значению токена
     * 
     * @param token Значение токена
     * @return Найденный токен
     * @throws DeviceTokenNotFoundException Если токен не найден
     */
    DeviceTokenDALM findByToken(String token) throws DeviceTokenNotFoundException;

    /**
     * Найти токен по UID устройства
     * 
     * @param deviceUid UID устройства
     * @return Найденный токен
     * @throws DeviceTokenNotFoundException Если токен не найден
     */
    DeviceTokenDALM findByDeviceUid(UUID deviceUid) throws DeviceTokenNotFoundException;

    /**
     * Отозвать токен по UID
     * 
     * @param uid UID токена
     * @throws DeviceTokenNotFoundException Если токен не найден
     */
    void revoke(UUID uid) throws DeviceTokenNotFoundException;

    /**
     * Отозвать все токены устройства
     * 
     * @param deviceUid UID устройства
     */
    void revokeByDeviceUid(UUID deviceUid);

    /**
     * Очистить истекшие токены
     */
    void cleanUpExpired();

    /**
     * Проверить существование активного токена для устройства
     * 
     * @param deviceUid UID устройства
     * @return true если активный токен существует
     */
    boolean existsByDeviceUid(UUID deviceUid);
}package com.connection.device.token.generator;

import static com.connection.device.token.mother.DeviceTokenObjectMother.*;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

import java.util.Date;
import java.util.UUID;

import javax.crypto.SecretKey;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

import com.connection.device.token.model.DeviceTokenBLM;

import io.jsonwebtoken.security.Keys;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Device Token Generator Tests")
class DeviceTokenGeneratorTest {

    private DeviceTokenGenerator generator;
    private SecretKey secretKey;

    @BeforeEach
    void setUp() {
        secretKey = Keys.hmacShaKeyFor("test-secret-key-1234567890-1234567890".getBytes());
        generator = new DeviceTokenGenerator(secretKey, "test-app", "device-token");
    }

    @Test
    @DisplayName("Generate device token - Positive")
    void testGenerateDeviceToken_Positive() {
        String token = generator.generateDeviceToken(
            createValidDeviceTokenDALM().getDeviceUid(),
            createValidDeviceTokenDALM().getCreatedAt(),
            createValidDeviceTokenDALM().getExpiresAt()
        );
        assertThat(token).isNotNull().isNotEmpty();
    }

    @Test
    @DisplayName("Parse valid device token - Positive")
    void testGetDeviceTokenBLM_Positive() {
        String tokenString = generator.generateDeviceToken(
            createValidDeviceTokenDALM().getDeviceUid(),
            createValidDeviceTokenDALM().getCreatedAt(),
            createValidDeviceTokenDALM().getExpiresAt()
        );
        
        DeviceTokenBLM result = generator.getDeviceTokenBLM(tokenString);
        assertThat(result).isNotNull();
        assertThat(result.getDeviceUid()).isEqualTo(createValidDeviceTokenDALM().getDeviceUid());
        assertThat(result.getToken()).isEqualTo(tokenString);
    }

    @Test
    @DisplayName("Parse invalid device token - Negative")
    void testGetDeviceTokenBLMWithInvalidToken_Negative() {
        assertThatThrownBy(() -> generator.getDeviceTokenBLM("invalid.token.here"))
                .isInstanceOf(RuntimeException.class);
    }

    @Test
    @DisplayName("Parse device token with wrong subject - Negative")
    void testGetDeviceTokenBLMWithWrongSubject_Negative() {
        DeviceTokenGenerator wrongSubjectGenerator = new DeviceTokenGenerator(secretKey, "test-app", "wrong-subject");
        
        String tokenString = generator.generateDeviceToken(
            createValidDeviceTokenDALM().getDeviceUid(),
            createValidDeviceTokenDALM().getCreatedAt(),
            createValidDeviceTokenDALM().getExpiresAt()
        );
        
        assertThatThrownBy(() -> wrongSubjectGenerator.getDeviceTokenBLM(tokenString))
                .isInstanceOf(RuntimeException.class)
                .hasMessageContaining("Invalid token subject");
    }

    @Test
    @DisplayName("Parse device token with wrong type - Negative")
    void testGetDeviceTokenBLMWithWrongType_Negative() {
        DeviceTokenGenerator wrongTypeGenerator = new DeviceTokenGenerator(secretKey, "test-app", "device-token") {
            @Override
            public String generateDeviceToken(java.util.UUID deviceUid, Date createdAt, Date expiresAt) {
                return io.jsonwebtoken.Jwts.builder()
                    .issuer("test-app")
                    .subject("device-token")
                    .claim("deviceUid", deviceUid.toString())
                    .claim("type", "wrong-type")
                    .issuedAt(createdAt)
                    .expiration(expiresAt)
                    .signWith(secretKey)
                    .compact();
            }
        };
        
        String tokenString = wrongTypeGenerator.generateDeviceToken(
            createValidDeviceTokenDALM().getDeviceUid(),
            createValidDeviceTokenDALM().getCreatedAt(),
            createValidDeviceTokenDALM().getExpiresAt()
        );
        
        assertThatThrownBy(() -> generator.getDeviceTokenBLM(tokenString))
                .isInstanceOf(RuntimeException.class)
                .hasMessageContaining("Invalid token type");
    }

    @Test
    @DisplayName("Generate and parse round trip - Positive")
    void testGenerateAndParseRoundTrip_Positive() {
        String token = generator.generateDeviceToken(
            createValidDeviceTokenDALM().getDeviceUid(),
            createValidDeviceTokenDALM().getCreatedAt(),
            createValidDeviceTokenDALM().getExpiresAt()
        );
        
        DeviceTokenBLM parsed = generator.getDeviceTokenBLM(token);
        
        assertThat(parsed.getDeviceUid()).isEqualTo(createValidDeviceTokenDALM().getDeviceUid());
        assertThat(parsed.getToken()).isEqualTo(token);
        assertThat(parsed.getCreatedAt()).isNotNull();
        assertThat(parsed.getExpiresAt()).isNotNull();
    }

    @Test
    @DisplayName("Generate token with different dates - Positive")
    void testGenerateDeviceTokenWithDifferentDates_Positive() {
        Date createdAt = new Date(System.currentTimeMillis() - 1000L * 60 * 10);
        Date expiresAt = new Date(System.currentTimeMillis() + 1000L * 60 * 30);
        
        String token = generator.generateDeviceToken(
            createValidDeviceTokenDALM().getDeviceUid(),
            createdAt,
            expiresAt
        );
        
        DeviceTokenBLM result = generator.getDeviceTokenBLM(token);
        
        assertThat(result.getDeviceUid()).isEqualTo(result.getDeviceUid());
        assertThat(result.getToken()).isEqualTo(token);
    }

    @Test
    @DisplayName("Generate multiple tokens for same device - Positive")
    void testGenerateMultipleTokensForSameDevice_Positive() {
        UUID deviceUid = createValidDeviceTokenDALM().getDeviceUid();
        Date createdAt1 = new Date(System.currentTimeMillis() - 1000L * 60 * 5);
        Date expiresAt1 = new Date(System.currentTimeMillis() + 1000L * 60 * 15);
        
        Date createdAt2 = new Date(System.currentTimeMillis() - 1000L * 60 * 2);
        Date expiresAt2 = new Date(System.currentTimeMillis() + 1000L * 60 * 25);
        
        String token1 = generator.generateDeviceToken(deviceUid, createdAt1, expiresAt1);
        String token2 = generator.generateDeviceToken(deviceUid, createdAt2, expiresAt2);
        
        DeviceTokenBLM result1 = generator.getDeviceTokenBLM(token1);
        DeviceTokenBLM result2 = generator.getDeviceTokenBLM(token2);
        
        assertThat(result1.getDeviceUid()).isEqualTo(deviceUid);
        assertThat(result2.getDeviceUid()).isEqualTo(deviceUid);
        assertThat(token1).isNotEqualTo(token2);
    }
}package com.connection.device.token.generator;

import static com.connection.device.token.mother.DeviceTokenObjectMother.*;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

import java.util.Date;
import java.util.UUID;

import javax.crypto.SecretKey;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

import com.connection.device.token.model.DeviceAccessTokenBLM;
import com.connection.device.token.model.DeviceTokenBLM;

import io.jsonwebtoken.security.Keys;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Device Access Token Generator Tests")
class DeviceAccessTokenGeneratorTest {

    private DeviceAccessTokenGenerator generator;
    private SecretKey secretKey;

    @BeforeEach
    void setUp() {
        secretKey = Keys.hmacShaKeyFor("test-secret-key-1234567890-1234567890".getBytes());
        generator = new DeviceAccessTokenGenerator(secretKey, "test-app", "device-access-token");
    }

    @Test
    @DisplayName("Generate device access token - Positive")
    void testGenerateDeviceAccessToken_Positive() {
        String token = generator.generateDeviceAccessToken(
            createValidDeviceAccessTokenDALM().getDeviceTokenUid(),
            createValidDeviceAccessTokenDALM().getCreatedAt(),
            createValidDeviceAccessTokenDALM().getExpiresAt()
        );
        assertThat(token).isNotNull().isNotEmpty();
    }

    @Test
    @DisplayName("Parse valid device access token - Positive")
    void testGetDeviceAccessTokenBLM_Positive() {
        String tokenString = generator.generateDeviceAccessToken(
            createValidDeviceAccessTokenDALM().getDeviceTokenUid(),
            createValidDeviceAccessTokenDALM().getCreatedAt(),
            createValidDeviceAccessTokenDALM().getExpiresAt()
        );
        
        DeviceAccessTokenBLM result = generator.getDeviceAccessTokenBLM(tokenString);
        assertThat(result).isNotNull();
        assertThat(result.getDeviceTokenUid()).isEqualTo(createValidDeviceAccessTokenDALM().getDeviceTokenUid());
        assertThat(result.getToken()).isEqualTo(tokenString);
    }

    @Test
    @DisplayName("Parse invalid device access token - Negative")
    void testGetDeviceAccessTokenBLMWithInvalidToken_Negative() {
        assertThatThrownBy(() -> generator.getDeviceAccessTokenBLM("invalid.token.here"))
                .isInstanceOf(RuntimeException.class);
    }

    @Test
    @DisplayName("Parse device access token with wrong subject - Negative")
    void testGetDeviceAccessTokenBLMWithWrongSubject_Negative() {
        DeviceAccessTokenGenerator wrongSubjectGenerator = new DeviceAccessTokenGenerator(secretKey, "test-app", "wrong-subject");
        
        String tokenString = generator.generateDeviceAccessToken(
            createValidDeviceAccessTokenDALM().getDeviceTokenUid(),
            createValidDeviceAccessTokenDALM().getCreatedAt(),
            createValidDeviceAccessTokenDALM().getExpiresAt()
        );
        
        assertThatThrownBy(() -> wrongSubjectGenerator.getDeviceAccessTokenBLM(tokenString))
                .isInstanceOf(RuntimeException.class)
                .hasMessageContaining("Invalid token subject");
    }

    @Test
    @DisplayName("Parse device access token with wrong type - Negative")
    void testGetDeviceAccessTokenBLMWithWrongType_Negative() {
        DeviceAccessTokenGenerator wrongTypeGenerator = new DeviceAccessTokenGenerator(secretKey, "test-app", "device-access-token") {
            @Override
            public String generateDeviceAccessToken(java.util.UUID deviceTokenUid, Date createdAt, Date expiresAt) {
                return io.jsonwebtoken.Jwts.builder()
                    .issuer("test-app")
                    .subject("device-access-token")
                    .claim("deviceTokenUid", deviceTokenUid.toString())
                    .claim("type", "wrong-type")
                    .issuedAt(createdAt)
                    .expiration(expiresAt)
                    .signWith(secretKey)
                    .compact();
            }
        };
        
        String tokenString = wrongTypeGenerator.generateDeviceAccessToken(
            createValidDeviceAccessTokenDALM().getDeviceTokenUid(),
            createValidDeviceAccessTokenDALM().getCreatedAt(),
            createValidDeviceAccessTokenDALM().getExpiresAt()
        );
        
        assertThatThrownBy(() -> generator.getDeviceAccessTokenBLM(tokenString))
                .isInstanceOf(RuntimeException.class)
                .hasMessageContaining("Invalid token type");
    }

    @Test
    @DisplayName("Generate and parse round trip - Positive")
    void testGenerateAndParseRoundTrip_Positive() {
        String token = generator.generateDeviceAccessToken(
            createValidDeviceAccessTokenDALM().getDeviceTokenUid(),
            createValidDeviceAccessTokenDALM().getCreatedAt(),
            createValidDeviceAccessTokenDALM().getExpiresAt()
        );
        
        DeviceAccessTokenBLM parsed = generator.getDeviceAccessTokenBLM(token);
        
        assertThat(parsed.getDeviceTokenUid()).isEqualTo(createValidDeviceAccessTokenDALM().getDeviceTokenUid());
        assertThat(parsed.getToken()).isEqualTo(token);
        assertThat(parsed.getCreatedAt()).isNotNull();
        assertThat(parsed.getExpiresAt()).isNotNull();
    }

    @Test
    @DisplayName("Generate token with expired date - Negative")
    void testGenerateDeviceAccessTokenWithExpiredDate_Positive() {
        Date createdAt = new Date(System.currentTimeMillis() - 1000L * 60 * 60 * 2);
        Date expiresAt = new Date(System.currentTimeMillis() - 1000L * 60 * 60 * 1);
        
        String token = generator.generateDeviceAccessToken(
            createValidDeviceAccessTokenDALM().getDeviceTokenUid(),
            createdAt,
            expiresAt
        );
    
        assertThatThrownBy(() -> generator.getDeviceAccessTokenBLM(token))
            .isInstanceOf(RuntimeException.class);
      
    }

    @Test
    @DisplayName("Generate token with future creation date - Positive")
    void testGenerateDeviceAccessTokenWithFutureCreationDate_Positive() {
        Date createdAt = new Date(System.currentTimeMillis() + 1000L * 60 * 10);
        Date expiresAt = new Date(System.currentTimeMillis() + 1000L * 60 * 60);
        
        String token = generator.generateDeviceAccessToken(
            createValidDeviceAccessTokenDALM().getDeviceTokenUid(),
            createdAt,
            expiresAt
        );
        
        DeviceAccessTokenBLM result = generator.getDeviceAccessTokenBLM(token);
        
        assertThat(result.getCreatedAt().after(new Date())).isTrue();
    }

    @Test
    @DisplayName("Compare device token and device access token structure")
    void testCompareTokenStructures() {
        UUID deviceUid = createValidDeviceTokenDALM().getDeviceUid();
        UUID deviceTokenUid = createValidDeviceAccessTokenDALM().getDeviceTokenUid();
        Date createdAt = new Date();
        Date expiresAt = new Date(System.currentTimeMillis() + 3600000);
        
        DeviceTokenGenerator deviceTokenGenerator = new DeviceTokenGenerator(secretKey, "test-app", "device-token");
        String deviceToken = deviceTokenGenerator.generateDeviceToken(deviceUid, createdAt, expiresAt);
        
        String deviceAccessToken = generator.generateDeviceAccessToken(deviceTokenUid, createdAt, expiresAt);
        
        DeviceTokenBLM deviceTokenBLM = deviceTokenGenerator.getDeviceTokenBLM(deviceToken);
        DeviceAccessTokenBLM deviceAccessTokenBLM = generator.getDeviceAccessTokenBLM(deviceAccessToken);
        
        assertThat(deviceTokenBLM.getDeviceUid()).isEqualTo(deviceUid);
        assertThat(deviceAccessTokenBLM.getDeviceTokenUid()).isEqualTo(deviceTokenUid);
        assertThat(deviceToken).isNotEqualTo(deviceAccessToken);
    }
}package com.connection.device.token.converter;

import static com.connection.device.token.mother.DeviceTokenObjectMother.*;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import com.connection.device.token.generator.DeviceTokenGenerator;
import com.connection.device.token.model.DeviceTokenBLM;
import com.connection.device.token.model.DeviceTokenDALM;
import com.connection.device.token.model.DeviceTokenDTO;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Device Token Converter Tests")
class DeviceTokenConverterTest {

    @Mock
    private DeviceTokenGenerator deviceTokenGenerator;

    private DeviceTokenConverter converter;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        converter = new DeviceTokenConverter(deviceTokenGenerator);
    }

    @Test
    @DisplayName("Convert DALM to BLM - Positive")
    void testToBLMFromDALM_Positive() {
        DeviceTokenDALM dalM = createValidDeviceTokenDALM();
        DeviceTokenBLM expectedBLM = createValidDeviceTokenBLM();
        
        when(deviceTokenGenerator.generateDeviceToken(any(), any(), any()))
                .thenReturn(expectedBLM.getToken());

        DeviceTokenBLM result = converter.toBLM(dalM);

        assertThat(result).isNotNull();
        assertThat(result.getUid()).isEqualTo(dalM.getUid());
        assertThat(result.getDeviceUid()).isEqualTo(dalM.getDeviceUid());
        assertThat(result.getCreatedAt()).isEqualTo(dalM.getCreatedAt());
        assertThat(result.getExpiresAt()).isEqualTo(dalM.getExpiresAt());
    }

    @Test
    @DisplayName("Convert DTO to BLM - Positive")
    void testToBLMFromDTO_Positive() {
        DeviceTokenDTO dto = createValidDeviceTokenDTO();
        DeviceTokenBLM expectedBLM = createValidDeviceTokenBLM();
        
        when(deviceTokenGenerator.getDeviceTokenBLM(dto.getToken()))
                .thenReturn(expectedBLM);

        DeviceTokenBLM result = converter.toBLM(dto);

        assertThat(result).isNotNull();
        assertThat(result.getToken()).isEqualTo(dto.getToken());
    }

    @Test
    @DisplayName("Convert BLM to DTO - Positive")
    void testToDTOFromBLM_Positive() {
        DeviceTokenBLM blm = createValidDeviceTokenBLM();

        DeviceTokenDTO result = converter.toDTO(blm);

        assertThat(result).isNotNull();
        assertThat(result.getToken()).isEqualTo(blm.getToken());
    }

    @Test
    @DisplayName("Convert BLM to DALM - Positive")
    void testToDALMFromBLM_Positive() {
        DeviceTokenBLM blm = createValidDeviceTokenBLM();

        DeviceTokenDALM result = converter.toDALM(blm);

        assertThat(result).isNotNull();
        assertThat(result.getUid()).isEqualTo(blm.getUid());
        assertThat(result.getDeviceUid()).isEqualTo(blm.getDeviceUid());
        assertThat(result.getToken()).isEqualTo(blm.getToken());
        assertThat(result.getCreatedAt()).isEqualTo(blm.getCreatedAt());
        assertThat(result.getExpiresAt()).isEqualTo(blm.getExpiresAt());
    }

    @Test
    @DisplayName("Convert DTO to BLM with invalid token - Negative")
    void testToBLMFromDTOWithInvalidToken_Negative() {
        DeviceTokenDTO dto = createValidDeviceTokenDTO();
        
        when(deviceTokenGenerator.getDeviceTokenBLM(dto.getToken()))
                .thenThrow(new RuntimeException("Invalid JWT token"));

        assertThatThrownBy(() -> converter.toBLM(dto))
                .isInstanceOf(RuntimeException.class)
                .hasMessageContaining("Invalid JWT token");
    }
}package com.connection.device.token.converter;

import static com.connection.device.token.mother.DeviceTokenObjectMother.*;
import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;


import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import com.connection.device.token.generator.DeviceAccessTokenGenerator;
import com.connection.device.token.model.DeviceAccessTokenBLM;
import com.connection.device.token.model.DeviceAccessTokenDALM;
import com.connection.device.token.model.DeviceAccessTokenDTO;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Device Access Token Converter Tests")
class DeviceAccessTokenConverterTest {

    @Mock
    private DeviceAccessTokenGenerator deviceAccessTokenGenerator;

    private DeviceAccessTokenConverter converter;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        converter = new DeviceAccessTokenConverter(deviceAccessTokenGenerator);
    }

    @Test
    @DisplayName("Convert DALM to BLM - Positive")
    void testToBLMFromDALM_Positive() {
        DeviceAccessTokenDALM dalM = createValidDeviceAccessTokenDALM();
        DeviceAccessTokenBLM expectedBLM = createValidDeviceAccessTokenBLM();
        
        when(deviceAccessTokenGenerator.generateDeviceAccessToken(any(), any(), any()))
                .thenReturn(expectedBLM.getToken());

        DeviceAccessTokenBLM result = converter.toBLM(dalM);

        assertThat(result).isNotNull();
        assertThat(result.getUid()).isEqualTo(dalM.getUid());
        assertThat(result.getDeviceTokenUid()).isEqualTo(dalM.getDeviceTokenUid());
        assertThat(result.getCreatedAt()).isEqualTo(dalM.getCreatedAt());
        assertThat(result.getExpiresAt()).isEqualTo(dalM.getExpiresAt());
    }

    @Test
    @DisplayName("Convert DTO to BLM - Positive")
    void testToBLMFromDTO_Positive() {
        DeviceAccessTokenDTO dto = createValidDeviceAccessTokenDTO();
        DeviceAccessTokenBLM expectedBLM = createValidDeviceAccessTokenBLM();
        
        when(deviceAccessTokenGenerator.getDeviceAccessTokenBLM(dto.getToken()))
                .thenReturn(expectedBLM);

        DeviceAccessTokenBLM result = converter.toBLM(dto);

        assertThat(result).isNotNull();
        assertThat(result.getToken()).isEqualTo(dto.getToken());
    }

    @Test
    @DisplayName("Convert BLM to DTO - Positive")
    void testToDTOFromBLM_Positive() {
        DeviceAccessTokenBLM blm = createValidDeviceAccessTokenBLM();

        DeviceAccessTokenDTO result = converter.toDTO(blm);

        assertThat(result).isNotNull();
        assertThat(result.getToken()).isEqualTo(blm.getToken());
    }

    @Test
    @DisplayName("Convert BLM to DALM - Positive")
    void testToDALMFromBLM_Positive() {
        DeviceAccessTokenBLM blm = createValidDeviceAccessTokenBLM();

        DeviceAccessTokenDALM result = converter.toDALM(blm);

        assertThat(result).isNotNull();
        assertThat(result.getUid()).isEqualTo(blm.getUid());
        assertThat(result.getDeviceTokenUid()).isEqualTo(blm.getDeviceTokenUid());
        assertThat(result.getToken()).isEqualTo(blm.getToken());
        assertThat(result.getCreatedAt()).isEqualTo(blm.getCreatedAt());
        assertThat(result.getExpiresAt()).isEqualTo(blm.getExpiresAt());
    }
}package com.connection.device.token.validator;

import static com.connection.device.token.mother.DeviceTokenObjectMother.*;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

import java.util.Date;
import java.util.UUID;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

import com.connection.device.token.exception.DeviceTokenValidateException;
import com.connection.device.token.model.DeviceTokenBLM;
import com.connection.device.token.model.DeviceTokenDALM;
import com.connection.device.token.model.DeviceTokenDTO;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Device Token Validator Tests")
class DeviceTokenValidatorTest {

    private DeviceTokenValidator validator;

    @BeforeEach
    void setUp() {
        validator = new DeviceTokenValidator();
    }

    @Test
    @DisplayName("Validate valid DeviceTokenDTO - Positive")
    void testValidateDeviceTokenDTO_Positive() {
        DeviceTokenDTO deviceToken = createValidDeviceTokenDTO();
        assertThat(deviceToken).isNotNull();
        validator.validate(deviceToken);
    }

    @Test
    @DisplayName("Validate valid DeviceTokenBLM - Positive")
    void testValidateDeviceTokenBLM_Positive() {
        DeviceTokenBLM deviceToken = createValidDeviceTokenBLM();
        assertThat(deviceToken).isNotNull();
        validator.validate(deviceToken);
    }

    @Test
    @DisplayName("Validate valid DeviceTokenDALM - Positive")
    void testValidateDeviceTokenDALM_Positive() {
        DeviceTokenDALM deviceToken = createValidDeviceTokenDALM();
        assertThat(deviceToken).isNotNull();
        validator.validate(deviceToken);
    }

    @Test
    @DisplayName("Validate null DeviceTokenDTO - Negative")
    void testValidateNullDeviceTokenDTO_Negative() {
        DeviceTokenDTO deviceToken = null;
        assertThatThrownBy(() -> validator.validate(deviceToken))
                .isInstanceOf(DeviceTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate DeviceTokenDTO with empty token - Negative")
    void testValidateDeviceTokenDTOWithEmptyToken_Negative() {
        DeviceTokenDTO deviceToken = createDeviceTokenDTOWithEmptyToken();
        assertThatThrownBy(() -> validator.validate(deviceToken))
                .isInstanceOf(RuntimeException.class);
    }

    @Test
    @DisplayName("Validate DeviceTokenBLM with expired token - Negative")
    void testValidateDeviceTokenBLMWithExpiredToken_Negative() {
        DeviceTokenBLM deviceToken = createDeviceTokenBLMWithExpiredToken();
        assertThatThrownBy(() -> validator.validate(deviceToken))
                .isInstanceOf(RuntimeException.class);
    }

    @Test
    @DisplayName("Validate DeviceTokenBLM with future creation date - Negative")
    void testValidateDeviceTokenBLMWithFutureCreationDate_Negative() {
        DeviceTokenBLM deviceToken = createDeviceTokenBLMWithFutureCreationDate();
        assertThatThrownBy(() -> validator.validate(deviceToken))
                .isInstanceOf(RuntimeException.class);
    }

    @Test
    @DisplayName("Validate DeviceTokenDALM with null UID - Negative")
    void testValidateDeviceTokenDALMWithNullUid_Negative() {
        DeviceTokenDALM deviceToken = DeviceTokenDALM.builder()
                .uid(null)
                .deviceUid(UUID.randomUUID())
                .token("valid.token")
                .createdAt(new Date())
                .expiresAt(new Date(System.currentTimeMillis() + 3600000))
                .build();
        assertThatThrownBy(() -> validator.validate(deviceToken))
                .isInstanceOf(RuntimeException.class);
    }

    @Test
    @DisplayName("Validate DeviceTokenBLM with long token - Negative")
    void testValidateDeviceTokenBLMWithLongToken_Negative() {
        DeviceTokenBLM deviceToken = DeviceTokenBLM.builder()
                .token("a".repeat(513))
                .uid(UUID.randomUUID())
                .deviceUid(UUID.randomUUID())
                .createdAt(new Date())
                .expiresAt(new Date(System.currentTimeMillis() + 3600000))
                .build();
        assertThatThrownBy(() -> validator.validate(deviceToken))
                .isInstanceOf(RuntimeException.class);
    }
}package com.connection.device.token.validator;

import static com.connection.device.token.mother.DeviceTokenObjectMother.*;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

import java.util.Date;
import java.util.UUID;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

import com.connection.device.token.exception.DeviceAccessTokenValidateException;
import com.connection.device.token.model.DeviceAccessTokenBLM;
import com.connection.device.token.model.DeviceAccessTokenDALM;
import com.connection.device.token.model.DeviceAccessTokenDTO;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Device Access Token Validator Tests")
class DeviceAccessTokenValidatorTest {

    private DeviceAccessTokenValidator validator;

    @BeforeEach
    void setUp() {
        validator = new DeviceAccessTokenValidator();
    }

    @Test
    @DisplayName("Validate valid DeviceAccessTokenDTO - Positive")
    void testValidateDeviceAccessTokenDTO_Positive() {
        DeviceAccessTokenDTO deviceToken = createValidDeviceAccessTokenDTO();
        assertThat(deviceToken).isNotNull();
        validator.validate(deviceToken);
    }

    @Test
    @DisplayName("Validate valid DeviceAccessTokenBLM - Positive")
    void testValidateDeviceAccessTokenBLM_Positive() {
        DeviceAccessTokenBLM deviceToken = createValidDeviceAccessTokenBLM();
        assertThat(deviceToken).isNotNull();
        validator.validate(deviceToken);
    }

    @Test
    @DisplayName("Validate valid DeviceAccessTokenDALM - Positive")
    void testValidateDeviceAccessTokenDALM_Positive() {
        DeviceAccessTokenDALM deviceToken = createValidDeviceAccessTokenDALM();
        assertThat(deviceToken).isNotNull();
        validator.validate(deviceToken);
    }

    @Test
    @DisplayName("Validate null DeviceAccessTokenDTO - Negative")
    void testValidateNullDeviceAccessTokenDTO_Negative() {
        DeviceAccessTokenDTO deviceToken = null;
        assertThatThrownBy(() -> validator.validate(deviceToken))
                .isInstanceOf(DeviceAccessTokenValidateException.class);
    }

    @Test
    @DisplayName("Validate DeviceAccessTokenDTO with long token - Negative")
    void testValidateDeviceAccessTokenDTOWithLongToken_Negative() {
        DeviceAccessTokenDTO deviceToken = createDeviceAccessTokenDTOWithLongToken();
        assertThatThrownBy(() -> validator.validate(deviceToken))
                .isInstanceOf(RuntimeException.class);
    }

    @Test
    @DisplayName("Validate DeviceAccessTokenBLM with invalid dates - Negative")
    void testValidateDeviceAccessTokenBLMWithInvalidDates_Negative() {
        DeviceAccessTokenBLM deviceToken = createDeviceAccessTokenBLMWithInvalidDates();
        assertThatThrownBy(() -> validator.validate(deviceToken))
                .isInstanceOf(RuntimeException.class);
    }

    @Test
    @DisplayName("Validate DeviceAccessTokenDALM with null device token UID - Negative")
    void testValidateDeviceAccessTokenDALMWithNullDeviceTokenUid_Negative() {
        DeviceAccessTokenDALM deviceToken = DeviceAccessTokenDALM.builder()
                .uid(UUID.randomUUID())
                .deviceTokenUid(null)
                .token("valid.token")
                .createdAt(new Date())
                .expiresAt(new Date(System.currentTimeMillis() + 3600000))
                .build();
        assertThatThrownBy(() -> validator.validate(deviceToken))
                .isInstanceOf(RuntimeException.class);
    }
}package com.connection.device.token.mother;

import java.util.Date;
import java.util.UUID;

import com.connection.device.token.model.DeviceAccessTokenBLM;
import com.connection.device.token.model.DeviceAccessTokenDALM;
import com.connection.device.token.model.DeviceAccessTokenDTO;
import com.connection.device.token.model.DeviceTokenBLM;
import com.connection.device.token.model.DeviceTokenDALM;
import com.connection.device.token.model.DeviceTokenDTO;

public class DeviceTokenObjectMother {

    private static final UUID DEFAULT_UID = UUID.fromString("123e4567-e89b-12d3-a456-426614174000");
    private static final UUID DEFAULT_DEVICE_UID = UUID.fromString("123e4567-e89b-12d3-a456-426614174001");
    private static final UUID DEFAULT_DEVICE_TOKEN_UID = UUID.fromString("123e4567-e89b-12d3-a456-426614174002");
    private static final String DEFAULT_TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.test.token";
    private static final Date DEFAULT_CREATED_AT = new Date(System.currentTimeMillis() - 3600000);
    private static final Date DEFAULT_EXPIRES_AT = new Date(System.currentTimeMillis() + 3600000);

    // DeviceToken objects
    public static DeviceTokenDTO createValidDeviceTokenDTO() {
        return DeviceTokenDTO.builder()
                .token(DEFAULT_TOKEN)
                .build();
    }

    public static DeviceTokenBLM createValidDeviceTokenBLM() {
        return DeviceTokenBLM.builder()
                .token(DEFAULT_TOKEN)
                .uid(DEFAULT_UID)
                .deviceUid(DEFAULT_DEVICE_UID)
                .createdAt(DEFAULT_CREATED_AT)
                .expiresAt(DEFAULT_EXPIRES_AT)
                .build();
    }

    public static DeviceTokenDALM createValidDeviceTokenDALM() {
        return DeviceTokenDALM.builder()
                .uid(DEFAULT_UID)
                .deviceUid(DEFAULT_DEVICE_UID)
                .token(DEFAULT_TOKEN)
                .createdAt(DEFAULT_CREATED_AT)
                .expiresAt(DEFAULT_EXPIRES_AT)
                .build();
    }

    public static DeviceTokenDTO createDeviceTokenDTOWithEmptyToken() {
        return DeviceTokenDTO.builder()
                .token("")
                .build();
    }

    public static DeviceTokenBLM createDeviceTokenBLMWithExpiredToken() {
        return DeviceTokenBLM.builder()
                .token(DEFAULT_TOKEN)
                .uid(DEFAULT_UID)
                .deviceUid(DEFAULT_DEVICE_UID)
                .createdAt(new Date(System.currentTimeMillis() - 7200000))
                .expiresAt(new Date(System.currentTimeMillis() - 3600000))
                .build();
    }

    public static DeviceTokenBLM createDeviceTokenBLMWithFutureCreationDate() {
        return DeviceTokenBLM.builder()
                .token(DEFAULT_TOKEN)
                .uid(DEFAULT_UID)
                .deviceUid(DEFAULT_DEVICE_UID)
                .createdAt(new Date(System.currentTimeMillis() + 3600000))
                .expiresAt(new Date(System.currentTimeMillis() + 7200000))
                .build();
    }

    // DeviceAccessToken objects
    public static DeviceAccessTokenDTO createValidDeviceAccessTokenDTO() {
        return DeviceAccessTokenDTO.builder()
                .token(DEFAULT_TOKEN)
                .build();
    }

    public static DeviceAccessTokenBLM createValidDeviceAccessTokenBLM() {
        return DeviceAccessTokenBLM.builder()
                .token(DEFAULT_TOKEN)
                .uid(DEFAULT_UID)
                .deviceTokenUid(DEFAULT_DEVICE_TOKEN_UID)
                .createdAt(DEFAULT_CREATED_AT)
                .expiresAt(DEFAULT_EXPIRES_AT)
                .build();
    }

    public static DeviceAccessTokenDALM createValidDeviceAccessTokenDALM() {
        return DeviceAccessTokenDALM.builder()
                .uid(DEFAULT_UID)
                .deviceTokenUid(DEFAULT_DEVICE_TOKEN_UID)
                .token(DEFAULT_TOKEN)
                .createdAt(DEFAULT_CREATED_AT)
                .expiresAt(DEFAULT_EXPIRES_AT)
                .build();
    }

    public static DeviceAccessTokenDTO createDeviceAccessTokenDTOWithLongToken() {
        return DeviceAccessTokenDTO.builder()
                .token("a".repeat(513))
                .build();
    }

    public static DeviceAccessTokenBLM createDeviceAccessTokenBLMWithInvalidDates() {
        return DeviceAccessTokenBLM.builder()
                .token(DEFAULT_TOKEN)
                .uid(DEFAULT_UID)
                .deviceTokenUid(DEFAULT_DEVICE_TOKEN_UID)
                .createdAt(new Date(System.currentTimeMillis() + 3600000))
                .expiresAt(new Date(System.currentTimeMillis() - 3600000))
                .build();
    }

    // Helper methods
    public static DeviceTokenDALM createDeviceTokenForDevice(UUID deviceUid) {
        return DeviceTokenDALM.builder()
                .uid(UUID.randomUUID())
                .deviceUid(deviceUid)
                .token("token_for_" + deviceUid)
                .createdAt(DEFAULT_CREATED_AT)
                .expiresAt(DEFAULT_EXPIRES_AT)
                .build();
    }

    public static DeviceAccessTokenDALM createDeviceAccessTokenForDeviceToken(UUID deviceTokenUid) {
        return DeviceAccessTokenDALM.builder()
                .uid(UUID.randomUUID())
                .deviceTokenUid(deviceTokenUid)
                .token("access_token_for_" + deviceTokenUid)
                .createdAt(DEFAULT_CREATED_AT)
                .expiresAt(DEFAULT_EXPIRES_AT)
                .build();
    }
}package com.connection.device.token.repository;

import static com.connection.device.token.mother.DeviceTokenObjectMother.createValidDeviceAccessTokenDALM;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.connection.device.token.exception.DeviceAccessTokenExistsException;
import com.connection.device.token.model.DeviceAccessTokenDALM;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Device Access Token Repository Tests")
class DeviceAccessTokenRepositorySQLImplTest {

    @Mock
    private NamedParameterJdbcTemplate jdbcTemplate;

    @InjectMocks
    private DeviceAccessTokenRepositorySQLImpl repository;

    private DeviceAccessTokenDALM testToken;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        testToken = createValidDeviceAccessTokenDALM();
    }

    @SuppressWarnings("unchecked")
    @Test
    @DisplayName("Add device access token - Positive")
    void testAddDeviceAccessToken_Positive() {
        when(jdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenThrow(new EmptyResultDataAccessException(1));
        when(jdbcTemplate.update(anyString(), any(MapSqlParameterSource.class))).thenReturn(1);

        repository.add(testToken);

        verify(jdbcTemplate, times(2)).queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class));
        verify(jdbcTemplate, times(1)).update(anyString(), any(MapSqlParameterSource.class));
    }

    @SuppressWarnings("unchecked")
    @Test
    @DisplayName("Add device access token with existing device token UID - Negative")
    void testAddDeviceAccessTokenWithExistingDeviceTokenUid_Negative() {
        when(jdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenReturn(testToken);

        assertThatThrownBy(() -> repository.add(testToken))
                .isInstanceOf(DeviceAccessTokenExistsException.class);

        verify(jdbcTemplate, never()).update(anyString(), any(MapSqlParameterSource.class));
    }

    @SuppressWarnings("unchecked")
    @Test
    @DisplayName("Find device access token by token - Positive")
    void testFindByToken_Positive() {
        when(jdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenReturn(testToken);

        DeviceAccessTokenDALM result = repository.findByToken(testToken.getToken());

        assertThat(result).isEqualTo(testToken);
    }

    @Test
    @DisplayName("Revoke by device token UID - Positive")
    void testRevokeByDeviceTokenUid_Positive() {
        when(jdbcTemplate.update(anyString(), any(MapSqlParameterSource.class))).thenReturn(1);

        repository.revokeByDeviceTokenUid(testToken.getDeviceTokenUid());

        verify(jdbcTemplate, times(1)).update(
                eq("DELETE FROM access.device_access_token WHERE device_token_uid = :device_token_uid"),
                any(MapSqlParameterSource.class));
    }
}package com.connection.device.token.repository;

import static com.connection.device.token.mother.DeviceTokenObjectMother.createValidDeviceTokenDALM;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.connection.device.token.exception.DeviceTokenAlreadyExistsException;
import com.connection.device.token.exception.DeviceTokenNotFoundException;
import com.connection.device.token.model.DeviceTokenDALM;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Device Token Repository Tests")
class DeviceTokenRepositorySQLImplTest {

    @Mock
    private NamedParameterJdbcTemplate jdbcTemplate;

    @InjectMocks
    private DeviceTokenRepositorySQLImpl repository;

    private DeviceTokenDALM testToken;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        testToken = createValidDeviceTokenDALM();
    }

    @SuppressWarnings("unchecked")
@Test
    @DisplayName("Add device token - Positive")
    void testAddDeviceToken_Positive() {
        when(jdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenThrow(new EmptyResultDataAccessException(1));
        when(jdbcTemplate.update(anyString(), any(MapSqlParameterSource.class))).thenReturn(1);

        repository.add(testToken);

        verify(jdbcTemplate, times(2)).queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class));
        verify(jdbcTemplate, times(1)).update(anyString(), any(MapSqlParameterSource.class));
    }

    @SuppressWarnings("unchecked")
@Test
    @DisplayName("Add existing device token - Negative")
    void testAddExistingDeviceToken_Negative() {
        when(jdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenReturn(testToken);

        assertThatThrownBy(() -> repository.add(testToken))
                .isInstanceOf(DeviceTokenAlreadyExistsException.class);

        verify(jdbcTemplate, never()).update(anyString(), any(MapSqlParameterSource.class));
    }

    @SuppressWarnings("unchecked")
@Test
    @DisplayName("Find device token by UID - Positive")
    void testFindByUid_Positive() {
        when(jdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenReturn(testToken);

        DeviceTokenDALM result = repository.findByUid(testToken.getUid());

        assertThat(result).isEqualTo(testToken);
    }

    @SuppressWarnings("unchecked")
@Test
    @DisplayName("Find non-existent device token by UID - Negative")
    void testFindByUid_Negative() {
        when(jdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenThrow(new EmptyResultDataAccessException(1));

        assertThatThrownBy(() -> repository.findByUid(testToken.getUid()))
                .isInstanceOf(DeviceTokenNotFoundException.class);
    }

    @SuppressWarnings("unchecked")
@Test
    @DisplayName("Revoke device token - Positive")
    void testRevoke_Positive() {
        when(jdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenReturn(testToken);
        when(jdbcTemplate.update(anyString(), any(MapSqlParameterSource.class))).thenReturn(1);

        repository.revoke(testToken.getUid());

        verify(jdbcTemplate, times(1)).update(
                eq("DELETE FROM access.device_token WHERE uid = :uid"),
                any(MapSqlParameterSource.class));
    }
}