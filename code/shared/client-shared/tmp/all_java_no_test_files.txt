package com.connection.client.exception;

public class ClientAddException extends BaseClientException{
    public ClientAddException(String clientString){
        super(clientString);
    }

    public String toString(){
        String res = super.toString();
        res += "\n" + "description: cannot add client";
        return res;
    }
}
package com.connection.client.exception;

public class BaseClientException extends RuntimeException{
    private final String clientString;

    public BaseClientException(String clientDescription){
        super("client");
        clientString = clientDescription;
    }

    public String toString(){
        String res = super.toString();
        res += "\n" + "client: " + clientString;
        return res;
    }
}
package com.connection.client.exception;

public class ClientNotFoundException extends BaseClientException {
    public ClientNotFoundException(String clientString) {
        super(clientString);
    }

    public String toString() {
        String res = super.toString();
        res += "\n" + "description: client not found";
        return res;
    }
}
package com.connection.client.exception;

public class ClientAlreadyExisistsException extends BaseClientException{
    private final String descriptionString = "client already exists";
    public ClientAlreadyExisistsException(String clientString){
        super(clientString);
    }

    public String toString(){
        String res = super.toString();
        res += "\n" + "description: " + descriptionString;
        return res;
    }
}
package com.connection.client.exception;

public class ClientValidateException extends BaseClientException{
    String descriptionString;
    public ClientValidateException(String clientString, String description){
        super(clientString);
        this.descriptionString = description;
    }

    public String toString(){
        String res = super.toString();
        res += "\n" + "description: client is invalid";
        res += "\n" + descriptionString;
        return res;
    }
}
package com.connection.client.model;


import java.util.Date;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Builder
@EqualsAndHashCode
public class ClientDALM {
    protected UUID uid;
    protected Date birthDate;
    protected String email;
    protected String password;
    protected String username;
}

package com.connection.client.model;

import java.util.Date;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Builder
@EqualsAndHashCode
public class ClientDTO {
    protected UUID uid;
    protected Date birthDate;
    protected String email;
    protected String password;
    protected String username;
}
package com.connection.client.model;

import java.util.Date;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Builder
@EqualsAndHashCode
public class ClientBLM {
    protected UUID uid;
    protected Date birthDate;
    protected String email;
    protected String password;
    protected String username;
}
package com.connection.client.converter;

import org.springframework.stereotype.Component;

import com.connection.client.model.ClientBLM;
import com.connection.client.model.ClientDALM;
import com.connection.client.model.ClientDTO;

import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class ClientConverter {
    public ClientBLM toBLM(ClientDTO dto){
        return new ClientBLM(dto.getUid(), dto.getBirthDate(), dto.getEmail(), dto.getPassword(), dto.getUsername());
    }
    public ClientBLM toBLM(ClientDALM dalm){
        return new ClientBLM(dalm.getUid(), dalm.getBirthDate(), dalm.getEmail(), dalm.getPassword(), dalm.getUsername());
    }
    public ClientDTO toDTO(ClientBLM blm){
        return new ClientDTO(blm.getUid(), blm.getBirthDate(), blm.getEmail(), blm.getPassword(), blm.getUsername());
    }
    public ClientDALM toDALM(ClientBLM blm){
        return new ClientDALM(blm.getUid(), blm.getBirthDate(), blm.getEmail(), blm.getPassword(), blm.getUsername());
    }
    
}
package com.connection.client.validator;

import com.connection.client.exception.ClientValidateException;
import com.connection.client.model.ClientBLM;
import com.connection.client.model.ClientDALM;
import com.connection.client.model.ClientDTO;

import java.util.Date;
import java.util.regex.Pattern;
import java.util.UUID;

public class ClientValidator {

    private final Pattern EMAIL_PATTERN = Pattern.compile("^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+$");
    private final Pattern USERNAME_PATTERN = Pattern.compile("^[a-zA-Z0-9_]{3,20}$");
    private final Pattern PASSWORD_PATTERN = Pattern
            .compile("^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=\\S+$).{6,}$");

    public void validate(ClientDTO client) {
        if (client == null) {
            throw new ClientValidateException("null", "Client cannot be null");
        }
        try {
            validateUid(client.getUid());
            validateEmail(client.getEmail());
            validateUsername(client.getUsername());
            validatePassword(client.getPassword());
            validateBirthDate(client.getBirthDate());
        } catch (IllegalArgumentException e) {
            if (client.getUid() != null)
                throw new ClientValidateException(client.getUid().toString(), e.getMessage());
            else
                throw new ClientValidateException("null", e.getMessage());
        }
    }

    public void validate(ClientBLM client) {
        if (client == null) {
            throw new ClientValidateException("null", "Client cannot be null.");
        }
        try {
            validateUid(client.getUid());
            validateEmail(client.getEmail());
            validateUsername(client.getUsername());
            validatePassword(client.getPassword());
            validateBirthDate(client.getBirthDate());
        } catch (IllegalArgumentException e) {
            if (client.getUid() != null)
                throw new ClientValidateException(client.getUid().toString(), e.getMessage());
            else
                throw new ClientValidateException("null", e.getMessage());
        }
    }

    public void validate(ClientDALM client) {
        if (client == null) {
            throw new ClientValidateException("null", "Client cannot be null");
        }
        try {
            validateUid(client.getUid());
            validateEmail(client.getEmail());
            validateUsername(client.getUsername());
            validatePassword(client.getPassword());
            // validateBirthDate(client.getBirthDate());
        } catch (IllegalArgumentException e) {
            if (client.getUid() != null)
                throw new ClientValidateException(client.getUid().toString(), e.getMessage());
            else
                throw new ClientValidateException("null", e.getMessage());
        }

    }

    public void validateUid(UUID uid) {
        if (uid == null) {
            throw new IllegalArgumentException("Client UID cannot be null");
        }
    }

    public void validateEmail(String email) {
        if (email == null || email.trim().isEmpty()) {
            throw new IllegalArgumentException("Email cannot be empty");
        }
        if (email.length() > 255) {
            throw new IllegalArgumentException("Email too long (max 255 chars)");
        }
        // if (!EMAIL_PATTERN.matcher(email).matches()) {
        //     throw new IllegalArgumentException("Invalid email format");
        // }
    }

    public void validateUsername(String username) {
        if (username == null || username.trim().isEmpty()) {
            throw new IllegalArgumentException("Username cannot be empty");
        }
        if (username.length() < 3) {
            throw new IllegalArgumentException("Username too short (min 3 chars)");
        }
        if (username.length() > 50) {
            throw new IllegalArgumentException("Username too long (max 50 chars)");
        }
        // if (!USERNAME_PATTERN.matcher(username).matches()) {
        //     throw new IllegalArgumentException("Username can only contain letters, numbers and underscores");
        // }
    }

    public void validatePassword(String password) {
        if (password == null || password.trim().isEmpty()) {
            throw new IllegalArgumentException("Password cannot be empty");
        }
        if (password.length() < 6) {
            throw new IllegalArgumentException("Password too short (min 6 chars)");
        }
        if (password.length() > 100) {
            throw new IllegalArgumentException("Password too long (max 100 chars)");
        }
        // if (!PASSWORD_PATTERN.matcher(password).matches()) {
        //     throw new IllegalArgumentException(
        //             "Password must contain at least one digit, one lowercase and one uppercase letter");
        // }
    }

    public void validateBirthDate(Date birthDate) {
        if (birthDate != null) {
            Date now = new Date();

            // Проверка что дата рождения не в будущем
            if (birthDate.after(now)) {
                throw new IllegalArgumentException("Birth date cannot be in the future");
            }
        }
    }
}package com.connection.client.repository;

import java.util.UUID;

import com.connection.client.exception.ClientAlreadyExisistsException;
import com.connection.client.exception.ClientNotFoundException;
import com.connection.client.model.ClientBLM;

import reactor.core.publisher.Mono;

public interface ClientRepository {
    public Mono<Void> add(ClientBLM clientBLM)
            throws ClientAlreadyExisistsException;

    public Mono<ClientBLM> findByUid(UUID uuid)
            throws ClientNotFoundException;

    public Mono<ClientBLM> findByEmail(String emailString)
            throws ClientNotFoundException;

    public Mono<ClientBLM> findByUsername(String usernameString)
            throws ClientNotFoundException;

    public Mono<ClientBLM> findByEmailPassword(String emailString, String passwordString)
            throws ClientNotFoundException;

    public Mono<ClientBLM> findByUsernamePassword(String usernameString, String passwordString)
            throws ClientNotFoundException;
    
    public Mono<Void> deleteByUid(UUID uuid)
        throws ClientNotFoundException;
    
}package com.connection.client.repository;

import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import java.sql.Date;
import java.util.UUID;

import com.connection.client.converter.ClientConverter;
import com.connection.client.exception.ClientAlreadyExisistsException;
import com.connection.client.exception.ClientNotFoundException;
import com.connection.client.model.ClientBLM;
import com.connection.client.model.ClientDALM;
import com.connection.client.validator.ClientValidator;

import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

public class ClientRepositorySQLImpl implements ClientRepository {

    private static final String SELECT_CLIENT = "SELECT uid, email, birth_date, username, password";

    private static final String SELECT_CLIENT_BY_UID = SELECT_CLIENT +
            " FROM core.client WHERE uid = :uid";

    private static final String SELECT_CLIENT_BY_EMAIL = SELECT_CLIENT +
            " FROM core.client WHERE email = :email";

    private static final String SELECT_CLIENT_BY_USERNAME = SELECT_CLIENT +
            " FROM core.client WHERE username = :username";

    private static final String SELECT_CLIENT_BY_EMAIL_PASSWORD = SELECT_CLIENT +
            " FROM core.client WHERE email = :email AND password = :password";

    private static final String SELECT_CLIENT_BY_USERNAME_PASSWORD = SELECT_CLIENT +
            " FROM core.client WHERE username = :username AND password = :password";

    private static final String INSERT_CLIENT = "INSERT INTO core.client (uid, email, birth_date, username, password) "
            +
            "VALUES (:uid, :email, :birth_date, :username, :password)";

    private static final String DELETE_CLIENT_BY_UID = "DELETE FROM core.client WHERE uid = :uid";

    private final ClientConverter converter = new ClientConverter();
    private final ClientValidator validator = new ClientValidator();
    private final NamedParameterJdbcTemplate jdbcTemplate;

    private final RowMapper<ClientDALM> clientRowMapper = (rs, rowNum) -> {
        ClientDALM client = new ClientDALM();
        client.setUid(UUID.fromString(rs.getString("uid")));
        client.setEmail(rs.getString("email"));
        client.setBirthDate(rs.getDate("birth_date"));
        client.setUsername(rs.getString("username"));
        client.setPassword(rs.getString("password"));
        return client;
    };

    public ClientRepositorySQLImpl(NamedParameterJdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    public Mono<Void> add(ClientBLM clientBLM) throws ClientAlreadyExisistsException {
        return Mono.fromCallable(() -> {
            // Валидация BLM модели
            validator.validate(clientBLM);
            
            try {
                // Проверяем существование по email
                findByEmailSync(clientBLM.getEmail());
                throw new ClientAlreadyExisistsException("Client with email " + clientBLM.getEmail() + " already exists");
            } catch (ClientNotFoundException e) {
                // Клиент не найден по email - продолжаем
            }

            try {
                // Проверяем существование по username
                findByUsernameSync(clientBLM.getUsername());
                throw new ClientAlreadyExisistsException(
                        "Client with username " + clientBLM.getUsername() + " already exists");
            } catch (ClientNotFoundException e) {
                // Клиент не найден по username - продолжаем
            }

            // Конвертация BLM в DALM
            ClientDALM clientDALM = converter.toDALM(clientBLM);

            MapSqlParameterSource params = new MapSqlParameterSource();
            params.addValue("uid", clientDALM.getUid() != null ? clientDALM.getUid() : UUID.randomUUID());
            params.addValue("email", clientDALM.getEmail());
            params.addValue("birth_date",
                    clientDALM.getBirthDate() != null ? new Date(clientDALM.getBirthDate().getTime()) : null);
            params.addValue("username", clientDALM.getUsername());
            params.addValue("password", clientDALM.getPassword());

            jdbcTemplate.update(INSERT_CLIENT, params);
            return null;
        }).subscribeOn(Schedulers.boundedElastic()).then();
    }

    @Override
    public Mono<ClientBLM> findByUid(UUID uuid) throws ClientNotFoundException {
        return Mono.fromCallable(() -> {
            MapSqlParameterSource params = new MapSqlParameterSource();
            params.addValue("uid", uuid);
            try {
                ClientDALM dalClient = jdbcTemplate.queryForObject(SELECT_CLIENT_BY_UID, params, clientRowMapper);
                // Конвертация DALM в BLM
                return converter.toBLM(dalClient);
            } catch (EmptyResultDataAccessException e) {
                throw new ClientNotFoundException("Client with UID " + uuid + " not found");
            }
        }).subscribeOn(Schedulers.boundedElastic());
    }

    @Override
    public Mono<ClientBLM> findByEmail(String emailString) throws ClientNotFoundException {
        return Mono.fromCallable(() -> {
            MapSqlParameterSource params = new MapSqlParameterSource();
            params.addValue("email", emailString);
            try {
                ClientDALM dalClient = jdbcTemplate.queryForObject(SELECT_CLIENT_BY_EMAIL, params, clientRowMapper);
                // Конвертация DALM в BLM
                return converter.toBLM(dalClient);
            } catch (EmptyResultDataAccessException e) {
                throw new ClientNotFoundException("Client with email " + emailString + " not found");
            }
        }).subscribeOn(Schedulers.boundedElastic());
    }

    @Override
    public Mono<ClientBLM> findByUsername(String usernameString) throws ClientNotFoundException {
        return Mono.fromCallable(() -> {
            MapSqlParameterSource params = new MapSqlParameterSource();
            params.addValue("username", usernameString);
            try {
                ClientDALM dalClient = jdbcTemplate.queryForObject(SELECT_CLIENT_BY_USERNAME, params, clientRowMapper);
                // Конвертация DALM в BLM
                return converter.toBLM(dalClient);
            } catch (EmptyResultDataAccessException e) {
                throw new ClientNotFoundException("Client with username " + usernameString + " not found");
            }
        }).subscribeOn(Schedulers.boundedElastic());
    }

    @Override
    public Mono<ClientBLM> findByEmailPassword(String emailString, String passwordString) throws ClientNotFoundException {
        return Mono.fromCallable(() -> {
            MapSqlParameterSource params = new MapSqlParameterSource();
            params.addValue("email", emailString);
            params.addValue("password", passwordString);
            try {
                ClientDALM dalClient = jdbcTemplate.queryForObject(SELECT_CLIENT_BY_EMAIL_PASSWORD, params, clientRowMapper);
                // Конвертация DALM в BLM
                return converter.toBLM(dalClient);
            } catch (EmptyResultDataAccessException e) {
                throw new ClientNotFoundException("Client with email " + emailString + " and provided password not found");
            }
        }).subscribeOn(Schedulers.boundedElastic());
    }

    @Override
    public Mono<ClientBLM> findByUsernamePassword(String usernameString, String passwordString)
            throws ClientNotFoundException {
        return Mono.fromCallable(() -> {
            MapSqlParameterSource params = new MapSqlParameterSource();
            params.addValue("username", usernameString);
            params.addValue("password", passwordString);
            try {
                ClientDALM dalClient = jdbcTemplate.queryForObject(SELECT_CLIENT_BY_USERNAME_PASSWORD, params, clientRowMapper);
                // Конвертация DALM в BLM
                return converter.toBLM(dalClient);
            } catch (EmptyResultDataAccessException e) {
                throw new ClientNotFoundException(
                        "Client with username " + usernameString + " and provided password not found");
            }
        }).subscribeOn(Schedulers.boundedElastic());
    }

    @Override
    public Mono<Void> deleteByUid(UUID uuid) throws ClientNotFoundException {
        return Mono.fromCallable(() -> {
            // Проверяем существование клиента перед удалением
            findByUidSync(uuid);

            MapSqlParameterSource params = new MapSqlParameterSource();
            params.addValue("uid", uuid);

            jdbcTemplate.update(DELETE_CLIENT_BY_UID, params);
            return null;
        }).subscribeOn(Schedulers.boundedElastic()).then();
    }

    // Синхронные методы для внутреннего использования
    private ClientBLM findByUidSync(UUID uuid) throws ClientNotFoundException {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", uuid);
        try {
            ClientDALM dalClient = jdbcTemplate.queryForObject(SELECT_CLIENT_BY_UID, params, clientRowMapper);
            return converter.toBLM(dalClient);
        } catch (EmptyResultDataAccessException e) {
            throw new ClientNotFoundException("Client with UID " + uuid + " not found");
        }
    }

    private ClientBLM findByEmailSync(String emailString) throws ClientNotFoundException {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("email", emailString);
        try {
            ClientDALM dalClient = jdbcTemplate.queryForObject(SELECT_CLIENT_BY_EMAIL, params, clientRowMapper);
            return converter.toBLM(dalClient);
        } catch (EmptyResultDataAccessException e) {
            throw new ClientNotFoundException("Client with email " + emailString + " not found");
        }
    }

    private ClientBLM findByUsernameSync(String usernameString) throws ClientNotFoundException {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("username", usernameString);
        try {
            ClientDALM dalClient = jdbcTemplate.queryForObject(SELECT_CLIENT_BY_USERNAME, params, clientRowMapper);
            return converter.toBLM(dalClient);
        } catch (EmptyResultDataAccessException e) {
            throw new ClientNotFoundException("Client with username " + usernameString + " not found");
        }
    }
}package com.connection.client.repository;

import io.r2dbc.spi.Connection;
import io.r2dbc.spi.ConnectionFactory;
import io.r2dbc.spi.Row;
import io.r2dbc.spi.Statement;

import com.connection.client.converter.ClientConverter;
import com.connection.client.exception.ClientAlreadyExisistsException;
import com.connection.client.exception.ClientNotFoundException;
import com.connection.client.model.ClientBLM;
import com.connection.client.model.ClientDALM;
import com.connection.client.validator.ClientValidator;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Mono;

import java.time.LocalDate;
import java.time.ZoneId;
import java.util.Date;
import java.util.UUID;

@Slf4j
@RequiredArgsConstructor
public class ClientReactiveRepositoryImpl implements ClientRepository {

    private final ConnectionFactory clientConnectionFactory;
    private final ClientConverter converter;
    private final ClientValidator validator = new ClientValidator();

    private static final String SELECT_CLIENT = "SELECT uid, email, birth_date, username, password";
    private static final String SELECT_CLIENT_BY_UID = SELECT_CLIENT +
            " FROM core.client WHERE uid = $1";
    private static final String SELECT_CLIENT_BY_EMAIL = SELECT_CLIENT +
            " FROM core.client WHERE email = $1";
    private static final String SELECT_CLIENT_BY_USERNAME = SELECT_CLIENT +
            " FROM core.client WHERE username = $1";
    private static final String SELECT_CLIENT_BY_EMAIL_PASSWORD = SELECT_CLIENT +
            " FROM core.client WHERE email = $1 AND password = $2";
    private static final String SELECT_CLIENT_BY_USERNAME_PASSWORD = SELECT_CLIENT +
            " FROM core.client WHERE username = $1 AND password = $2";
    private static final String INSERT_CLIENT = "INSERT INTO core.client (uid, email, birth_date, username, password) " +
            "VALUES ($1, $2, $3, $4, $5)";
    private static final String DELETE_CLIENT_BY_UID = "DELETE FROM core.client WHERE uid = $1";

    @Override
    public Mono<Void> add(ClientBLM clientBLM) {
        log.info("Attempting to add new client with email: {} and username: {}", 
                clientBLM.getEmail(), clientBLM.getUsername());
        
        validator.validate(clientBLM);
        ClientDALM clientDALM = converter.toDALM(clientBLM);
        
        return Mono.usingWhen(
                clientConnectionFactory.create(),
                connection -> {
                    log.debug("Starting transaction for client addition");
                    return Mono.from(connection.beginTransaction())
                            .then(Mono.defer(() -> {
                                log.trace("Checking client existence by email: {}", clientDALM.getEmail());
                                return checkClientExistsByEmail(connection, clientDALM.getEmail());
                            }))
                            .filter(exists -> !exists)
                            .switchIfEmpty(Mono.defer(() -> {
                                log.warn("Client with email {} already exists", clientDALM.getEmail());
                                return Mono.error(new ClientAlreadyExisistsException("Email already exists"));
                            }))
                            .then(Mono.defer(() -> {
                                log.trace("Checking client existence by username: {}", clientDALM.getUsername());
                                return checkClientExistsByUsername(connection, clientDALM.getUsername());
                            }))
                            .filter(exists -> !exists)
                            .switchIfEmpty(Mono.defer(() -> {
                                log.warn("Client with username {} already exists", clientDALM.getUsername());
                                return Mono.error(new ClientAlreadyExisistsException("Username already exists"));
                            }))
                            .then(Mono.defer(() -> {
                                log.debug("Proceeding with client insertion");
                                return insertClient(connection, clientDALM);
                            }))
                            .then(Mono.defer(() -> {
                                log.debug("Committing transaction");
                                return Mono.from(connection.commitTransaction());
                            }))
                            .onErrorResume(error -> {
                                log.error("Error during client addition with email: {} - {}. Rolling back transaction.", 
                                        clientDALM.getEmail(), error.getMessage());
                                return Mono.from(connection.rollbackTransaction())
                                        .then(Mono.error(error));
                            })
                            .doOnSuccess(v -> log.info("Successfully added client with UID: {}, email: {}", 
                                    clientDALM.getUid(), clientDALM.getEmail()));
                },
                Connection::close,
                (connection, error) -> {
                    log.error("Async error cleanup for client addition: {}", error.getMessage());
                    return Mono.from(connection.close());
                },
                Connection::close
        );
    }

    @Override
    public Mono<ClientBLM> findByUid(UUID uuid) throws ClientNotFoundException {
        log.debug("Searching for client by UID: {}", uuid);
        
        return Mono.usingWhen(
                clientConnectionFactory.create(),
                connection -> findClientByQuery(connection, SELECT_CLIENT_BY_UID, uuid)
                        .doOnSuccess(client -> log.debug("Found client by UID: {}", uuid))
                        .doOnError(error -> log.warn("Client not found by UID: {} - {}", uuid, error.getMessage())),
                Connection::close,
                (connection, error) -> Mono.from(connection.close()),
                Connection::close
        );
    }

    @Override
    public Mono<ClientBLM> findByEmail(String emailString) throws ClientNotFoundException {
        log.debug("Searching for client by email: {}", emailString);
        
        return Mono.usingWhen(
                clientConnectionFactory.create(),
                connection -> findClientByQuery(connection, SELECT_CLIENT_BY_EMAIL, emailString)
                        .doOnSuccess(client -> log.debug("Found client by email: {}", emailString))
                        .doOnError(error -> log.warn("Client not found by email: {} - {}", emailString, error.getMessage())),
                Connection::close,
                (connection, error) -> Mono.from(connection.close()),
                Connection::close
        );
    }

    @Override
    public Mono<ClientBLM> findByUsername(String usernameString) throws ClientNotFoundException {
        log.debug("Searching for client by username: {}", usernameString);
        
        return Mono.usingWhen(
                clientConnectionFactory.create(),
                connection -> findClientByQuery(connection, SELECT_CLIENT_BY_USERNAME, usernameString)
                        .doOnSuccess(client -> log.debug("Found client by username: {}", usernameString))
                        .doOnError(error -> log.warn("Client not found by username: {} - {}", usernameString, error.getMessage())),
                Connection::close,
                (connection, error) -> Mono.from(connection.close()),
                Connection::close
        );
    }

    @Override
    public Mono<ClientBLM> findByEmailPassword(String emailString, String passwordString)
            throws ClientNotFoundException {
        log.debug("Attempting authentication by email: {}", emailString);
        
        return Mono.usingWhen(
                clientConnectionFactory.create(),
                connection -> {
                    return Mono.from(connection.createStatement(SELECT_CLIENT_BY_EMAIL_PASSWORD)
                            .bind("$1", emailString)
                            .bind("$2", passwordString)
                            .execute())
                            .flatMap(result -> Mono.from(result.map((row, metadata) -> mapRowToClientDALM(row))))
                            .map(converter::toBLM)
                            .doOnSuccess(client -> log.info("Successful authentication by email: {}", emailString))
                            .doOnError(error -> log.warn("Failed authentication by email: {} - {}", emailString, error.getMessage()))
                            .switchIfEmpty(Mono.error(new ClientNotFoundException(
                                    "Client with email " + emailString + " and provided password not found")));
                },
                Connection::close,
                (connection, error) -> Mono.from(connection.close()),
                Connection::close
        );
    }

    @Override
    public Mono<ClientBLM> findByUsernamePassword(String usernameString, String passwordString)
            throws ClientNotFoundException {
        log.debug("Attempting authentication by username: {}", usernameString);
        
        return Mono.usingWhen(
                clientConnectionFactory.create(),
                connection -> {
                    return Mono.from(connection.createStatement(SELECT_CLIENT_BY_USERNAME_PASSWORD)
                            .bind("$1", usernameString)
                            .bind("$2", passwordString)
                            .execute())
                            .flatMap(result -> Mono.from(result.map((row, metadata) -> mapRowToClientDALM(row))))
                            .map(converter::toBLM)
                            .doOnSuccess(client -> log.info("Successful authentication by username: {}", usernameString))
                            .doOnError(error -> log.warn("Failed authentication by username: {} - {}", usernameString, error.getMessage()))
                            .switchIfEmpty(Mono.error(new ClientNotFoundException(
                                    "Client with username " + usernameString + " and provided password not found")));
                },
                Connection::close,
                (connection, error) -> Mono.from(connection.close()),
                Connection::close
        );
    }

    @Override
    public Mono<Void> deleteByUid(UUID uuid) throws ClientNotFoundException {
        log.info("Attempting to delete client by UID: {}", uuid);
        
        return findByUid(uuid)
                .flatMap(client -> Mono.usingWhen(
                        clientConnectionFactory.create(),
                        connection -> {
                            log.debug("Starting transaction for client deletion");
                            return Mono.from(connection.beginTransaction())
                                    .then(Mono.from(connection.createStatement(DELETE_CLIENT_BY_UID)
                                            .bind("$1", uuid)
                                            .execute()))
                                    .flatMap(result -> Mono.from(result.getRowsUpdated()))
                                    .doOnNext(rows -> log.debug("Deleted {} rows for UID: {}", rows, uuid))
                                    .then(Mono.from(connection.commitTransaction()))
                                    .onErrorResume(error -> {
                                        log.error("Error during client deletion for UID: {} - {}. Rolling back transaction.", 
                                                uuid, error.getMessage());
                                        return Mono.from(connection.rollbackTransaction())
                                                .then(Mono.error(error));
                                    })
                                    .doOnSuccess(v -> log.info("Successfully deleted client with UID: {}", uuid));
                        },
                        Connection::close,
                        (connection, error) -> {
                            log.error("Async error cleanup for client deletion: {}", error.getMessage());
                            return Mono.from(connection.close());
                        },
                        Connection::close
                ))
                .doOnError(error -> log.warn("Cannot delete client - client not found by UID: {}", uuid));
    }

    private Mono<Boolean> checkClientExistsByEmail(Connection connection, String email) {
        log.trace("Checking if client exists by email: {}", email);
        
        String sql = "SELECT COUNT(*) as count FROM core.client WHERE email = $1";

        return Mono.from(connection.createStatement(sql)
                .bind("$1", email)
                .execute())
                .flatMap(result -> Mono.from(result.map((row, metadata) -> row.get("count", Long.class))))
                .map(count -> count > 0)
                .defaultIfEmpty(false)
                .doOnNext(exists -> log.trace("Client existence check by email {}: {}", email, exists));
    }

    private Mono<Boolean> checkClientExistsByUsername(Connection connection, String username) {
        log.trace("Checking if client exists by username: {}", username);
        
        String sql = "SELECT COUNT(*) as count FROM core.client WHERE username = $1";

        return Mono.from(connection.createStatement(sql)
                .bind("$1", username)
                .execute())
                .flatMap(result -> Mono.from(result.map((row, metadata) -> row.get("count", Long.class))))
                .map(count -> count > 0)
                .defaultIfEmpty(false)
                .doOnNext(exists -> log.trace("Client existence check by username {}: {}", username, exists));
    }

    private Mono<Void> insertClient(Connection connection, ClientDALM clientDALM) {
        UUID uid = clientDALM.getUid() != null ? clientDALM.getUid() : UUID.randomUUID();
        clientDALM.setUid(uid);
        
        log.debug("Inserting new client with UID: {}, email: {}", uid, clientDALM.getEmail());

        Statement stmt = connection.createStatement(INSERT_CLIENT)
                .bind("$1", uid)
                .bind("$2", clientDALM.getEmail())
                .bind("$3",
                        clientDALM.getBirthDate() != null
                                ? clientDALM.getBirthDate().toInstant().atZone(ZoneId.systemDefault()).toLocalDate()
                                : null)
                .bind("$4", clientDALM.getUsername())
                .bind("$5", clientDALM.getPassword());

        return Mono.from(stmt.execute())
                .flatMap(result -> Mono.from(result.getRowsUpdated()))
                .doOnNext(rowsUpdated -> log.debug("Insert executed, rows affected: {}", rowsUpdated))
                .then()
                .doOnSuccess(v -> log.info("Client inserted successfully with UID: {}", uid))
                .doOnError(error -> log.error("Failed to insert client with UID: {} - {}", uid, error.getMessage()));
    }

    private Mono<ClientBLM> findClientByQuery(Connection connection, String sql, Object value) {
        log.trace("Executing query: {} with value: {}", sql, value);
        
        return Mono.from(connection.createStatement(sql)
                .bind("$1", value)
                .execute())
                .flatMap(result -> Mono.from(result.map((row, metadata) -> mapRowToClientDALM(row))))
                .map(converter::toBLM)
                .doOnNext(client -> log.trace("Query executed successfully: {}", sql))
                .doOnError(error -> log.trace("Query failed: {} - {}", sql, error.getMessage()))
                .switchIfEmpty(Mono.error(new ClientNotFoundException(
                        "Client not found for query: " + sql + " with value: " + value)));
    }

    private ClientDALM mapRowToClientDALM(Row row) {
        log.trace("Mapping row to ClientDALM");
        
        LocalDate birthDateLocal = row.get("birth_date", LocalDate.class);
        Date birthDate = birthDateLocal != null
                ? Date.from(birthDateLocal.atStartOfDay(ZoneId.systemDefault()).toInstant())
                : null;

        return ClientDALM.builder()
                .uid(row.get("uid", UUID.class))
                .email(row.get("email", String.class))
                .birthDate(birthDate)
                .username(row.get("username", String.class))
                .password(row.get("password", String.class))
                .build();
    }

    // Метод для проверки соединения с БД
    public Mono<Boolean> testConnection() {
        return Mono.usingWhen(
                clientConnectionFactory.create(),
                connection -> {
                    log.info("Testing database connection");
                    return Mono.from(connection.createStatement("SELECT 1").execute())
                            .flatMap(result -> Mono.from(result.map((row, metadata) -> true)))
                            .doOnSuccess(v -> log.info("Database connection test successful"))
                            .doOnError(error -> log.error("Database connection test failed: {}", error.getMessage()));
                },
                Connection::close,
                (connection, error) -> Mono.from(connection.close()),
                Connection::close
        );
    }
}package com.connection.client.mother;

import java.util.Date;
import java.util.UUID;

import com.connection.client.model.ClientBLM;
import com.connection.client.model.ClientDALM;
import com.connection.client.model.ClientDTO;

public class ClientObjectMother {

    private static final UUID DEFAULT_UID = UUID.fromString("123e4567-e89b-12d3-a456-426614174000");
    private static final Date DEFAULT_BIRTH_DATE = new Date(
            System.currentTimeMillis() - 25L * 365 * 24 * 60 * 60 * 1000);
    private static final String DEFAULT_EMAIL = "test@example.com";
    private static final String DEFAULT_PASSWORD = "Password123";
    private static final String DEFAULT_USERNAME = "testuser";

    public static ClientDTO createValidClientDTO() {
        return ClientDTO.builder()
                .uid(DEFAULT_UID)
                .birthDate(DEFAULT_BIRTH_DATE)
                .email(DEFAULT_EMAIL)
                .password(DEFAULT_PASSWORD)
                .username(DEFAULT_USERNAME)
                .build();
    }

    public static ClientBLM createValidClientBLM() {
        return ClientBLM.builder()
                .uid(DEFAULT_UID)
                .birthDate(DEFAULT_BIRTH_DATE)
                .email(DEFAULT_EMAIL)
                .password(DEFAULT_PASSWORD)
                .username(DEFAULT_USERNAME)
                .build();
    }

    public static ClientDALM createValidClientDALM() {
        return ClientDALM.builder()
                .uid(DEFAULT_UID)
                .birthDate(DEFAULT_BIRTH_DATE)
                .email(DEFAULT_EMAIL)
                .password(DEFAULT_PASSWORD)
                .username(DEFAULT_USERNAME)
                .build();
    }

    public static ClientDTO createClientDTOWithInvalidEmail() {
        return ClientDTO.builder()
                .uid(DEFAULT_UID)
                .birthDate(DEFAULT_BIRTH_DATE)
                .email("invalid-email")
                .password(DEFAULT_PASSWORD)
                .username(DEFAULT_USERNAME)
                .build();
    }

    public static ClientDTO createClientDTOWithShortPassword() {
        return ClientDTO.builder()
                .uid(DEFAULT_UID)
                .birthDate(DEFAULT_BIRTH_DATE)
                .email(DEFAULT_EMAIL)
                .password("short")
                .username(DEFAULT_USERNAME)
                .build();
    }

    public static ClientDTO createClientDTOWithInvalidUsername() {
        return ClientDTO.builder()
                .uid(DEFAULT_UID)
                .birthDate(DEFAULT_BIRTH_DATE)
                .email(DEFAULT_EMAIL)
                .password(DEFAULT_PASSWORD)
                .username("ab")
                .build();
    }

    public static ClientDTO createClientDTOWithFutureBirthDate() {
        return ClientDTO.builder()
                .uid(DEFAULT_UID)
                .birthDate(new Date(System.currentTimeMillis() + 365L * 24 * 60 * 60 * 1000))
                .email(DEFAULT_EMAIL)
                .password(DEFAULT_PASSWORD)
                .username(DEFAULT_USERNAME)
                .build();
    }

    public static ClientBLM createClientBLMWithNullFields() {
        return ClientBLM.builder()
                .uid(null)
                .birthDate(null)
                .email(null)
                .password(null)
                .username(null)
                .build();
    }

    public static ClientDALM createClientForEmail(String email) {
        return ClientDALM.builder()
                .uid(UUID.randomUUID())
                .birthDate(DEFAULT_BIRTH_DATE)
                .email(email)
                .password(DEFAULT_PASSWORD)
                .username("user_" + email.split("@")[0])
                .build();
    }

    public static ClientDALM createClientForUsername(String username) {
        return ClientDALM.builder()
                .uid(UUID.randomUUID())
                .birthDate(DEFAULT_BIRTH_DATE)
                .email(username + "@example.com")
                .password(DEFAULT_PASSWORD)
                .username(username)
                .build();
    }
}