package com.connection.token.exception;

public class AccessTokenValidateException extends BaseTokenException{
    String descriptionString;
    public AccessTokenValidateException(String tokenString, String description){
        super(tokenString);
        this.descriptionString = description;
    }

    public String toString(){
        String res = super.toString();
        res += "\n" + "description: Access token is invalid";
        res += "\n" + descriptionString;
        return res;
    }
}
package com.connection.token.exception;

public class RefreshTokenAddException extends BaseTokenException{
    public RefreshTokenAddException(String tokenString){
        super(tokenString);
    }

    public String toString(){
        String res = super.toString();
        res += "\n" + "description: cannot add refresh token";
        return res;
    }
}
package com.connection.token.exception;

public class RefreshTokenNotFoundException extends BaseTokenException {
    public RefreshTokenNotFoundException(String tokenString) {
        super(tokenString);
    }

    public String toString() {
        String res = super.toString();
        res += "\n" + "description: refresh token not found";
        return res;
    }
}
package com.connection.token.exception;

public class RefreshTokenExpiredException extends BaseTokenException {
    public RefreshTokenExpiredException(String tokenString) {
        super(tokenString);
    }

    public String toString() {
        String res = super.toString();
        res += "\n" + "description: refresh token is expired";
        return res;
    }
}
package com.connection.token.exception;

public class RefreshTokenValidateException extends BaseTokenException{
    String descriptionString;
    public RefreshTokenValidateException(String tokenString, String description){
        super(tokenString);
        this.descriptionString = description;
    }

    public String toString(){
        String res = super.toString();
        res += "\n" + "description: refresh token is invalid";
        res += "\n" + descriptionString;
        return res;
    }
}
package com.connection.token.exception;

public class BaseTokenException extends RuntimeException{
    private final String tokenString;

    public BaseTokenException(String tokenDescription){
        super("token");
        tokenString = tokenDescription;
    }

    public String toString(){
        String res = super.toString();
        res += "\n" + "token: " + tokenString;
        return res;
    }
}
package com.connection.token.exception;

public class RefreshTokenAlreadyExisistsException extends BaseTokenException{
    private final String descriptionString = "refresh token already exists";
    public RefreshTokenAlreadyExisistsException(String tokenString){
        super(tokenString);
    }

    public String toString(){
        String res = super.toString();
        res += "\n" + "description: " + descriptionString;
        return res;
    }
}
package com.connection.token.generator;

import java.util.Date;
import java.util.UUID;

import javax.crypto.SecretKey;

import com.connection.token.exception.AccessTokenValidateException;
import com.connection.token.model.AccessTokenBLM;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import io.jsonwebtoken.Jwts;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class AccessTokenGenerator {
    @NonNull
    private final SecretKey jwtSecretKey;

    @NonNull
    private final String appNameString;

    @NonNull
    private final String jwtSubjecString;

    public String generateAccessToken(UUID clientUuid, Date createdAtDate, Date expiresAtDate) {
        String token = Jwts.builder()
                .issuer(appNameString)
                .subject(jwtSubjecString)
                .claim("clientUid", clientUuid.toString())
                .issuedAt(createdAtDate)
                .expiration(expiresAtDate)
                .signWith(jwtSecretKey)
                .compact();
        return token;
    }

    public AccessTokenBLM getAccessTokenBLM(String token) {
        try{
        Jws<Claims> jws = Jwts.parser()
                .verifyWith(jwtSecretKey)
                .build()
                .parseSignedClaims(token);

        Claims claims = jws.getPayload();

        UUID clientUid = UUID.fromString(claims.get("clientUid", String.class));
        Date issuedAt = claims.getIssuedAt();
        Date expiration = claims.getExpiration();

        if (!jwtSubjecString.equals(claims.getSubject())) {
            throw new RuntimeException("Invalid token subject");
        }

        return new AccessTokenBLM(token, clientUid, issuedAt, expiration);
    }
    catch (RuntimeException e){
        throw new AccessTokenValidateException(token, "Invalid jwt");
    }
    }
}
package com.connection.token.generator;

import java.util.Date;
import java.util.UUID;

import javax.crypto.SecretKey;

import com.connection.token.exception.RefreshTokenValidateException;
import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDALM;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import io.jsonwebtoken.Jwts;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class RefreshTokenGenerator {
    @NonNull
    private final SecretKey jwtSecretKey;

    @NonNull
    private final String appNameString;

    @NonNull
    private final String jwtSubjecString;

    public String generateRefreshToken(RefreshTokenDALM dalm) {
        String token = Jwts.builder()
                .issuer(appNameString)
                .subject(jwtSubjecString)
                .claim("uid", dalm.getUid().toString())
                .claim("clientUid", dalm.getClientUID().toString())
                .issuedAt(dalm.getCreatedAt())
                .expiration(dalm.getExpiresAt())
                .signWith(jwtSecretKey)
                .compact();
        return token;
    }

    public String generateRefreshToken(UUID uid, UUID clientUuid, Date createdAt, Date expiresAt) {
        String token = Jwts.builder()
                .issuer(appNameString)
                .subject(jwtSubjecString)
                .claim("uid", uid.toString())
                .claim("clientUid", clientUuid.toString())
                .issuedAt(createdAt)
                .expiration(expiresAt)
                .signWith(jwtSecretKey)
                .compact();
        return token;
    }

    public RefreshTokenBLM getRefreshToken(String token) {
        try{
        Jws<Claims> jws = Jwts.parser()
                .verifyWith(jwtSecretKey)
                .build()
                .parseSignedClaims(token);

        Claims claims = jws.getPayload();

        UUID uid = UUID.fromString(claims.get("uid", String.class));
        UUID clientUid = UUID.fromString(claims.get("clientUid", String.class));
        Date issuedAt = claims.getIssuedAt();
        Date expiration = claims.getExpiration();

        if (!jwtSubjecString.equals(claims.getSubject())) {
            throw new RuntimeException("Invalid token subject");
        }

        return new RefreshTokenBLM(token, uid, clientUid, issuedAt, expiration);
    }
    catch (RuntimeException e){
        throw new RefreshTokenValidateException(token, "Invalid jwt");
    }
    }
}
package com.connection.token.model;

import java.util.Date;
import java.util.UUID;

import jakarta.persistence.Entity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Builder
@EqualsAndHashCode
public class RefreshTokenBLM {
    protected String token;
    protected UUID uid;
    protected UUID clientUID;
    
    protected Date createdAt;
    protected Date expiresAt;
}
package com.connection.token.model;

import java.util.Date;
import java.util.UUID;

import jakarta.persistence.Entity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Builder
@EqualsAndHashCode
public class RefreshTokenDALM {
    protected String token;

    
    protected UUID uid;
    
    protected UUID clientUID;
    
    protected Date createdAt;
    
    protected Date expiresAt;
}
package com.connection.token.model;
import jakarta.persistence.Entity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Builder
@EqualsAndHashCode
public class AccessTokenDTO {
    protected String token;
}
package com.connection.token.model;

import jakarta.persistence.Entity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Builder
@EqualsAndHashCode
public class RefreshTokenDTO {
    protected String token;
}
package com.connection.token.model;

import java.util.Date;
import java.util.UUID;

import jakarta.persistence.Entity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Builder
@EqualsAndHashCode
public class AccessTokenBLM {
    protected String token;
    protected UUID clientUID;
    protected Date createdAt;
    protected Date expiresAt;
}
package com.connection.token.model;

import java.util.Date;
import java.util.UUID;

import jakarta.persistence.Entity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Builder
@EqualsAndHashCode
public class AccessTokenDALM {
    protected UUID clientUID;
    protected Date createdAt;
    protected Date expiresAt;
}
package com.connection.token.converter;

import com.connection.token.generator.RefreshTokenGenerator;
import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDALM;
import com.connection.token.model.RefreshTokenDTO;

import io.jsonwebtoken.JwtException;
import jakarta.annotation.Nonnull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class RefreshTokenConverter {
    @Nonnull
    private final RefreshTokenGenerator tokenGenerator;
    public RefreshTokenBLM toBLM(RefreshTokenDALM dalm) {
        String token  = tokenGenerator.generateRefreshToken(dalm);
        return new RefreshTokenBLM(token,
                dalm.getUid(),
                dalm.getClientUID(),
                dalm.getCreatedAt(),
                dalm.getExpiresAt());
    }

    public RefreshTokenBLM toBLM(RefreshTokenDTO dto) {
        try {
            RefreshTokenBLM tokenBLM = tokenGenerator.getRefreshToken(dto.getToken());
            return tokenBLM;
        } catch (JwtException e) {
            throw new RuntimeException("Invalid JWT token: " + e.getMessage(), e);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException("Malformed JWT token", e);
        }
    }

    public RefreshTokenDTO toDTO(RefreshTokenBLM blm){
        return new RefreshTokenDTO(blm.getToken());
    }

    public RefreshTokenDALM toDALM(RefreshTokenBLM blm){
        return new RefreshTokenDALM(blm.getToken(), 
                                    blm.getUid(),
                                    blm.getClientUID(), 
                                    blm.getCreatedAt(), 
                                    blm.getExpiresAt());
    }
}

package com.connection.token.converter;

import com.connection.token.generator.AccessTokenGenerator;
import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.AccessTokenDALM;
import com.connection.token.model.AccessTokenDTO;

import io.jsonwebtoken.JwtException;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class AccessTokenConverter {
    @NonNull
    private final AccessTokenGenerator accessTokenGenerator;

    public AccessTokenBLM toBLM(AccessTokenDALM dalm) {
        try {
            String token = accessTokenGenerator.generateAccessToken(dalm.getClientUID(), dalm.getCreatedAt(),
                    dalm.getExpiresAt());
            return new AccessTokenBLM(token,
                    dalm.getClientUID(),
                    dalm.getCreatedAt(),
                    dalm.getExpiresAt());
        } catch (JwtException e) {
            throw new RuntimeException("Invalid JWT token: " + e.getMessage(), e);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException("Malformed JWT token", e);
        }
    }

    public AccessTokenBLM toBLM(AccessTokenDTO dto) {
        try {
            AccessTokenBLM blm = accessTokenGenerator.getAccessTokenBLM(dto.getToken());
            return blm;
        } catch (JwtException e) {
            throw new RuntimeException("Invalid JWT token: " + e.getMessage(), e);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException("Malformed JWT token", e);
        }
    }

    public AccessTokenDTO toDTO(AccessTokenBLM blm) {
        return new AccessTokenDTO(blm.getToken());
    }

    public AccessTokenDALM toDALM(AccessTokenBLM blm) {
        return new AccessTokenDALM(blm.getClientUID(), blm.getCreatedAt(), blm.getExpiresAt());
    }
}
package com.connection.token.validator;

import java.util.Date;
import java.util.UUID;

import com.connection.token.exception.RefreshTokenValidateException;
import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDALM;
import com.connection.token.model.RefreshTokenDTO;

public class RefreshTokenValidator {
    public void validate(RefreshTokenDTO refreshToken) {
        if (refreshToken == null) {
            throw new RefreshTokenValidateException("null", "Refresh token is null");
        }
        try {
            validateToken(refreshToken.getToken());
        } catch (IllegalArgumentException e) {
            throw new RefreshTokenValidateException("refreshToken", e.getMessage());
        }
    }

    public void validate(RefreshTokenBLM refreshToken) {
        if (refreshToken == null) {
            throw new RefreshTokenValidateException("null", "Refresh token is null");
        }
        try {
            validateToken(refreshToken.getToken());
            validateUID(refreshToken.getUid());
            validateClientUID(refreshToken.getClientUID());
            validateCreatedAt(refreshToken.getCreatedAt());
            validateExpiresAt(refreshToken.getExpiresAt());
        } catch (IllegalArgumentException e) {
            if (refreshToken.getUid() != null)
                throw new RefreshTokenValidateException(refreshToken.getUid().toString(), e.getMessage());
            else
                throw new RefreshTokenValidateException("null", e.getMessage());
        }
    }

    public void validate(RefreshTokenDALM refreshToken) {
        if (refreshToken == null) {
            throw new RefreshTokenValidateException("null", "Refresh token is null");
        }
        try {
            validateUID(refreshToken.getUid());
            validateClientUID(refreshToken.getClientUID());
            validateCreatedAt(refreshToken.getCreatedAt());
            validateExpiresAt(refreshToken.getExpiresAt());
        } catch (IllegalArgumentException e) {
            if (refreshToken.getUid() != null)
                throw new RefreshTokenValidateException(refreshToken.getUid().toString(), e.getMessage());
            else
                throw new RefreshTokenValidateException("null", e.getMessage());
        }
    }

    private void validateToken(String token) {
        if (token == null || token.trim().isEmpty()) {
            throw new IllegalArgumentException("Token cannot be empty");
        }
    }

    private void validateUID(UUID UID) {
        if (UID == null) {
            throw new IllegalArgumentException("UID cannot be null");
        }
    }

    private void validateClientUID(UUID clientUID) {
        if (clientUID == null) {
            throw new IllegalArgumentException("Client UID cannot be null");
        }
    }

    private void validateCreatedAt(Date createdAt) {
        if (createdAt == null) {
            throw new IllegalArgumentException("Creation date cannot be null");
        }

        Date now = new Date();
        if (createdAt.after(now)) {
            throw new IllegalArgumentException("Creation date cannot be in the future");
        }
    }

    private void validateExpiresAt(Date expiresAt) {
        if (expiresAt == null) {
            throw new IllegalArgumentException("Expiration date cannot be null");
        }

        Date now = new Date();
        if (expiresAt.before(now)) {
            throw new IllegalArgumentException("Token has already expired");
        }
    }

}
package com.connection.token.validator;

import java.util.Date;
import java.util.UUID;

import com.connection.token.exception.AccessTokenValidateException;
import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.AccessTokenDALM;
import com.connection.token.model.AccessTokenDTO;

public class AccessTokenValidator {
    public void validate(AccessTokenDTO accessToken) {
        if (accessToken == null) {
            throw new AccessTokenValidateException("null", "Access token is null");
        }
        try {
            validateToken(accessToken.getToken());
        } catch (IllegalArgumentException e) {
            throw new AccessTokenValidateException("accessToken", e.getMessage());
        }
    }

    public void validate(AccessTokenBLM accessToken) {
        if (accessToken == null) {
            throw new AccessTokenValidateException("null", "Access token is null");
        }
        try {
            validateToken(accessToken.getToken());
            validateClientUID(accessToken.getClientUID());
            validateCreatedAt(accessToken.getCreatedAt());
            validateExpiresAt(accessToken.getExpiresAt());
        } catch (IllegalArgumentException e) {
            throw new AccessTokenValidateException("accessToken", e.getMessage());
        }
    }

    public void validate(AccessTokenDALM accessToken) {
        if (accessToken == null) {
            throw new AccessTokenValidateException("null", "Access token is null");
        }
        try {
            validateClientUID(accessToken.getClientUID());
            validateCreatedAt(accessToken.getCreatedAt());
            validateExpiresAt(accessToken.getExpiresAt());
        } catch (IllegalArgumentException e) {
            throw new AccessTokenValidateException("accessToken", e.getMessage());
        }
    }

    private void validateToken(String token) {
        if (token == null || token.trim().isEmpty()) {
            throw new IllegalArgumentException("Token cannot be empty");
        }
    }

    private void validateClientUID(UUID clientUID) {
        if (clientUID == null) {
            throw new IllegalArgumentException("Client UID cannot be null");
        }
    }

    private void validateCreatedAt(Date createdAt) {
        if (createdAt == null) {
            throw new IllegalArgumentException("Creation date cannot be null");
        }

        Date now = new Date();
        if (createdAt.after(now)) {
            throw new IllegalArgumentException("Creation date cannot be in the future");
        }
    }

    private void validateExpiresAt(Date expiresAt) {
        if (expiresAt == null) {
            throw new IllegalArgumentException("Expiration date cannot be null");
        }

        Date now = new Date();
        if (expiresAt.before(now)) {
            throw new IllegalArgumentException("Token has already expired");
        }
    }

}
package com.connection.token.repository;

import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import java.sql.Timestamp;
import java.util.Date;
import java.util.UUID;

import com.connection.token.exception.RefreshTokenAlreadyExisistsException;
import com.connection.token.exception.RefreshTokenNotFoundException;
import com.connection.token.model.RefreshTokenDALM;

import reactor.core.publisher.Mono;
import reactor.core.scheduler.Schedulers;

public class RefreshTokenRepositorySQLImpl implements RefreshTokenRepository {

    private static final String SELECT_REFRESH_TOKEN = "SELECT uid, client_id, token, created_at, expires_at";
    private static final String FROM_REFRESH_TOKEN = " FROM \"access\".refresh_token";

    private static final String SELECT_TOKEN_BY_UID = SELECT_REFRESH_TOKEN + FROM_REFRESH_TOKEN + " WHERE uid = :uid";
    private static final String SELECT_TOKEN_BY_TOKEN = SELECT_REFRESH_TOKEN + FROM_REFRESH_TOKEN + " WHERE token = :token";

    private static final String INSERT_REFRESH_TOKEN = "INSERT INTO \"access\".refresh_token (uid, client_id, token, created_at, expires_at) " +
            "VALUES (:uid, :client_id, :token, :created_at, :expires_at)";

    private static final String UPDATE_TOKEN = "UPDATE \"access\".refresh_token SET token = :new_token, expires_at = :new_expires_at, created_at = :new_created_at " +
            "WHERE token = :old_token";

    private static final String REVOKE_TOKEN = "DELETE FROM \"access\".refresh_token WHERE uid = :uid";
    private static final String REVOKE_ALL_CLIENT_TOKENS = "DELETE FROM \"access\".refresh_token WHERE client_id = :client_id";
    private static final String CLEANUP_EXPIRED_TOKENS = "DELETE FROM \"access\".refresh_token WHERE expires_at < NOW()";

    private final NamedParameterJdbcTemplate jdbcTemplate;

    private final RowMapper<RefreshTokenDALM> refreshTokenRowMapper = (rs, rowNum) -> {
        RefreshTokenDALM token = new RefreshTokenDALM();
        token.setUid(UUID.fromString(rs.getString("uid")));
        token.setClientUID(UUID.fromString(rs.getString("client_id")));
        token.setToken(rs.getString("token"));
        token.setCreatedAt(rs.getTimestamp("created_at"));
        token.setExpiresAt(rs.getTimestamp("expires_at"));
        return token;
    };

    public RefreshTokenRepositorySQLImpl(NamedParameterJdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    public Mono<Void> add(RefreshTokenDALM refreshTokenDALM) throws RefreshTokenAlreadyExisistsException {
        return Mono.fromCallable(() -> {
            // Проверяем существование по token
            if (tokenExistsSync(refreshTokenDALM.getToken())) {
                throw new RefreshTokenAlreadyExisistsException("Refresh token already exists");
            }

            // Проверяем существование по uid
            if (uidExistsSync(refreshTokenDALM.getUid())) {
                throw new RefreshTokenAlreadyExisistsException("Refresh token with UID " + refreshTokenDALM.getUid() + " already exists");
            }

            MapSqlParameterSource params = new MapSqlParameterSource();
            params.addValue("uid", refreshTokenDALM.getUid());
            params.addValue("client_id", refreshTokenDALM.getClientUID());
            params.addValue("token", refreshTokenDALM.getToken());
            params.addValue("created_at", new Timestamp(refreshTokenDALM.getCreatedAt().getTime()));
            params.addValue("expires_at", new Timestamp(refreshTokenDALM.getExpiresAt().getTime()));

            jdbcTemplate.update(INSERT_REFRESH_TOKEN, params);
            return null;
        }).subscribeOn(Schedulers.boundedElastic()).then();
    }

    @Override
    public Mono<Void> updateToken(RefreshTokenDALM refreshTokenDALM, RefreshTokenDALM newRefreshTokenDALM) 
            throws RefreshTokenNotFoundException {
        return Mono.fromCallable(() -> {
            // Проверяем существование старого токена
            if (!tokenExistsSync(refreshTokenDALM.getToken())) {
                throw new RefreshTokenNotFoundException("Refresh token not found");
            }

            // Проверяем что новый токен не существует
            if (tokenExistsSync(newRefreshTokenDALM.getToken())) {
                throw new RefreshTokenAlreadyExisistsException("Refresh token already exists");
            }

            MapSqlParameterSource params = new MapSqlParameterSource();
            params.addValue("old_token", refreshTokenDALM.getToken());
            params.addValue("new_token", newRefreshTokenDALM.getToken());
            params.addValue("new_created_at", new Timestamp(newRefreshTokenDALM.getCreatedAt().getTime()));
            params.addValue("new_expires_at", new Timestamp(newRefreshTokenDALM.getExpiresAt().getTime()));

            jdbcTemplate.update(UPDATE_TOKEN, params);
            return null;
        }).subscribeOn(Schedulers.boundedElastic()).then();
    }

    @Override
    public Mono<Void> revoke(RefreshTokenDALM refreshTokenDALM) throws RefreshTokenNotFoundException {
        return Mono.fromCallable(() -> {
            // Проверяем существование токена
            if (!uidExistsSync(refreshTokenDALM.getUid())) {
                throw new RefreshTokenNotFoundException("Refresh token with UID " + refreshTokenDALM.getUid() + " not found");
            }

            MapSqlParameterSource params = new MapSqlParameterSource();
            params.addValue("uid", refreshTokenDALM.getUid());

            jdbcTemplate.update(REVOKE_TOKEN, params);
            return null;
        }).subscribeOn(Schedulers.boundedElastic()).then();
    }

    @Override
    public Mono<Void> revokeAll(UUID clientUUID) {
        return Mono.fromCallable(() -> {
            MapSqlParameterSource params = new MapSqlParameterSource();
            params.addValue("client_id", clientUUID);

            jdbcTemplate.update(REVOKE_ALL_CLIENT_TOKENS, params);
            return null;
        }).subscribeOn(Schedulers.boundedElastic()).then();
    }

    @Override
    public Mono<Void> cleanUpExpired() {
        return Mono.fromCallable(() -> {
            jdbcTemplate.update(CLEANUP_EXPIRED_TOKENS, new MapSqlParameterSource());
            return null;
        }).subscribeOn(Schedulers.boundedElastic()).then();
    }

    // Синхронные вспомогательные методы для внутреннего использования
    private boolean uidExistsSync(UUID uid) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", uid);
        try {
            jdbcTemplate.queryForObject(SELECT_TOKEN_BY_UID, params, refreshTokenRowMapper);
            return true;
        } catch (EmptyResultDataAccessException e) {
            return false;
        }
    }

    private boolean tokenExistsSync(String token) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("token", token);
        try {
            jdbcTemplate.queryForObject(SELECT_TOKEN_BY_TOKEN, params, refreshTokenRowMapper);
            return true;
        } catch (EmptyResultDataAccessException e) {
            return false;
        }
    }

    // Дополнительные методы для внутреннего использования (синхронные)
    private RefreshTokenDALM findByUidSync(UUID uid) throws RefreshTokenNotFoundException {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", uid);
        try {
            return jdbcTemplate.queryForObject(SELECT_TOKEN_BY_UID, params, refreshTokenRowMapper);
        } catch (EmptyResultDataAccessException e) {
            throw new RefreshTokenNotFoundException("Refresh token with UID " + uid + " not found");
        }
    }

    private RefreshTokenDALM findByTokenSync(String token) throws RefreshTokenNotFoundException {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("token", token);
        try {
            return jdbcTemplate.queryForObject(SELECT_TOKEN_BY_TOKEN, params, refreshTokenRowMapper);
        } catch (EmptyResultDataAccessException e) {
            throw new RefreshTokenNotFoundException("Refresh token not found");
        }
    }

    private boolean isTokenValidSync(String token) {
        try {
            RefreshTokenDALM refreshToken = findByTokenSync(token);
            return refreshToken.getExpiresAt().after(new Date());
        } catch (RefreshTokenNotFoundException e) {
            return false;
        }
    }

    // Реактивные версии дополнительных методов (если нужны)
    public Mono<RefreshTokenDALM> findByUid(UUID uid) throws RefreshTokenNotFoundException {
        return Mono.fromCallable(() -> findByUidSync(uid))
                .subscribeOn(Schedulers.boundedElastic());
    }

    public Mono<RefreshTokenDALM> findByToken(String token) throws RefreshTokenNotFoundException {
        return Mono.fromCallable(() -> findByTokenSync(token))
                .subscribeOn(Schedulers.boundedElastic());
    }

    public Mono<Boolean> isTokenValid(String token) {
        return Mono.fromCallable(() -> isTokenValidSync(token))
                .subscribeOn(Schedulers.boundedElastic());
    }
}package com.connection.token.repository;

import java.util.UUID;

import com.connection.token.exception.RefreshTokenAlreadyExisistsException;
import com.connection.token.exception.RefreshTokenNotFoundException;
import com.connection.token.model.RefreshTokenDALM;

import reactor.core.publisher.Mono;

public interface RefreshTokenRepository {
    /**
     * Добавить новый refreshToken
     */
    Mono<Void> add(RefreshTokenDALM refreshTokenDALM) throws RefreshTokenAlreadyExisistsException;

    /**
     * Обновить токен
     */
    Mono<Void> updateToken(RefreshTokenDALM refreshTokenDALM, RefreshTokenDALM newRefreshTokenDALM)
            throws RefreshTokenNotFoundException;

    /**
     * Отозвать токен
     */
    Mono<Void> revoke(RefreshTokenDALM refreshTokenDALM) throws RefreshTokenNotFoundException;

    /**
     * Отозвать все токены клиента
     */
    Mono<Void> revokeAll(UUID clientUUID);

    /**
     * Отозвать все закончившиеся токены
     */
    Mono<Void> cleanUpExpired();
}package com.connection.token.repository;

import io.r2dbc.spi.Connection;
import io.r2dbc.spi.ConnectionFactory;
import io.r2dbc.spi.Row;
import io.r2dbc.spi.Statement;

import com.connection.token.exception.RefreshTokenAlreadyExisistsException;
import com.connection.token.exception.RefreshTokenNotFoundException;
import com.connection.token.model.RefreshTokenDALM;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Mono;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Date;
import java.util.UUID;

@Slf4j
@RequiredArgsConstructor
public class RefreshTokenReactiveRepositoryImpl implements RefreshTokenRepository {

    private final ConnectionFactory refreshTokenConnectionFactory;

    @Override
    public Mono<Void> add(RefreshTokenDALM refreshTokenDALM) throws RefreshTokenAlreadyExisistsException {
        log.info("Attempting to add new refresh token for client UID: {}", refreshTokenDALM.getClientUID());
        
        return Mono.usingWhen(
            refreshTokenConnectionFactory.create(),
            connection -> {
                log.debug("Starting transaction for token addition");
                return Mono.from(connection.beginTransaction())
                        .then(Mono.defer(() -> {
                            log.trace("Checking if token already exists: {}", refreshTokenDALM.getToken());
                            return checkTokenExists(connection, refreshTokenDALM.getToken(), refreshTokenDALM.getUid());
                        }))
                        .filter(exists -> !exists)
                        .switchIfEmpty(Mono.defer(() -> {
                            log.warn("Refresh token already exists for token: {} or UID: {}", 
                                    refreshTokenDALM.getToken(), refreshTokenDALM.getUid());
                            return Mono.error(new RefreshTokenAlreadyExisistsException("Refresh token already exists"));
                        }))
                        .then(Mono.defer(() -> {
                            log.debug("Proceeding with token insertion");
                            return insertToken(connection, refreshTokenDALM);
                        }))
                        .then(Mono.defer(() -> {
                            log.debug("Committing transaction for token addition");
                            return Mono.from(connection.commitTransaction());
                        }))
                        .onErrorResume(error -> {
                            log.error("Error during token addition for client: {} - {}. Rolling back transaction.", 
                                    refreshTokenDALM.getClientUID(), error.getMessage());
                            return Mono.from(connection.rollbackTransaction())
                                    .then(Mono.error(error));
                        })
                        .doOnSuccess(v -> log.info("Successfully added refresh token with UID: {} for client: {}", 
                                refreshTokenDALM.getUid(), refreshTokenDALM.getClientUID()));
            },
            Connection::close,
            (connection, error) -> {
                log.error("Async error cleanup for token addition: {}", error.getMessage());
                return Mono.from(connection.close());
            },
            Connection::close
        );
    }

    @Override
    public Mono<Void> updateToken(RefreshTokenDALM oldToken, RefreshTokenDALM newToken) 
            throws RefreshTokenNotFoundException {
        log.info("Attempting to update token from: {} to: {}", oldToken.getToken(), newToken.getToken());
        
        return Mono.usingWhen(
            refreshTokenConnectionFactory.create(),
            connection -> {
                log.debug("Starting transaction for token update");
                return Mono.from(connection.beginTransaction())
                        .then(Mono.defer(() -> {
                            log.trace("Checking if old token exists: {}", oldToken.getToken());
                            return checkTokenExistsByToken(connection, oldToken.getToken());
                        }))
                        .filter(exists -> exists)
                        .switchIfEmpty(Mono.defer(() -> {
                            log.warn("Old refresh token not found: {}", oldToken.getToken());
                            return Mono.error(new RefreshTokenNotFoundException("Refresh token not found"));
                        }))
                        .then(Mono.defer(() -> {
                            log.trace("Checking if new token already exists: {}", newToken.getToken());
                            return checkTokenExistsByToken(connection, newToken.getToken());
                        }))
                        .filter(newExists -> !newExists)
                        .switchIfEmpty(Mono.defer(() -> {
                            log.warn("New refresh token already exists: {}", newToken.getToken());
                            return Mono.error(new RefreshTokenAlreadyExisistsException("Refresh token already exists"));
                        }))
                        .then(Mono.defer(() -> {
                            log.debug("Proceeding with token update");
                            return updateTokenInDb(connection, oldToken.getToken(), newToken);
                        }))
                        .then(Mono.defer(() -> {
                            log.debug("Committing transaction for token update");
                            return Mono.from(connection.commitTransaction());
                        }))
                        .onErrorResume(error -> {
                            log.error("Error during token update from {} to {} - {}. Rolling back transaction.", 
                                    oldToken.getToken(), newToken.getToken(), error.getMessage());
                            return Mono.from(connection.rollbackTransaction())
                                    .then(Mono.error(error));
                        })
                        .doOnSuccess(v -> log.info("Successfully updated token from {} to {}", 
                                oldToken.getToken(), newToken.getToken()));
            },
            Connection::close,
            (connection, error) -> {
                log.error("Async error cleanup for token update: {}", error.getMessage());
                return Mono.from(connection.close());
            },
            Connection::close
        );
    }

    @Override
    public Mono<Void> revoke(RefreshTokenDALM refreshTokenDALM) throws RefreshTokenNotFoundException {
        log.info("Attempting to revoke token with UID: {}", refreshTokenDALM.getUid());
        
        return Mono.usingWhen(
            refreshTokenConnectionFactory.create(),
            connection -> {
                log.debug("Starting transaction for token revocation");
                return Mono.from(connection.beginTransaction())
                        .then(Mono.defer(() -> {
                            log.trace("Checking if UID exists: {}", refreshTokenDALM.getUid());
                            return checkUidExists(connection, refreshTokenDALM.getUid());
                        }))
                        .filter(exists -> exists)
                        .switchIfEmpty(Mono.defer(() -> {
                            log.warn("Refresh token with UID {} not found", refreshTokenDALM.getUid());
                            return Mono.error(new RefreshTokenNotFoundException(
                                "Refresh token with UID " + refreshTokenDALM.getUid() + " not found"));
                        }))
                        .then(Mono.defer(() -> {
                            log.debug("Proceeding with token revocation");
                            return revokeToken(connection, refreshTokenDALM.getUid());
                        }))
                        .then(Mono.defer(() -> {
                            log.debug("Committing transaction for token revocation");
                            return Mono.from(connection.commitTransaction());
                        }))
                        .onErrorResume(error -> {
                            log.error("Error during token revocation for UID: {} - {}. Rolling back transaction.", 
                                    refreshTokenDALM.getUid(), error.getMessage());
                            return Mono.from(connection.rollbackTransaction())
                                    .then(Mono.error(error));
                        })
                        .doOnSuccess(v -> log.info("Successfully revoked token with UID: {}", refreshTokenDALM.getUid()));
            },
            Connection::close,
            (connection, error) -> {
                log.error("Async error cleanup for token revocation: {}", error.getMessage());
                return Mono.from(connection.close());
            },
            Connection::close
        );
    }

    @Override
    public Mono<Void> revokeAll(UUID clientUUID) {
        log.info("Attempting to revoke all tokens for client: {}", clientUUID);
        
        return Mono.usingWhen(
            refreshTokenConnectionFactory.create(),
            connection -> {
                log.debug("Starting transaction for revoke all tokens");
                return Mono.from(connection.beginTransaction())
                        .then(Mono.defer(() -> {
                            String sql = "DELETE FROM \"access\".refresh_token WHERE client_id = $1";
                            log.trace("Executing revoke all query for client: {}", clientUUID);
                            return Mono.from(connection.createStatement(sql)
                                .bind("$1", clientUUID)
                                .execute());
                        }))
                        .flatMap(result -> Mono.from(result.getRowsUpdated()))
                        .doOnNext(rowsDeleted -> log.debug("Revoked {} tokens for client: {}", rowsDeleted, clientUUID))
                        .then(Mono.defer(() -> {
                            log.debug("Committing transaction for revoke all");
                            return Mono.from(connection.commitTransaction());
                        }))
                        .onErrorResume(error -> {
                            log.error("Error during revoke all for client: {} - {}. Rolling back transaction.", 
                                    clientUUID, error.getMessage());
                            return Mono.from(connection.rollbackTransaction())
                                    .then(Mono.error(error));
                        })
                        .doOnSuccess(v -> log.info("Successfully revoked all tokens for client: {}", clientUUID));
            },
            Connection::close,
            (connection, error) -> {
                log.error("Async error cleanup for revoke all: {}", error.getMessage());
                return Mono.from(connection.close());
            },
            Connection::close
        );
    }

    @Override
    public Mono<Void> cleanUpExpired() {
        log.info("Attempting to clean up expired tokens");
        
        return Mono.usingWhen(
            refreshTokenConnectionFactory.create(),
            connection -> {
                log.debug("Starting transaction for cleanup expired tokens");
                return Mono.from(connection.beginTransaction())
                        .then(Mono.defer(() -> {
                            String sql = "DELETE FROM \"access\".refresh_token WHERE expires_at < NOW()";
                            log.trace("Executing cleanup expired tokens query");
                            return Mono.from(connection.createStatement(sql).execute());
                        }))
                        .flatMap(result -> Mono.from(result.getRowsUpdated()))
                        .doOnNext(rowsDeleted -> log.info("Cleaned up {} expired tokens", rowsDeleted))
                        .then(Mono.defer(() -> {
                            log.debug("Committing transaction for cleanup");
                            return Mono.from(connection.commitTransaction());
                        }))
                        .onErrorResume(error -> {
                            log.error("Error during cleanup expired tokens - {}. Rolling back transaction.", 
                                    error.getMessage());
                            return Mono.from(connection.rollbackTransaction())
                                    .then(Mono.error(error));
                        })
                        .doOnSuccess(v -> log.info("Successfully cleaned up expired tokens"));
            },
            Connection::close,
            (connection, error) -> {
                log.error("Async error cleanup for cleanup: {}", error.getMessage());
                return Mono.from(connection.close());
            },
            Connection::close
        );
    }

    // Вспомогательные методы
    private Mono<Boolean> checkTokenExists(Connection connection, String token, UUID uid) {
        log.trace("Checking token existence for token: {} and UID: {}", token, uid);
        
        String sql = "SELECT COUNT(*) as count FROM \"access\".refresh_token WHERE token = $1 OR uid = $2";
        
        return Mono.from(connection.createStatement(sql)
            .bind("$1", token)
            .bind("$2", uid)
            .execute())
            .flatMap(result -> 
                Mono.from(result.map((row, metadata) -> row.get("count", Long.class)))
            )
            .map(count -> count > 0)
            .defaultIfEmpty(false)
            .doOnNext(exists -> log.trace("Token existence check result: {}", exists));
    }

    private Mono<Boolean> checkTokenExistsByToken(Connection connection, String token) {
        log.trace("Checking token existence by token: {}", token);
        
        String sql = "SELECT COUNT(*) as count FROM \"access\".refresh_token WHERE token = $1";
        
        return Mono.from(connection.createStatement(sql)
            .bind("$1", token)
            .execute())
            .flatMap(result -> 
                Mono.from(result.map((row, metadata) -> row.get("count", Long.class)))
            )
            .map(count -> count > 0)
            .defaultIfEmpty(false)
            .doOnNext(exists -> log.trace("Token existence by token check result: {}", exists));
    }

    private Mono<Boolean> checkUidExists(Connection connection, UUID uid) {
        log.trace("Checking token existence by UID: {}", uid);
        
        String sql = "SELECT COUNT(*) as count FROM \"access\".refresh_token WHERE uid = $1";
        
        return Mono.from(connection.createStatement(sql)
            .bind("$1", uid)
            .execute())
            .flatMap(result -> 
                Mono.from(result.map((row, metadata) -> row.get("count", Long.class)))
            )
            .map(count -> count > 0)
            .defaultIfEmpty(false)
            .doOnNext(exists -> log.trace("Token existence by UID check result: {}", exists));
    }

    private Mono<Void> insertToken(Connection connection, RefreshTokenDALM token) {
        log.debug("Inserting new token with UID: {} for client: {}", token.getUid(), token.getClientUID());
        
        String sql = "INSERT INTO \"access\".refresh_token (uid, client_id, token, created_at, expires_at) " +
                    "VALUES ($1, $2, $3, $4, $5)";
        
        Statement stmt = connection.createStatement(sql)
            .bind("$1", token.getUid())
            .bind("$2", token.getClientUID())
            .bind("$3", token.getToken())
            .bind("$4", toLocalDateTime(token.getCreatedAt()))
            .bind("$5", toLocalDateTime(token.getExpiresAt()));

        return Mono.from(stmt.execute())
                .flatMap(result -> Mono.from(result.getRowsUpdated()))
                .doOnNext(rowsUpdated -> log.debug("Token insert executed, rows affected: {}", rowsUpdated))
                .then()
                .doOnSuccess(v -> log.info("Token inserted successfully with UID: {}", token.getUid()))
                .doOnError(error -> log.error("Failed to insert token with UID: {} - {}", token.getUid(), error.getMessage()));
    }

    private Mono<Void> updateTokenInDb(Connection connection, String oldToken, RefreshTokenDALM newToken) {
        log.debug("Updating token from: {} to: {}", oldToken, newToken.getToken());
        
        String sql = "UPDATE \"access\".refresh_token SET token = $1, expires_at = $2, created_at = $3 " +
                    "WHERE token = $4";
        
        Statement stmt = connection.createStatement(sql)
            .bind("$1", newToken.getToken())
            .bind("$2", toLocalDateTime(newToken.getExpiresAt()))
            .bind("$3", toLocalDateTime(newToken.getCreatedAt()))
            .bind("$4", oldToken);

        return Mono.from(stmt.execute())
                .flatMap(result -> Mono.from(result.getRowsUpdated()))
                .doOnNext(rowsUpdated -> log.debug("Token update executed, rows affected: {}", rowsUpdated))
                .then()
                .doOnSuccess(v -> log.info("Token updated successfully from {} to {}", oldToken, newToken.getToken()))
                .doOnError(error -> log.error("Failed to update token from {} - {}", oldToken, error.getMessage()));
    }

    private Mono<Void> revokeToken(Connection connection, UUID uid) {
        log.debug("Revoking token with UID: {}", uid);
        
        String sql = "DELETE FROM \"access\".refresh_token WHERE uid = $1";
        return Mono.from(connection.createStatement(sql)
            .bind("$1", uid)
            .execute())
            .flatMap(result -> Mono.from(result.getRowsUpdated()))
            .doOnNext(rowsDeleted -> log.debug("Token revocation executed, rows affected: {}", rowsDeleted))
            .then()
            .doOnSuccess(v -> log.info("Token revoked successfully with UID: {}", uid))
            .doOnError(error -> log.error("Failed to revoke token with UID: {} - {}", uid, error.getMessage()));
    }

    // Дополнительные реактивные методы
    public Mono<RefreshTokenDALM> findByUid(UUID uid) throws RefreshTokenNotFoundException {
        log.debug("Searching for token by UID: {}", uid);
        
        return Mono.usingWhen(
            refreshTokenConnectionFactory.create(),
            connection -> {
                String sql = "SELECT uid, client_id, token, created_at, expires_at " +
                           "FROM \"access\".refresh_token WHERE uid = $1";
                
                return Mono.from(connection.createStatement(sql)
                    .bind("$1", uid)
                    .execute())
                    .flatMap(result -> 
                        Mono.from(result.map((row, metadata) -> mapRowToRefreshTokenDALM(row)))
                    )
                    .doOnSuccess(token -> log.debug("Found token by UID: {}", uid))
                    .doOnError(error -> log.warn("Token not found by UID: {} - {}", uid, error.getMessage()))
                    .switchIfEmpty(Mono.error(new RefreshTokenNotFoundException(
                        "Refresh token with UID " + uid + " not found")));
            },
            Connection::close,
            (connection, error) -> Mono.from(connection.close()),
            Connection::close
        );
    }

    public Mono<RefreshTokenDALM> findByToken(String token) throws RefreshTokenNotFoundException {
        log.debug("Searching for token by token string: {}", token);
        
        return Mono.usingWhen(
            refreshTokenConnectionFactory.create(),
            connection -> {
                String sql = "SELECT uid, client_id, token, created_at, expires_at " +
                           "FROM \"access\".refresh_token WHERE token = $1";
                
                return Mono.from(connection.createStatement(sql)
                    .bind("$1", token)
                    .execute())
                    .flatMap(result -> 
                        Mono.from(result.map((row, metadata) -> mapRowToRefreshTokenDALM(row)))
                    )
                    .doOnSuccess(foundToken -> log.debug("Found token by token string: {}", token))
                    .doOnError(error -> log.warn("Token not found by token string: {} - {}", token, error.getMessage()))
                    .switchIfEmpty(Mono.error(new RefreshTokenNotFoundException("Refresh token not found")));
            },
            Connection::close,
            (connection, error) -> Mono.from(connection.close()),
            Connection::close
        );
    }

    public Mono<Boolean> isTokenValid(String token) {
        log.trace("Checking token validity: {}", token);
        
        return findByToken(token)
            .map(refreshToken -> {
                boolean isValid = refreshToken.getExpiresAt().after(new Date());
                log.trace("Token validity check for {}: {}", token, isValid);
                return isValid;
            })
            .onErrorReturn(RefreshTokenNotFoundException.class, false)
            .doOnError(error -> log.warn("Error during token validity check for {}: {}", token, error.getMessage()));
    }

    // Маппинг Row -> RefreshTokenDALM
    private RefreshTokenDALM mapRowToRefreshTokenDALM(Row row) {
        log.trace("Mapping row to RefreshTokenDALM");
        
        LocalDateTime createdAtLocal = row.get("created_at", LocalDateTime.class);
        LocalDateTime expiresAtLocal = row.get("expires_at", LocalDateTime.class);

        return RefreshTokenDALM.builder()
            .uid(row.get("uid", UUID.class))
            .clientUID(row.get("client_id", UUID.class))
            .token(row.get("token", String.class))
            .createdAt(toDate(createdAtLocal))
            .expiresAt(toDate(expiresAtLocal))
            .build();
    }

    // Утилиты для конвертации Date <-> LocalDateTime
    private LocalDateTime toLocalDateTime(Date date) {
        return date != null ? 
            date.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime() : null;
    }

    private Date toDate(LocalDateTime localDateTime) {
        return localDateTime != null ? 
            Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant()) : null;
    }

    // Метод для проверки соединения с БД
    public Mono<Boolean> testConnection() {
        return Mono.usingWhen(
                refreshTokenConnectionFactory.create(),
                connection -> {
                    log.info("Testing database connection for tokens");
                    return Mono.from(connection.createStatement("SELECT 1").execute())
                            .flatMap(result -> Mono.from(result.map((row, metadata) -> true)))
                            .doOnSuccess(v -> log.info("Database connection test successful for tokens"))
                            .doOnError(error -> log.error("Database connection test failed for tokens: {}", error.getMessage()));
                },
                Connection::close,
                (connection, error) -> Mono.from(connection.close()),
                Connection::close
        );
    }
}package com.connection.token.mother;

import java.util.Date;
import java.util.UUID;

import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.AccessTokenDALM;
import com.connection.token.model.AccessTokenDTO;
import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDALM;
import com.connection.token.model.RefreshTokenDTO;

public class TokenObjectMother {

    private static final UUID DEFAULT_UID = UUID.fromString("123e4567-e89b-12d3-a456-426614174000");
    private static final UUID DEFAULT_CLIENT_UID = UUID.fromString("123e4567-e89b-12d3-a456-426614174001");
    private static final String DEFAULT_TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c";
    private static final Date DEFAULT_CREATED_AT = new Date(System.currentTimeMillis() - 1000L * 60 * 5);
    private static final Date DEFAULT_EXPIRES_AT = new Date(System.currentTimeMillis() + 1000L * 60 * 60 * 24);

    public static RefreshTokenDTO createValidRefreshTokenDTO() {
        return new RefreshTokenDTO(DEFAULT_TOKEN);
    }

    public static RefreshTokenBLM createValidRefreshTokenBLM() {
        return new RefreshTokenBLM(DEFAULT_TOKEN, DEFAULT_UID, DEFAULT_CLIENT_UID, DEFAULT_CREATED_AT, DEFAULT_EXPIRES_AT);
    }

    public static RefreshTokenDALM createValidRefreshTokenDALM() {
        return new RefreshTokenDALM(DEFAULT_TOKEN, DEFAULT_UID, DEFAULT_CLIENT_UID, DEFAULT_CREATED_AT, DEFAULT_EXPIRES_AT);
    }

    public static AccessTokenDTO createValidAccessTokenDTO() {
        return new AccessTokenDTO(DEFAULT_TOKEN);
    }

    public static AccessTokenBLM createValidAccessTokenBLM() {
        return new AccessTokenBLM(DEFAULT_TOKEN, DEFAULT_CLIENT_UID, DEFAULT_CREATED_AT, DEFAULT_EXPIRES_AT);
    }

    public static AccessTokenDALM createValidAccessTokenDALM() {
        return new AccessTokenDALM(DEFAULT_CLIENT_UID, DEFAULT_CREATED_AT, DEFAULT_EXPIRES_AT);
    }

    public static RefreshTokenDTO createRefreshTokenDTOWithEmptyToken() {
        return new RefreshTokenDTO("");
    }

    public static RefreshTokenBLM createRefreshTokenBLMWithNullFields() {
        return new RefreshTokenBLM(null, null, null, null, null);
    }

    public static RefreshTokenDALM createRefreshTokenDALMWithNullFields() {
        return new RefreshTokenDALM(null, null, null, null, null);
    }

    public static RefreshTokenBLM createRefreshTokenBLMWithExpiredToken() {
        Date expiredDate = new Date(System.currentTimeMillis() - 1000L * 60 * 60);
        return new RefreshTokenBLM(DEFAULT_TOKEN, DEFAULT_UID, DEFAULT_CLIENT_UID, DEFAULT_CREATED_AT, expiredDate);
    }

    public static RefreshTokenDALM createRefreshTokenDALMWithFutureCreatedAt() {
        Date futureDate = new Date(System.currentTimeMillis() + 1000L * 60 * 60);
        return new RefreshTokenDALM(DEFAULT_TOKEN, DEFAULT_UID, DEFAULT_CLIENT_UID, futureDate, DEFAULT_EXPIRES_AT);
    }

    public static RefreshTokenDALM createRefreshTokenForClient(UUID clientUid) {
        return new RefreshTokenDALM(DEFAULT_TOKEN, UUID.randomUUID(), clientUid, DEFAULT_CREATED_AT, DEFAULT_EXPIRES_AT);
    }
}package com.connection.token.exception;

public class AccessTokenValidateException extends BaseTokenException{
    String descriptionString;
    public AccessTokenValidateException(String tokenString, String description){
        super(tokenString);
        this.descriptionString = description;
    }

    public String toString(){
        String res = super.toString();
        res += "\n" + "description: Access token is invalid";
        res += "\n" + descriptionString;
        return res;
    }
}
package com.connection.token.repository;

import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Timestamp;
import java.util.Date;
import java.util.UUID;

import com.connection.token.exception.RefreshTokenAlreadyExisistsException;
import com.connection.token.exception.RefreshTokenNotFoundException;
import com.connection.token.model.RefreshTokenDALM;


public class RefreshTokenRepositorySQLImpl implements RefreshTokenRepository {

    private static final String SELECT_REFRESH_TOKEN = "SELECT uid, client_id, token, family_id, created_at, expires_at";
    private static final String FROM_REFRESH_TOKEN = " FROM public.refresh_token";

    private static final String SELECT_TOKEN_BY_UID = SELECT_REFRESH_TOKEN + FROM_REFRESH_TOKEN + " WHERE uid = :uid";
    private static final String SELECT_TOKEN_BY_TOKEN = SELECT_REFRESH_TOKEN + FROM_REFRESH_TOKEN + " WHERE token = :token";
    // private static final String SELECT_TOKENS_BY_CLIENT = SELECT_REFRESH_TOKEN + FROM_REFRESH_TOKEN + " WHERE client_id = :client_id";
    // private static final String SELECT_TOKEN_BY_FAMILY = SELECT_REFRESH_TOKEN + FROM_REFRESH_TOKEN + " WHERE family_id = :family_id";

    private static final String INSERT_REFRESH_TOKEN = "INSERT INTO public.refresh_token (uid, client_id, token, family_id, created_at, expires_at) " +
            "VALUES (:uid, :client_id, :token, :family_id, :created_at, :expires_at)";

    private static final String UPDATE_TOKEN = "UPDATE public.refresh_token SET token = :new_token, expires_at = :new_expires_at, created_at = :new_created_at " +
            "WHERE uid = :uid";

    private static final String REVOKE_TOKEN = "DELETE FROM public.refresh_token WHERE uid = :uid";
    private static final String REVOKE_ALL_CLIENT_TOKENS = "DELETE FROM public.refresh_token WHERE client_id = :client_id";
    private static final String CLEANUP_EXPIRED_TOKENS = "DELETE FROM public.refresh_token WHERE expires_at < NOW()";

    private final NamedParameterJdbcTemplate jdbcTemplate;

    private final RowMapper<RefreshTokenDALM> refreshTokenRowMapper = (rs, rowNum) -> {
        RefreshTokenDALM token = new RefreshTokenDALM();
        token.setUid(UUID.fromString(rs.getString("uid")));
        token.setClientUID(UUID.fromString(rs.getString("client_id")));
        token.setToken(rs.getString("token"));
        token.setCreatedAt(rs.getTimestamp("created_at"));
        token.setExpiresAt(rs.getTimestamp("expires_at"));
        return token;
    };

    public RefreshTokenRepositorySQLImpl(NamedParameterJdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    //@Transaction
    public void add(RefreshTokenDALM refreshTokenDALM) throws RefreshTokenAlreadyExisistsException {
        // Проверяем существование по token
        if (tokenExists(refreshTokenDALM.getToken())) {
            throw new RefreshTokenAlreadyExisistsException("Refresh token already exists");
        }

        // Проверяем существование по uid
        if (uidExists(refreshTokenDALM.getUid())) {
            throw new RefreshTokenAlreadyExisistsException("Refresh token with UID " + refreshTokenDALM.getUid() + " already exists");
        }

        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", refreshTokenDALM.getUid());
        params.addValue("client_id", refreshTokenDALM.getClientUID());
        params.addValue("token", refreshTokenDALM.getToken());
        params.addValue("family_id", refreshTokenDALM.getUid()); // Используем uid как family_id для простоты
        params.addValue("created_at", new Timestamp(refreshTokenDALM.getCreatedAt().getTime()));
        params.addValue("expires_at", new Timestamp(refreshTokenDALM.getExpiresAt().getTime()));

        jdbcTemplate.update(INSERT_REFRESH_TOKEN, params);
    }

    @Override
    //@Transaction
    public void updateToken(RefreshTokenDALM refreshTokenDALM, RefreshTokenDALM newRefreshTokenDALM) 
            throws RefreshTokenNotFoundException {
        // Проверяем существование старого токена
        if (!uidExists(refreshTokenDALM.getUid())) {
            throw new RefreshTokenNotFoundException("Refresh token with UID " + refreshTokenDALM.getUid() + " not found");
        }

        // Проверяем что новый токен не существует
        if (tokenExists(newRefreshTokenDALM.getToken())) {
            throw new RefreshTokenAlreadyExisistsException("Refresh token already exists");
        }

        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", refreshTokenDALM.getUid());
        params.addValue("new_token", newRefreshTokenDALM.getToken());
        params.addValue("new_created_at", new Timestamp(newRefreshTokenDALM.getCreatedAt().getTime()));
        params.addValue("new_expires_at", new Timestamp(newRefreshTokenDALM.getExpiresAt().getTime()));

        jdbcTemplate.update(UPDATE_TOKEN, params);
    }

    @Override
    //@Transaction
    public void revoke(RefreshTokenDALM refreshTokenDALM) throws RefreshTokenNotFoundException {
        // Проверяем существование токена
        if (!uidExists(refreshTokenDALM.getUid())) {
            throw new RefreshTokenNotFoundException("Refresh token with UID " + refreshTokenDALM.getUid() + " not found");
        }

        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", refreshTokenDALM.getUid());

        jdbcTemplate.update(REVOKE_TOKEN, params);
    }

    @Override
    //@Transaction
    public void revokeAll(UUID clientUUID) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("client_id", clientUUID);

        jdbcTemplate.update(REVOKE_ALL_CLIENT_TOKENS, params);
    }

    @Override
    //@Transaction
    public void cleanUpExpired() {
        jdbcTemplate.update(CLEANUP_EXPIRED_TOKENS, new MapSqlParameterSource());
    }

    // Вспомогательные методы
    //@Transaction(readOnly = true)
    boolean uidExists(UUID uid) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", uid);
        try {
            jdbcTemplate.queryForObject(SELECT_TOKEN_BY_UID, params, refreshTokenRowMapper);
            return true;
        } catch (EmptyResultDataAccessException e) {
            return false;
        }
    }

    //@Transaction(readOnly = true)
    boolean tokenExists(String token) {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("token", token);
        try {
            jdbcTemplate.queryForObject(SELECT_TOKEN_BY_TOKEN, params, refreshTokenRowMapper);
            return true;
        } catch (EmptyResultDataAccessException e) {
            return false;
        }
    }

    // Дополнительные методы для внутреннего использования
    //@Transaction(readOnly = true)
    RefreshTokenDALM findByUid(UUID uid) throws RefreshTokenNotFoundException {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", uid);
        try {
            return jdbcTemplate.queryForObject(SELECT_TOKEN_BY_UID, params, refreshTokenRowMapper);
        } catch (EmptyResultDataAccessException e) {
            throw new RefreshTokenNotFoundException("Refresh token with UID " + uid + " not found");
        }
    }

    //@Transaction(readOnly = true)
    RefreshTokenDALM findByToken(String token) throws RefreshTokenNotFoundException {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("token", token);
        try {
            return jdbcTemplate.queryForObject(SELECT_TOKEN_BY_TOKEN, params, refreshTokenRowMapper);
        } catch (EmptyResultDataAccessException e) {
            throw new RefreshTokenNotFoundException("Refresh token not found");
        }
    }

    //@Transaction(readOnly = true)
    boolean isTokenValid(String token) {
        try {
            RefreshTokenDALM refreshToken = findByToken(token);
            return refreshToken.getExpiresAt().after(new Date());
        } catch (RefreshTokenNotFoundException e) {
            return false;
        }
    }
}package com.connection.token.model;

import java.util.Date;
import java.util.UUID;

import jakarta.persistence.Entity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Builder
public class RefreshTokenBLM {
    protected String token;
    protected UUID uid;
    protected UUID clientUID;
    
    protected Date createdAt;
    protected Date expiresAt;
}
package com.connection.token.converter;

import com.connection.token.generator.RefreshTokenGenerator;
import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDALM;
import com.connection.token.model.RefreshTokenDTO;

import io.jsonwebtoken.JwtException;
import jakarta.annotation.Nonnull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class RefreshTokenConverter {
    @Nonnull
    private final RefreshTokenGenerator tokenGenerator;
    public RefreshTokenBLM toBLM(RefreshTokenDALM dalm) {
        String token  = tokenGenerator.generateRefreshToken(dalm);
        return new RefreshTokenBLM(token,
                dalm.getUid(),
                dalm.getClientUID(),
                dalm.getCreatedAt(),
                dalm.getExpiresAt());
    }

    public RefreshTokenBLM toBLM(RefreshTokenDTO dto) {
        try {
            RefreshTokenBLM tokenBLM = tokenGenerator.getRefreshToken(dto.getToken());
            return tokenBLM;
        } catch (JwtException e) {
            throw new RuntimeException("Invalid JWT token: " + e.getMessage(), e);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException("Malformed JWT token", e);
        }
    }

    public RefreshTokenDTO toDTO(RefreshTokenBLM blm){
        return new RefreshTokenDTO(blm.getToken());
    }

    public RefreshTokenDALM toDALM(RefreshTokenBLM blm){
        return new RefreshTokenDALM(blm.getToken(), 
                                    blm.getUid(),
                                    blm.getClientUID(), 
                                    blm.getCreatedAt(), 
                                    blm.getExpiresAt());
    }
}

package com.connection.token.mother;

import java.util.Date;
import java.util.UUID;

import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.AccessTokenDALM;
import com.connection.token.model.AccessTokenDTO;
import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDALM;
import com.connection.token.model.RefreshTokenDTO;

public class TokenObjectMother {

    private static final UUID DEFAULT_UID = UUID.fromString("123e4567-e89b-12d3-a456-426614174000");
    private static final UUID DEFAULT_CLIENT_UID = UUID.fromString("123e4567-e89b-12d3-a456-426614174001");
    private static final String DEFAULT_TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c";
    private static final Date DEFAULT_CREATED_AT = new Date(System.currentTimeMillis() - 1000L * 60 * 5);
    private static final Date DEFAULT_EXPIRES_AT = new Date(System.currentTimeMillis() + 1000L * 60 * 60 * 24);

    public static RefreshTokenDTO createValidRefreshTokenDTO() {
        return new RefreshTokenDTO(DEFAULT_TOKEN);
    }

    public static RefreshTokenBLM createValidRefreshTokenBLM() {
        return new RefreshTokenBLM(DEFAULT_TOKEN, DEFAULT_UID, DEFAULT_CLIENT_UID, DEFAULT_CREATED_AT, DEFAULT_EXPIRES_AT);
    }

    public static RefreshTokenDALM createValidRefreshTokenDALM() {
        return new RefreshTokenDALM(DEFAULT_TOKEN, DEFAULT_UID, DEFAULT_CLIENT_UID, DEFAULT_CREATED_AT, DEFAULT_EXPIRES_AT);
    }

    public static AccessTokenDTO createValidAccessTokenDTO() {
        return new AccessTokenDTO(DEFAULT_TOKEN);
    }

    public static AccessTokenBLM createValidAccessTokenBLM() {
        return new AccessTokenBLM(DEFAULT_TOKEN, DEFAULT_CLIENT_UID, DEFAULT_CREATED_AT, DEFAULT_EXPIRES_AT);
    }

    public static AccessTokenDALM createValidAccessTokenDALM() {
        return new AccessTokenDALM(DEFAULT_CLIENT_UID, DEFAULT_CREATED_AT, DEFAULT_EXPIRES_AT);
    }

    public static RefreshTokenDTO createRefreshTokenDTOWithEmptyToken() {
        return new RefreshTokenDTO("");
    }

    public static RefreshTokenBLM createRefreshTokenBLMWithNullFields() {
        return new RefreshTokenBLM(null, null, null, null, null);
    }

    public static RefreshTokenDALM createRefreshTokenDALMWithNullFields() {
        return new RefreshTokenDALM(null, null, null, null, null);
    }

    public static RefreshTokenBLM createRefreshTokenBLMWithExpiredToken() {
        Date expiredDate = new Date(System.currentTimeMillis() - 1000L * 60 * 60);
        return new RefreshTokenBLM(DEFAULT_TOKEN, DEFAULT_UID, DEFAULT_CLIENT_UID, DEFAULT_CREATED_AT, expiredDate);
    }

    public static RefreshTokenDALM createRefreshTokenDALMWithFutureCreatedAt() {
        Date futureDate = new Date(System.currentTimeMillis() + 1000L * 60 * 60);
        return new RefreshTokenDALM(DEFAULT_TOKEN, DEFAULT_UID, DEFAULT_CLIENT_UID, futureDate, DEFAULT_EXPIRES_AT);
    }

    public static RefreshTokenDALM createRefreshTokenForClient(UUID clientUid) {
        return new RefreshTokenDALM(DEFAULT_TOKEN, UUID.randomUUID(), clientUid, DEFAULT_CREATED_AT, DEFAULT_EXPIRES_AT);
    }
}package com.connection.token.exception;

public class RefreshTokenAddException extends BaseTokenException{
    public RefreshTokenAddException(String tokenString){
        super(tokenString);
    }

    public String toString(){
        String res = super.toString();
        res += "\n" + "description: cannot add refresh token";
        return res;
    }
}
package com.connection.token.generator;

import java.util.Date;
import java.util.UUID;

import javax.crypto.SecretKey;

import com.connection.token.model.AccessTokenBLM;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import io.jsonwebtoken.Jwts;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class AccessTokenGenerator {
    @NonNull
    private final SecretKey jwtSecretKey;

    @NonNull
    private final String appNameString;

    @NonNull
    private final String jwtSubjecString;

    public String generateAccessToken(UUID clientUuid, Date createdAtDate, Date expiresAtDate) {
        String token = Jwts.builder()
                .issuer(appNameString)
                .subject(jwtSubjecString)
                .claim("clientUid", clientUuid.toString())
                .issuedAt(createdAtDate)
                .expiration(expiresAtDate)
                .signWith(jwtSecretKey)
                .compact();
        return token;
    }

    public AccessTokenBLM getAccessTokenBLM(String token) {
        Jws<Claims> jws = Jwts.parser()
                .verifyWith(jwtSecretKey)
                .build()
                .parseSignedClaims(token);

        Claims claims = jws.getPayload();

        UUID clientUid = UUID.fromString(claims.get("clientUid", String.class));
        Date issuedAt = claims.getIssuedAt();
        Date expiration = claims.getExpiration();

        if (!jwtSubjecString.equals(claims.getSubject())) {
            throw new RuntimeException("Invalid token subject");
        }

        return new AccessTokenBLM(token, clientUid, issuedAt, expiration);
    }
}
package com.connection.token.exception;

public class RefreshTokenNotFoundException extends BaseTokenException {
    public RefreshTokenNotFoundException(String tokenString) {
        super(tokenString);
    }

    public String toString() {
        String res = super.toString();
        res += "\n" + "description: refresh token not found";
        return res;
    }
}
package com.connection.token.model;

import java.util.Date;
import java.util.UUID;

import jakarta.persistence.Entity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Builder
public class RefreshTokenDALM {
    protected String token;

    
    protected UUID uid;
    
    protected UUID clientUID;
    
    protected Date createdAt;
    
    protected Date expiresAt;
}
package com.connection.token.model;
import jakarta.persistence.Entity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Builder
public class AccessTokenDTO {
    protected String token;
}
package com.connection.token.model;

import jakarta.persistence.Entity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Builder
public class RefreshTokenDTO {
    protected String token;
}
package com.connection.token.model;

import java.util.Date;
import java.util.UUID;

import jakarta.persistence.Entity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Builder
public class AccessTokenBLM {
    protected String token;
    protected UUID clientUID;
    protected Date createdAt;
    protected Date expiresAt;
}
package com.connection.token.exception;

public class RefreshTokenExpiredException extends BaseTokenException {
    public RefreshTokenExpiredException(String tokenString) {
        super(tokenString);
    }

    public String toString() {
        String res = super.toString();
        res += "\n" + "description: refresh token is expired";
        return res;
    }
}
package com.connection.token.exception;

public class RefreshTokenValidateException extends BaseTokenException{
    String descriptionString;
    public RefreshTokenValidateException(String tokenString, String description){
        super(tokenString);
        this.descriptionString = description;
    }

    public String toString(){
        String res = super.toString();
        res += "\n" + "description: refresh token is invalid";
        res += "\n" + descriptionString;
        return res;
    }
}
package com.connection.token.exception;

public class BaseTokenException extends RuntimeException{
    private final String tokenString;

    public BaseTokenException(String tokenDescription){
        super("token");
        tokenString = tokenDescription;
    }

    public String toString(){
        String res = super.toString();
        res += "\n" + "token: " + tokenString;
        return res;
    }
}
package com.connection.token.repository;

import java.util.UUID;

import com.connection.token.exception.RefreshTokenAlreadyExisistsException;
import com.connection.token.exception.RefreshTokenNotFoundException;
import com.connection.token.model.RefreshTokenDALM;

public interface RefreshTokenRepository {
    /**
     * Лобавить новый refreshToken
     * 
     * @param refreshTokenDALM Новый токен
     */
    public void add(RefreshTokenDALM refreshTokenDALM) throws RefreshTokenAlreadyExisistsException;

    /**
     * Обновить токен
     * Создается новый токен взамен старого, старый отзывается
     * 
     * @param refreshTokenDALM Старый токен
     * @return Новый сохраненный токен
     * @throws RefreshTokenNotFoundException Если токен с таким uid не существует
     */
    public void updateToken(RefreshTokenDALM refreshTokenDALM, RefreshTokenDALM newRefreshTokenDALM)
            throws RefreshTokenNotFoundException;

    /**
     * Отозвать токен
     * 
     * @param refreshTokenDALM Токен для отзыва
     * @throws RefreshTokenNotFoundException Если токен с таким uid не существует
     */
    public void revoke(RefreshTokenDALM refreshTokenDALM) throws RefreshTokenNotFoundException;

    /**
     * Отозвать все токены клиента
     * 
     * @param clientDALM Клиент
     */
    public void revokeAll(UUID clientUUID);

    /**
     * Отозвать все закончившиеся токены
     */
    public void cleanUpExpired();
}
package com.connection.token.exception;

public class RefreshTokenAlreadyExisistsException extends BaseTokenException{
    private final String descriptionString = "refresh token already exists";
    public RefreshTokenAlreadyExisistsException(String tokenString){
        super(tokenString);
    }

    public String toString(){
        String res = super.toString();
        res += "\n" + "description: " + descriptionString;
        return res;
    }
}
package com.connection.token.validator;

import java.util.Date;
import java.util.UUID;

import com.connection.token.exception.RefreshTokenValidateException;
import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDALM;
import com.connection.token.model.RefreshTokenDTO;

public class RefreshTokenValidator {
    public void validate(RefreshTokenDTO refreshToken) {
        if (refreshToken == null) {
            throw new RefreshTokenValidateException("null", "Refresh token is null");
        }
        try {
            validateToken(refreshToken.getToken());
        } catch (IllegalArgumentException e) {
            throw new RefreshTokenValidateException("refreshToken", e.getMessage());
        }
    }

    public void validate(RefreshTokenBLM refreshToken) {
        if (refreshToken == null) {
            throw new RefreshTokenValidateException("null", "Refresh token is null");
        }
        try {
            validateToken(refreshToken.getToken());
            validateUID(refreshToken.getUid());
            validateClientUID(refreshToken.getClientUID());
            validateCreatedAt(refreshToken.getCreatedAt());
            validateExpiresAt(refreshToken.getExpiresAt());
        } catch (IllegalArgumentException e) {
            if (refreshToken.getUid() != null)
                throw new RefreshTokenValidateException(refreshToken.getUid().toString(), e.getMessage());
            else
                throw new RefreshTokenValidateException("null", e.getMessage());
        }
    }

    public void validate(RefreshTokenDALM refreshToken) {
        if (refreshToken == null) {
            throw new RefreshTokenValidateException("null", "Refresh token is null");
        }
        try {
            validateUID(refreshToken.getUid());
            validateClientUID(refreshToken.getClientUID());
            validateCreatedAt(refreshToken.getCreatedAt());
            validateExpiresAt(refreshToken.getExpiresAt());
        } catch (IllegalArgumentException e) {
            if (refreshToken.getUid() != null)
                throw new RefreshTokenValidateException(refreshToken.getUid().toString(), e.getMessage());
            else
                throw new RefreshTokenValidateException("null", e.getMessage());
        }
    }

    private void validateToken(String token) {
        if (token == null || token.trim().isEmpty()) {
            throw new IllegalArgumentException("Token cannot be empty");
        }
    }

    private void validateUID(UUID UID) {
        if (UID == null) {
            throw new IllegalArgumentException("UID cannot be null");
        }
    }

    private void validateClientUID(UUID clientUID) {
        if (clientUID == null) {
            throw new IllegalArgumentException("Client UID cannot be null");
        }
    }

    private void validateCreatedAt(Date createdAt) {
        if (createdAt == null) {
            throw new IllegalArgumentException("Creation date cannot be null");
        }

        Date now = new Date();
        if (createdAt.after(now)) {
            throw new IllegalArgumentException("Creation date cannot be in the future");
        }
    }

    private void validateExpiresAt(Date expiresAt) {
        if (expiresAt == null) {
            throw new IllegalArgumentException("Expiration date cannot be null");
        }

        Date now = new Date();
        if (expiresAt.before(now)) {
            throw new IllegalArgumentException("Token has already expired");
        }
    }

}
package com.connection.token.validator;

import java.util.Date;
import java.util.UUID;

import com.connection.token.exception.AccessTokenValidateException;
import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.AccessTokenDALM;
import com.connection.token.model.AccessTokenDTO;

public class AccessTokenValidator {
    public void validate(AccessTokenDTO accessToken) {
        if (accessToken == null) {
            throw new AccessTokenValidateException("null", "Access token is null");
        }
        try {
            validateToken(accessToken.getToken());
        } catch (IllegalArgumentException e) {
            throw new AccessTokenValidateException("accessToken", e.getMessage());
        }
    }

    public void validate(AccessTokenBLM accessToken) {
        if (accessToken == null) {
            throw new AccessTokenValidateException("null", "Access token is null");
        }
        try {
            validateToken(accessToken.getToken());
            validateClientUID(accessToken.getClientUID());
            validateCreatedAt(accessToken.getCreatedAt());
            validateExpiresAt(accessToken.getExpiresAt());
        } catch (IllegalArgumentException e) {
            throw new AccessTokenValidateException("accessToken", e.getMessage());
        }
    }

    public void validate(AccessTokenDALM accessToken) {
        if (accessToken == null) {
            throw new AccessTokenValidateException("null", "Access token is null");
        }
        try {
            validateClientUID(accessToken.getClientUID());
            validateCreatedAt(accessToken.getCreatedAt());
            validateExpiresAt(accessToken.getExpiresAt());
        } catch (IllegalArgumentException e) {
            throw new AccessTokenValidateException("accessToken", e.getMessage());
        }
    }

    private void validateToken(String token) {
        if (token == null || token.trim().isEmpty()) {
            throw new IllegalArgumentException("Token cannot be empty");
        }
    }

    private void validateClientUID(UUID clientUID) {
        if (clientUID == null) {
            throw new IllegalArgumentException("Client UID cannot be null");
        }
    }

    private void validateCreatedAt(Date createdAt) {
        if (createdAt == null) {
            throw new IllegalArgumentException("Creation date cannot be null");
        }

        Date now = new Date();
        if (createdAt.after(now)) {
            throw new IllegalArgumentException("Creation date cannot be in the future");
        }
    }

    private void validateExpiresAt(Date expiresAt) {
        if (expiresAt == null) {
            throw new IllegalArgumentException("Expiration date cannot be null");
        }

        Date now = new Date();
        if (expiresAt.before(now)) {
            throw new IllegalArgumentException("Token has already expired");
        }
    }

}
package com.connection.token.generator;

import java.util.Date;
import java.util.UUID;

import javax.crypto.SecretKey;

import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDALM;

import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jws;
import io.jsonwebtoken.Jwts;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class RefreshTokenGenerator {
    @NonNull
    private final SecretKey jwtSecretKey;

    @NonNull
    private final String appNameString;

    @NonNull
    private final String jwtSubjecString;

    public String generateRefreshToken(RefreshTokenDALM dalm) {
        String token = Jwts.builder()
                .issuer(appNameString)
                .subject(jwtSubjecString)
                .claim("uid", dalm.getUid().toString())
                .claim("clientUid", dalm.getClientUID().toString())
                .issuedAt(dalm.getCreatedAt())
                .expiration(dalm.getExpiresAt())
                .signWith(jwtSecretKey)
                .compact();
        return token;
    }

    public String generateRefreshToken(UUID uid, UUID clientUuid, Date createdAt, Date expiresAt) {
        String token = Jwts.builder()
                .issuer(appNameString)
                .subject(jwtSubjecString)
                .claim("uid", uid.toString())
                .claim("clientUid", clientUuid.toString())
                .issuedAt(createdAt)
                .expiration(expiresAt)
                .signWith(jwtSecretKey)
                .compact();
        return token;
    }

    public RefreshTokenBLM getRefreshToken(String token) {
        Jws<Claims> jws = Jwts.parser()
                .verifyWith(jwtSecretKey)
                .build()
                .parseSignedClaims(token);

        Claims claims = jws.getPayload();

        UUID uid = UUID.fromString(claims.get("uid", String.class));
        UUID clientUid = UUID.fromString(claims.get("clientUid", String.class));
        Date issuedAt = claims.getIssuedAt();
        Date expiration = claims.getExpiration();

        if (!jwtSubjecString.equals(claims.getSubject())) {
            throw new RuntimeException("Invalid token subject");
        }

        return new RefreshTokenBLM(token, uid, clientUid, issuedAt, expiration);
    }
}
package com.connection.token.converter;

import com.connection.token.generator.AccessTokenGenerator;
import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.AccessTokenDALM;
import com.connection.token.model.AccessTokenDTO;

import io.jsonwebtoken.JwtException;
import lombok.NonNull;
import lombok.RequiredArgsConstructor;

@RequiredArgsConstructor
public class AccessTokenConverter {
    @NonNull
    private final AccessTokenGenerator accessTokenGenerator;

    public AccessTokenBLM toBLM(AccessTokenDALM dalm) {
        try {
            String token = accessTokenGenerator.generateAccessToken(dalm.getClientUID(), dalm.getCreatedAt(),
                    dalm.getExpiresAt());
            return new AccessTokenBLM(token,
                    dalm.getClientUID(),
                    dalm.getCreatedAt(),
                    dalm.getExpiresAt());
        } catch (JwtException e) {
            throw new RuntimeException("Invalid JWT token: " + e.getMessage(), e);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException("Malformed JWT token", e);
        }
    }

    public AccessTokenBLM toBLM(AccessTokenDTO dto) {
        try {
            AccessTokenBLM blm = accessTokenGenerator.getAccessTokenBLM(dto.getToken());
            return blm;
        } catch (JwtException e) {
            throw new RuntimeException("Invalid JWT token: " + e.getMessage(), e);
        } catch (IllegalArgumentException e) {
            throw new RuntimeException("Malformed JWT token", e);
        }
    }

    public AccessTokenDTO toDTO(AccessTokenBLM blm) {
        return new AccessTokenDTO(blm.getToken());
    }

    public AccessTokenDALM toDALM(AccessTokenBLM blm) {
        return new AccessTokenDALM(blm.getClientUID(), blm.getCreatedAt(), blm.getExpiresAt());
    }
}
package com.connection.token.model;

import java.util.Date;
import java.util.UUID;

import jakarta.persistence.Entity;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Entity
@Builder
public class AccessTokenDALM {
    protected UUID clientUID;
    protected Date createdAt;
    protected Date expiresAt;
}
