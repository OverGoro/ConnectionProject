// Исключения для Message
package com.connection.message.exception;

public class MessageAddException extends BaseMessageException {
    public MessageAddException(String messageString) {
        super(messageString);
    }

    public String toString() {
        String res = super.toString();
        res += "\n" + "description: cannot add message";
        return res;
    }
}package com.connection.message.exception;

public class BaseMessageException extends RuntimeException {
    private final String messageString;

    public BaseMessageException(String messageDescription) {
        super("message");
        messageString = messageDescription;
    }

    public String toString() {
        String res = super.toString();
        res += "\n" + "message: " + messageString;
        return res;
    }
}package com.connection.message.exception;

public class MessageValidateException extends BaseMessageException {
    String descriptionString;
    
    public MessageValidateException(String messageString, String description) {
        super(messageString);
        this.descriptionString = description;
    }

    public String toString() {
        String res = super.toString();
        res += "\n" + "description: message is invalid";
        res += "\n" + descriptionString;
        return res;
    }
}package com.connection.message.exception;

public class MessageNotFoundException extends BaseMessageException {
    public MessageNotFoundException(String messageString) {
        super(messageString);
    }

    public String toString() {
        String res = super.toString();
        res += "\n" + "description: message not found";
        return res;
    }
}
package com.connection.message.exception;

public class MessageRoutingException extends BaseMessageException {
    public MessageRoutingException(String messageString) {
        super(messageString);
    }

    public String toString() {
        String res = super.toString();
        res += "\n" + "description: cannot route message";
        return res;
    }
}package com.connection.message.model;

import java.util.Date;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Builder
@EqualsAndHashCode
public class MessageDTO {
    protected UUID uid;
    protected UUID bufferUid;
    protected String content;
    protected String contentType;
    protected Date createdAt;
}// Модели данных
package com.connection.message.model;

import java.util.Date;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Builder
@EqualsAndHashCode
public class MessageDALM {
    protected UUID uid;
    protected UUID bufferUid;
    protected String content;
    protected String contentType;
    protected Date createdAt;
}package com.connection.message.model;

import java.util.Date;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Builder
@EqualsAndHashCode
public class MessageBLM {
    protected UUID uid;
    protected UUID bufferUid;
    protected String content;
    protected String contentType;
    protected Date createdAt;
}
package com.connection.message.model;

public enum MessageStatus {
    PENDING,
    PROCESSED,
    FAILED,
    DELIVERED
}
package com.connection.message.model;

public enum MessageDirection {
    INCOMING,
    OUTGOING
}// Конвертер
package com.connection.message.converter;

import org.springframework.stereotype.Component;

import com.connection.message.model.MessageBLM;
import com.connection.message.model.MessageDALM;
import com.connection.message.model.MessageDTO;

import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class MessageConverter {
    public MessageBLM toBLM(MessageDTO dto) {
        return new MessageBLM(dto.getUid(), dto.getBufferUid(), dto.getContent(), dto.getContentType(), dto.getCreatedAt());
    }
    
    public MessageBLM toBLM(MessageDALM dalm) {
        return new MessageBLM(dalm.getUid(), dalm.getBufferUid(), dalm.getContent(), dalm.getContentType(), dalm.getCreatedAt());
    }
    
    public MessageDTO toDTO(MessageBLM blm) {
        return new MessageDTO(blm.getUid(), blm.getBufferUid(), blm.getContent(), blm.getContentType(), blm.getCreatedAt());
    }
    
    public MessageDALM toDALM(MessageBLM blm) {
        return new MessageDALM(blm.getUid(), blm.getBufferUid(), blm.getContent(), blm.getContentType(), blm.getCreatedAt());
    }
}// Валидатор
package com.connection.message.validator;

import com.connection.message.exception.MessageValidateException;
import com.connection.message.model.MessageBLM;
import com.connection.message.model.MessageDALM;
import com.connection.message.model.MessageDTO;

import java.util.Date;
import java.util.UUID;

public class MessageValidator {

    public void validate(MessageDTO message) {
        if (message == null) {
            throw new MessageValidateException("null", "Message cannot be null");
        }
        try {
            validateUid(message.getUid());
            validateBufferUid(message.getBufferUid());
            validateContent(message.getContent());
            validateContentType(message.getContentType());
            validateCreatedAt(message.getCreatedAt());
        } catch (IllegalArgumentException e) {
            if (message.getUid() != null)
                throw new MessageValidateException(message.getUid().toString(), e.getMessage());
            else
                throw new MessageValidateException("null", e.getMessage());
        }
    }

    public void validate(MessageBLM message) {
        if (message == null) {
            throw new MessageValidateException("null", "Message cannot be null.");
        }
        try {
            validateUid(message.getUid());
            validateBufferUid(message.getBufferUid());
            validateContent(message.getContent());
            validateContentType(message.getContentType());
            validateCreatedAt(message.getCreatedAt());
        } catch (IllegalArgumentException e) {
            if (message.getUid() != null)
                throw new MessageValidateException(message.getUid().toString(), e.getMessage());
            else
                throw new MessageValidateException("null", e.getMessage());
        }
    }

    public void validate(MessageDALM message) {
        if (message == null) {
            throw new MessageValidateException("null", "Message cannot be null");
        }
        try {
            validateUid(message.getUid());
            validateBufferUid(message.getBufferUid());
            validateContent(message.getContent());
            validateContentType(message.getContentType());
            validateCreatedAt(message.getCreatedAt());
        } catch (IllegalArgumentException e) {
            if (message.getUid() != null)
                throw new MessageValidateException(message.getUid().toString(), e.getMessage());
            else
                throw new MessageValidateException("null", e.getMessage());
        }
    }

    public void validateUid(UUID uid) {
        if (uid == null) {
            throw new IllegalArgumentException("Message UID cannot be null");
        }
    }

    public void validateBufferUid(UUID bufferUid) {
        if (bufferUid == null) {
            throw new IllegalArgumentException("Buffer UID cannot be null");
        }
    }

    public void validateContent(String content) {
        if (content == null || content.trim().isEmpty()) {
            throw new IllegalArgumentException("Content cannot be empty");
        }
        if (content.length() > 10000) { // Пример ограничения
            throw new IllegalArgumentException("Content too long (max 10000 chars)");
        }
    }

    public void validateContentType(String contentType) {
        if (contentType == null || contentType.trim().isEmpty()) {
            throw new IllegalArgumentException("Content type cannot be empty");
        }
        if (contentType.length() > 100) {
            throw new IllegalArgumentException("Content type too long (max 100 chars)");
        }
    }

    public void validateCreatedAt(Date createdAt) {
        if (createdAt == null) {
            throw new IllegalArgumentException("Created at date cannot be null");
        }
        
        Date now = new Date();
        if (createdAt.after(now)) {
            throw new IllegalArgumentException("Created at date cannot be in the future");
        }
    }
}// Реализация репозитория SQL
package com.connection.message.repository;

import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import java.sql.Timestamp;
import java.util.Date;
import java.util.List;
import java.util.UUID;

import com.connection.message.exception.MessageAddException;
import com.connection.message.exception.MessageNotFoundException;
import com.connection.message.model.MessageDALM;

import org.springframework.transaction.annotation.Transactional;

public class MessageRepositorySQLImpl implements MessageRepository {

    private static final String SELECT_MESSAGE = "SELECT uid, buffer_uid, content, content_type, created_at";

    private static final String SELECT_MESSAGE_BY_UID = SELECT_MESSAGE +
            " FROM processing.message WHERE uid = :uid";

    private static final String SELECT_MESSAGES_BY_BUFFER_UID = SELECT_MESSAGE +
            " FROM processing.message WHERE buffer_uid = :buffer_uid ORDER BY created_at DESC";

    private static final String SELECT_MESSAGES_BY_BUFFER_UID_AND_TIME_RANGE = SELECT_MESSAGE +
            " FROM processing.message WHERE buffer_uid = :buffer_uid AND created_at BETWEEN :start_time AND :end_time ORDER BY created_at DESC";

    private static final String INSERT_MESSAGE = "INSERT INTO processing.message (uid, buffer_uid, content, content_type, created_at) " +
            "VALUES (:uid, :buffer_uid, :content, :content_type, :created_at)";

    private static final String DELETE_MESSAGE_BY_UID = "DELETE FROM processing.message WHERE uid = :uid";

    private static final String DELETE_MESSAGES_BY_BUFFER_UID = "DELETE FROM processing.message WHERE buffer_uid = :buffer_uid";

    private final NamedParameterJdbcTemplate jdbcTemplate;

    private final RowMapper<MessageDALM> messageRowMapper = (rs, rowNum) -> {
        MessageDALM message = new MessageDALM();
        message.setUid(UUID.fromString(rs.getString("uid")));
        message.setBufferUid(UUID.fromString(rs.getString("buffer_uid")));
        message.setContent(rs.getString("content"));
        message.setContentType(rs.getString("content_type"));
        message.setCreatedAt(new Date(rs.getTimestamp("created_at").getTime()));
        return message;
    };

    public MessageRepositorySQLImpl(NamedParameterJdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    @Transactional
    public void add(MessageDALM messageDALM) throws MessageAddException {
        try {
            MapSqlParameterSource params = new MapSqlParameterSource();
            params.addValue("uid", messageDALM.getUid() != null ? messageDALM.getUid() : UUID.randomUUID());
            params.addValue("buffer_uid", messageDALM.getBufferUid());
            params.addValue("content", messageDALM.getContent());
            params.addValue("content_type", messageDALM.getContentType());
            params.addValue("created_at", 
                messageDALM.getCreatedAt() != null ? new Timestamp(messageDALM.getCreatedAt().getTime()) : new Timestamp(System.currentTimeMillis()));

            jdbcTemplate.update(INSERT_MESSAGE, params);
        } catch (Exception e) {
            throw new MessageAddException("Failed to add message: " + e.getMessage());
        }
    }

    @Override
    @Transactional
    public MessageDALM findByUid(UUID uuid) throws MessageNotFoundException {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", uuid);
        try {
            return jdbcTemplate.queryForObject(SELECT_MESSAGE_BY_UID, params, messageRowMapper);
        } catch (EmptyResultDataAccessException e) {
            throw new MessageNotFoundException("Message with UID " + uuid + " not found");
        }
    }

    @Override
    @Transactional
    public List<MessageDALM> findByBufferUid(UUID bufferUid) throws MessageNotFoundException {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("buffer_uid", bufferUid);
        try {
            List<MessageDALM> messages = jdbcTemplate.query(SELECT_MESSAGES_BY_BUFFER_UID, params, messageRowMapper);
            if (messages.isEmpty()) {
                throw new MessageNotFoundException("No messages found for buffer UID " + bufferUid);
            }
            return messages;
        } catch (EmptyResultDataAccessException e) {
            throw new MessageNotFoundException("No messages found for buffer UID " + bufferUid);
        }
    }

    @Override
    @Transactional
    public List<MessageDALM> findByBufferUidAndTimeRange(UUID bufferUid, Date startTime, Date endTime) throws MessageNotFoundException {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("buffer_uid", bufferUid);
        params.addValue("start_time", new Timestamp(startTime.getTime()));
        params.addValue("end_time", new Timestamp(endTime.getTime()));
        
        try {
            List<MessageDALM> messages = jdbcTemplate.query(SELECT_MESSAGES_BY_BUFFER_UID_AND_TIME_RANGE, params, messageRowMapper);
            if (messages.isEmpty()) {
                throw new MessageNotFoundException("No messages found for buffer UID " + bufferUid + " in specified time range");
            }
            return messages;
        } catch (EmptyResultDataAccessException e) {
            throw new MessageNotFoundException("No messages found for buffer UID " + bufferUid + " in specified time range");
        }
    }

    @Override
    @Transactional
    public void deleteByUid(UUID uuid) throws MessageNotFoundException {
        // Проверяем существование сообщения перед удалением
        findByUid(uuid);

        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", uuid);

        jdbcTemplate.update(DELETE_MESSAGE_BY_UID, params);
    }

    @Override
    @Transactional
    public void deleteByBufferUid(UUID bufferUid) throws MessageNotFoundException {
        // Проверяем существование сообщений перед удалением
        findByBufferUid(bufferUid);

        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("buffer_uid", bufferUid);

        jdbcTemplate.update(DELETE_MESSAGES_BY_BUFFER_UID, params);
    }
}// Репозиторий (интерфейс)
package com.connection.message.repository;

import java.util.Date;
import java.util.List;
import java.util.UUID;

import com.connection.message.exception.MessageAddException;
import com.connection.message.exception.MessageNotFoundException;
import com.connection.message.model.MessageDALM;

public interface MessageRepository {
    public void add(MessageDALM messageDALM)
            throws MessageAddException;

    public MessageDALM findByUid(UUID uuid)
            throws MessageNotFoundException;

    public List<MessageDALM> findByBufferUid(UUID bufferUid)
            throws MessageNotFoundException;

    public List<MessageDALM> findByBufferUidAndTimeRange(UUID bufferUid, Date startTime, Date endTime)
            throws MessageNotFoundException;

    public void deleteByUid(UUID uuid)
            throws MessageNotFoundException;

    public void deleteByBufferUid(UUID bufferUid)
            throws MessageNotFoundException;
}// Object Mother для тестов
package com.connection.message.mother;

import java.util.Date;
import java.util.UUID;

import com.connection.message.model.MessageBLM;
import com.connection.message.model.MessageDALM;
import com.connection.message.model.MessageDTO;

public class MessageObjectMother {

    private static final UUID DEFAULT_UID = UUID.fromString("123e4567-e89b-12d3-a456-426614174001");
    private static final UUID DEFAULT_BUFFER_UID = UUID.fromString("223e4567-e89b-12d3-a456-426614174002");
    private static final String DEFAULT_CONTENT = "{\"type\":\"test\",\"data\":\"sample data\"}";
    private static final String DEFAULT_CONTENT_TYPE = "application/json";
    private static final Date DEFAULT_CREATED_AT = new Date(System.currentTimeMillis() - 1000L * 60 * 60); // 1 hour ago

    public static MessageDTO createValidMessageDTO() {
        return MessageDTO.builder()
                .uid(DEFAULT_UID)
                .bufferUid(DEFAULT_BUFFER_UID)
                .content(DEFAULT_CONTENT)
                .contentType(DEFAULT_CONTENT_TYPE)
                .createdAt(DEFAULT_CREATED_AT)
                .build();
    }

    public static MessageBLM createValidMessageBLM() {
        return MessageBLM.builder()
                .uid(DEFAULT_UID)
                .bufferUid(DEFAULT_BUFFER_UID)
                .content(DEFAULT_CONTENT)
                .contentType(DEFAULT_CONTENT_TYPE)
                .createdAt(DEFAULT_CREATED_AT)
                .build();
    }

    public static MessageDALM createValidMessageDALM() {
        return MessageDALM.builder()
                .uid(DEFAULT_UID)
                .bufferUid(DEFAULT_BUFFER_UID)
                .content(DEFAULT_CONTENT)
                .contentType(DEFAULT_CONTENT_TYPE)
                .createdAt(DEFAULT_CREATED_AT)
                .build();
    }

    public static MessageDTO createMessageDTOWithInvalidContent() {
        return MessageDTO.builder()
                .uid(DEFAULT_UID)
                .bufferUid(DEFAULT_BUFFER_UID)
                .content("") // Пустой контент
                .contentType(DEFAULT_CONTENT_TYPE)
                .createdAt(DEFAULT_CREATED_AT)
                .build();
    }

    public static MessageDTO createMessageDTOWithFutureDate() {
        return MessageDTO.builder()
                .uid(DEFAULT_UID)
                .bufferUid(DEFAULT_BUFFER_UID)
                .content(DEFAULT_CONTENT)
                .contentType(DEFAULT_CONTENT_TYPE)
                .createdAt(new Date(System.currentTimeMillis() + 1000L * 60 * 60)) // Будущее время
                .build();
    }

    public static MessageDTO createMessageDTOWithNullFields() {
        return MessageDTO.builder()
                .uid(null)
                .bufferUid(null)
                .content(null)
                .contentType(null)
                .createdAt(null)
                .build();
    }

    public static MessageDALM createMessageForBuffer(UUID bufferUid) {
        return MessageDALM.builder()
                .uid(UUID.randomUUID())
                .bufferUid(bufferUid)
                .content("{\"buffer\":\"" + bufferUid + "\",\"data\":\"test data\"}")
                .contentType(DEFAULT_CONTENT_TYPE)
                .createdAt(new Date())
                .build();
    }

    public static MessageDALM createMessageWithContentType(String contentType) {
        return MessageDALM.builder()
                .uid(UUID.randomUUID())
                .bufferUid(DEFAULT_BUFFER_UID)
                .content("{\"type\":\"custom\",\"contentType\":\"" + contentType + "\"}")
                .contentType(contentType)
                .createdAt(new Date())
                .build();
    }
}