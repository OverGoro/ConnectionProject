// Исключения для Message
package com.connection.message.exception;

public class MessageAddException extends BaseMessageException {
    public MessageAddException(String messageString) {
        super(messageString);
    }

    public String toString() {
        String res = super.toString();
        res += "\n" + "description: cannot add message";
        return res;
    }
}package com.connection.message.exception;

public class BaseMessageException extends RuntimeException {
    private final String messageString;

    public BaseMessageException(String messageDescription) {
        super("message");
        messageString = messageDescription;
    }

    public String toString() {
        String res = super.toString();
        res += "\n" + "message: " + messageString;
        return res;
    }
}package com.connection.message.exception;

public class MessageValidateException extends BaseMessageException {
    String descriptionString;
    
    public MessageValidateException(String messageString, String description) {
        super(messageString);
        this.descriptionString = description;
    }

    public String toString() {
        String res = super.toString();
        res += "\n" + "description: message is invalid";
        res += "\n" + descriptionString;
        return res;
    }
}package com.connection.message.exception;

public class MessageNotFoundException extends BaseMessageException {
    public MessageNotFoundException(String messageString) {
        super(messageString);
    }

    public String toString() {
        String res = super.toString();
        res += "\n" + "description: message not found";
        return res;
    }
}// MessageRoutingException.java
package com.connection.message.exception;

public class MessageRoutingException extends BaseMessageException {
    public MessageRoutingException(String messageString) {
        super(messageString);
    }

    public String toString() {
        String res = super.toString();
        res += "\n" + "description: cannot route message";
        return res;
    }
}package com.connection.message.model;

import java.util.Date;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Builder
@EqualsAndHashCode
public class MessageDTO {
    protected UUID uid;
    protected UUID bufferUid;
    protected String content;
    protected String contentType;
    protected Date createdAt;
}// Модели данных
package com.connection.message.model;

import java.util.Date;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Builder
@EqualsAndHashCode
public class MessageDALM {
    protected UUID uid;
    protected UUID bufferUid;
    protected String content;
    protected String contentType;
    protected Date createdAt;
}package com.connection.message.model;

import java.util.Date;
import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Builder
@EqualsAndHashCode
public class MessageBLM {
    protected UUID uid;
    protected UUID bufferUid;
    protected String content;
    protected String contentType;
    protected Date createdAt;
}// MessageStatus.java
package com.connection.message.model;

public enum MessageStatus {
    PENDING,
    PROCESSED,
    FAILED,
    DELIVERED
}// MessageDirection.java
package com.connection.message.model;

public enum MessageDirection {
    INCOMING,
    OUTGOING
}// Конвертер
package com.connection.message.converter;

import org.springframework.stereotype.Component;

import com.connection.message.model.MessageBLM;
import com.connection.message.model.MessageDALM;
import com.connection.message.model.MessageDTO;

import lombok.RequiredArgsConstructor;

@Component
@RequiredArgsConstructor
public class MessageConverter {
    public MessageBLM toBLM(MessageDTO dto) {
        return new MessageBLM(dto.getUid(), dto.getBufferUid(), dto.getContent(), dto.getContentType(), dto.getCreatedAt());
    }
    
    public MessageBLM toBLM(MessageDALM dalm) {
        return new MessageBLM(dalm.getUid(), dalm.getBufferUid(), dalm.getContent(), dalm.getContentType(), dalm.getCreatedAt());
    }
    
    public MessageDTO toDTO(MessageBLM blm) {
        return new MessageDTO(blm.getUid(), blm.getBufferUid(), blm.getContent(), blm.getContentType(), blm.getCreatedAt());
    }
    
    public MessageDALM toDALM(MessageBLM blm) {
        return new MessageDALM(blm.getUid(), blm.getBufferUid(), blm.getContent(), blm.getContentType(), blm.getCreatedAt());
    }
}// Валидатор
package com.connection.message.validator;

import com.connection.message.exception.MessageValidateException;
import com.connection.message.model.MessageBLM;
import com.connection.message.model.MessageDALM;
import com.connection.message.model.MessageDTO;

import java.util.Date;
import java.util.UUID;

public class MessageValidator {

    public void validate(MessageDTO message) {
        if (message == null) {
            throw new MessageValidateException("null", "Message cannot be null");
        }
        try {
            validateUid(message.getUid());
            validateBufferUid(message.getBufferUid());
            validateContent(message.getContent());
            validateContentType(message.getContentType());
            validateCreatedAt(message.getCreatedAt());
        } catch (IllegalArgumentException e) {
            if (message.getUid() != null)
                throw new MessageValidateException(message.getUid().toString(), e.getMessage());
            else
                throw new MessageValidateException("null", e.getMessage());
        }
    }

    public void validate(MessageBLM message) {
        if (message == null) {
            throw new MessageValidateException("null", "Message cannot be null.");
        }
        try {
            validateUid(message.getUid());
            validateBufferUid(message.getBufferUid());
            validateContent(message.getContent());
            validateContentType(message.getContentType());
            validateCreatedAt(message.getCreatedAt());
        } catch (IllegalArgumentException e) {
            if (message.getUid() != null)
                throw new MessageValidateException(message.getUid().toString(), e.getMessage());
            else
                throw new MessageValidateException("null", e.getMessage());
        }
    }

    public void validate(MessageDALM message) {
        if (message == null) {
            throw new MessageValidateException("null", "Message cannot be null");
        }
        try {
            validateUid(message.getUid());
            validateBufferUid(message.getBufferUid());
            validateContent(message.getContent());
            validateContentType(message.getContentType());
            validateCreatedAt(message.getCreatedAt());
        } catch (IllegalArgumentException e) {
            if (message.getUid() != null)
                throw new MessageValidateException(message.getUid().toString(), e.getMessage());
            else
                throw new MessageValidateException("null", e.getMessage());
        }
    }

    public void validateUid(UUID uid) {
        if (uid == null) {
            throw new IllegalArgumentException("Message UID cannot be null");
        }
    }

    public void validateBufferUid(UUID bufferUid) {
        if (bufferUid == null) {
            throw new IllegalArgumentException("Buffer UID cannot be null");
        }
    }

    public void validateContent(String content) {
        if (content == null || content.trim().isEmpty()) {
            throw new IllegalArgumentException("Content cannot be empty");
        }
        if (content.length() > 10000) { // Пример ограничения
            throw new IllegalArgumentException("Content too long (max 10000 chars)");
        }
    }

    public void validateContentType(String contentType) {
        if (contentType == null || contentType.trim().isEmpty()) {
            throw new IllegalArgumentException("Content type cannot be empty");
        }
        if (contentType.length() > 100) {
            throw new IllegalArgumentException("Content type too long (max 100 chars)");
        }
    }

    public void validateCreatedAt(Date createdAt) {
        if (createdAt == null) {
            throw new IllegalArgumentException("Created at date cannot be null");
        }
        
        Date now = new Date();
        if (createdAt.after(now)) {
            throw new IllegalArgumentException("Created at date cannot be in the future");
        }
    }
}package com.connection.message.repository;

import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.transaction.annotation.Transactional;

import java.sql.Timestamp;
import java.util.Date;
import java.util.List;
import java.util.UUID;

import com.connection.message.exception.MessageAddException;
import com.connection.message.exception.MessageNotFoundException;
import com.connection.message.model.MessageDALM;

public class MessageRepositorySQLImpl implements MessageRepository {

    private static final String SELECT_MESSAGE = "SELECT uid, buffer_uid, content, content_type, created_at";

    private static final String SELECT_MESSAGE_BY_UID = SELECT_MESSAGE +
            " FROM processing.message WHERE uid = :uid";

    private static final String SELECT_MESSAGES_BY_BUFFER_UID = SELECT_MESSAGE +
            " FROM processing.message WHERE buffer_uid = :buffer_uid ORDER BY created_at DESC";

    private static final String SELECT_MESSAGES_BY_BUFFER_UID_AND_TIME_RANGE = SELECT_MESSAGE +
            " FROM processing.message WHERE buffer_uid = :buffer_uid AND created_at BETWEEN :start_time AND :end_time ORDER BY created_at DESC";

    private static final String INSERT_MESSAGE = "INSERT INTO processing.message (uid, buffer_uid, content, content_type, created_at) "
            +
            "VALUES (:uid, :buffer_uid, :content::jsonb, :content_type, :created_at)";

    private static final String DELETE_MESSAGE_BY_UID = "DELETE FROM processing.message WHERE uid = :uid";

    private static final String DELETE_MESSAGES_BY_BUFFER_UID = "DELETE FROM processing.message WHERE buffer_uid = :buffer_uid";

    private final NamedParameterJdbcTemplate jdbcTemplate;

    private final RowMapper<MessageDALM> messageRowMapper = (rs, rowNum) -> {
        MessageDALM message = new MessageDALM();
        message.setUid(UUID.fromString(rs.getString("uid")));
        message.setBufferUid(UUID.fromString(rs.getString("buffer_uid")));

        // Для чтения JSON из базы
        String contentJson = rs.getString("content");
        message.setContent(contentJson); // или парсинг в объект, если нужно

        message.setContentType(rs.getString("content_type"));
        message.setCreatedAt(new Date(rs.getTimestamp("created_at").getTime()));
        return message;
    };

    public MessageRepositorySQLImpl(NamedParameterJdbcTemplate jdbcTemplate) {
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    @Transactional
    public void add(MessageDALM messageDALM) throws MessageAddException {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", messageDALM.getUid() != null ? messageDALM.getUid() : UUID.randomUUID());
        params.addValue("buffer_uid", messageDALM.getBufferUid());

        // Важно: content должен быть валидным JSON
        String content = messageDALM.getContent();
        if (content == null) {
            content = "{}"; // пустой JSON объект по умолчанию
        }
        params.addValue("content", content);

        params.addValue("content_type", messageDALM.getContentType());
        params.addValue("created_at",
                messageDALM.getCreatedAt() != null ? new Timestamp(messageDALM.getCreatedAt().getTime())
                        : new Timestamp(System.currentTimeMillis()));

        jdbcTemplate.update(INSERT_MESSAGE, params);

    }

    // Остальные методы остаются без изменений
    @Override
    @Transactional
    public MessageDALM findByUid(UUID uuid) throws MessageNotFoundException {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", uuid);
        try {
            return jdbcTemplate.queryForObject(SELECT_MESSAGE_BY_UID, params, messageRowMapper);
        } catch (EmptyResultDataAccessException e) {
            throw new MessageNotFoundException("Message with UID " + uuid + " not found");
        }
    }

    @Override
    @Transactional
    public List<MessageDALM> findByBufferUid(UUID bufferUid) throws MessageNotFoundException {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("buffer_uid", bufferUid);
        try {
            List<MessageDALM> messages = jdbcTemplate.query(SELECT_MESSAGES_BY_BUFFER_UID, params, messageRowMapper);
            if (messages.isEmpty()) {
                throw new MessageNotFoundException("No messages found for buffer UID " + bufferUid);
            }
            return messages;
        } catch (EmptyResultDataAccessException e) {
            throw new MessageNotFoundException("No messages found for buffer UID " + bufferUid);
        }
    }

    @Override
    @Transactional
    public List<MessageDALM> findByBufferUidAndTimeRange(UUID bufferUid, Date startTime, Date endTime)
            throws MessageNotFoundException {
        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("buffer_uid", bufferUid);
        params.addValue("start_time", new Timestamp(startTime.getTime()));
        params.addValue("end_time", new Timestamp(endTime.getTime()));

        try {
            List<MessageDALM> messages = jdbcTemplate.query(SELECT_MESSAGES_BY_BUFFER_UID_AND_TIME_RANGE, params,
                    messageRowMapper);
            if (messages.isEmpty()) {
                throw new MessageNotFoundException(
                        "No messages found for buffer UID " + bufferUid + " in specified time range");
            }
            return messages;
        } catch (EmptyResultDataAccessException e) {
            throw new MessageNotFoundException(
                    "No messages found for buffer UID " + bufferUid + " in specified time range");
        }
    }

    @Override
    @Transactional
    public void deleteByUid(UUID uuid) throws MessageNotFoundException {
        // Проверяем существование сообщения перед удалением
        findByUid(uuid);

        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("uid", uuid);

        jdbcTemplate.update(DELETE_MESSAGE_BY_UID, params);
    }

    @Override
    @Transactional
    public void deleteByBufferUid(UUID bufferUid) throws MessageNotFoundException {
        // Проверяем существование сообщений перед удалением
        findByBufferUid(bufferUid);

        MapSqlParameterSource params = new MapSqlParameterSource();
        params.addValue("buffer_uid", bufferUid);

        jdbcTemplate.update(DELETE_MESSAGES_BY_BUFFER_UID, params);
    }
}// Репозиторий (интерфейс)
package com.connection.message.repository;

import java.util.Date;
import java.util.List;
import java.util.UUID;

import com.connection.message.exception.MessageAddException;
import com.connection.message.exception.MessageNotFoundException;
import com.connection.message.model.MessageDALM;

public interface MessageRepository {
    public void add(MessageDALM messageDALM)
            throws MessageAddException;

    public MessageDALM findByUid(UUID uuid)
            throws MessageNotFoundException;

    public List<MessageDALM> findByBufferUid(UUID bufferUid)
            throws MessageNotFoundException;

    public List<MessageDALM> findByBufferUidAndTimeRange(UUID bufferUid, Date startTime, Date endTime)
            throws MessageNotFoundException;

    public void deleteByUid(UUID uuid)
            throws MessageNotFoundException;

    public void deleteByBufferUid(UUID bufferUid)
            throws MessageNotFoundException;
}package com.connection.message.exception;

import static org.assertj.core.api.Assertions.assertThat;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Message Exception Tests")
class MessageExceptionTest {

    @Test
    @DisplayName("BaseMessageException toString format")
    void testBaseMessageExceptionToString() {
        String messageUid = "test-message-123";
        BaseMessageException exception = new BaseMessageException(messageUid);
        String result = exception.toString();
        assertThat(result).contains(messageUid);
    }

    @Test
    @DisplayName("MessageValidateException toString format")
    void testMessageValidateExceptionToString() {
        String messageUid = "test-message-456";
        String description = "Validation failed";
        MessageValidateException exception = new MessageValidateException(messageUid, description);
        String result = exception.toString();
        assertThat(result).contains(messageUid);
        assertThat(result).contains(description);
    }

    @Test
    @DisplayName("MessageAddException toString format")
    void testMessageAddExceptionToString() {
        String messageUid = "test-message-789";
        MessageAddException exception = new MessageAddException(messageUid);
        String result = exception.toString();
        assertThat(result).contains(messageUid);
    }

    @Test
    @DisplayName("MessageNotFoundException toString format")
    void testMessageNotFoundExceptionToString() {
        String messageUid = "test-message-012";
        MessageNotFoundException exception = new MessageNotFoundException(messageUid);
        String result = exception.toString();
        assertThat(result).contains(messageUid);
    }

    @Test
    @DisplayName("Exception inheritance hierarchy")
    void testExceptionInheritance() {
        MessageValidateException validateException = new MessageValidateException("uid", "desc");
        MessageAddException addException = new MessageAddException("uid");
        MessageNotFoundException notFoundException = new MessageNotFoundException("uid");

        assertThat(validateException).isInstanceOf(BaseMessageException.class);
        assertThat(addException).isInstanceOf(BaseMessageException.class);
        assertThat(notFoundException).isInstanceOf(BaseMessageException.class);
        assertThat(validateException).isInstanceOf(RuntimeException.class);
    }
}package com.connection.message.converter;

import static com.connection.message.mother.MessageObjectMother.*;
import static org.assertj.core.api.Assertions.assertThat;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

import com.connection.message.model.MessageBLM;
import com.connection.message.model.MessageDALM;
import com.connection.message.model.MessageDTO;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Message Converter Tests")
class  MessageConverterTest{

    private MessageConverter converter;

    @BeforeEach
    void setUp() {
        converter = new MessageConverter();
    }

    @Test
    @DisplayName("Convert DTO to BLM - Positive")
    void testToBLMFromDTO_Positive() {
        MessageDTO dto = createValidMessageDTO();
        MessageBLM result = converter.toBLM(dto);
        assertThat(result).isNotNull();
        assertThat(result.getUid()).isEqualTo(dto.getUid());
        assertThat(result.getBufferUid()).isEqualTo(dto.getBufferUid());
        assertThat(result.getContent()).isEqualTo(dto.getContent());
        assertThat(result.getContentType()).isEqualTo(dto.getContentType());
        assertThat(result.getCreatedAt()).isEqualTo(dto.getCreatedAt());
    }

    @Test
    @DisplayName("Convert DALM to BLM - Positive")
    void testToBLMFromDALM_Positive() {
        MessageDALM dalM = createValidMessageDALM();
        MessageBLM result = converter.toBLM(dalM);
        assertThat(result).isNotNull();
        assertThat(result.getUid()).isEqualTo(dalM.getUid());
        assertThat(result.getBufferUid()).isEqualTo(dalM.getBufferUid());
        assertThat(result.getContent()).isEqualTo(dalM.getContent());
        assertThat(result.getContentType()).isEqualTo(dalM.getContentType());
        assertThat(result.getCreatedAt()).isEqualTo(dalM.getCreatedAt());
    }

    @Test
    @DisplayName("Convert BLM to DTO - Positive")
    void testToDTOFromBLM_Positive() {
        MessageBLM blm = createValidMessageBLM();
        MessageDTO result = converter.toDTO(blm);
        assertThat(result).isNotNull();
        assertThat(result.getUid()).isEqualTo(blm.getUid());
        assertThat(result.getBufferUid()).isEqualTo(blm.getBufferUid());
        assertThat(result.getContent()).isEqualTo(blm.getContent());
        assertThat(result.getContentType()).isEqualTo(blm.getContentType());
        assertThat(result.getCreatedAt()).isEqualTo(blm.getCreatedAt());
    }

    @Test
    @DisplayName("Convert BLM to DALM - Positive")
    void testToDALMFromBLM_Positive() {
        MessageBLM blm = createValidMessageBLM();
        MessageDALM result = converter.toDALM(blm);
        assertThat(result).isNotNull();
        assertThat(result.getUid()).isEqualTo(blm.getUid());
        assertThat(result.getBufferUid()).isEqualTo(blm.getBufferUid());
        assertThat(result.getContent()).isEqualTo(blm.getContent());
        assertThat(result.getContentType()).isEqualTo(blm.getContentType());
        assertThat(result.getCreatedAt()).isEqualTo(blm.getCreatedAt());
    }

    @Test
    @DisplayName("Round-trip conversion DTO -> BLM -> DTO")
    void testRoundTripDTOToBLMToDTO() {
        MessageDTO original = createValidMessageDTO();
        MessageBLM blm = converter.toBLM(original);
        MessageDTO result = converter.toDTO(blm);
        assertThat(result).isNotNull();
        assertThat(result.getUid()).isEqualTo(original.getUid());
        assertThat(result.getBufferUid()).isEqualTo(original.getBufferUid());
        assertThat(result.getContent()).isEqualTo(original.getContent());
        assertThat(result.getContentType()).isEqualTo(original.getContentType());
        assertThat(result.getCreatedAt()).isEqualTo(original.getCreatedAt());
    }

    @Test
    @DisplayName("Round-trip conversion DALM -> BLM -> DALM")
    void testRoundTripDALMToBLMToDALM() {
        MessageDALM original = createValidMessageDALM();
        MessageBLM blm = converter.toBLM(original);
        MessageDALM result = converter.toDALM(blm);
        assertThat(result).isNotNull();
        assertThat(result.getUid()).isEqualTo(original.getUid());
        assertThat(result.getBufferUid()).isEqualTo(original.getBufferUid());
        assertThat(result.getContent()).isEqualTo(original.getContent());
        assertThat(result.getContentType()).isEqualTo(original.getContentType());
        assertThat(result.getCreatedAt()).isEqualTo(original.getCreatedAt());
    }
}package com.connection.message.validator;

import static com.connection.message.mother.MessageObjectMother.*;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

import java.util.Date;
import java.util.UUID;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;

import com.connection.message.exception.MessageValidateException;
import com.connection.message.model.MessageBLM;
import com.connection.message.model.MessageDALM;
import com.connection.message.model.MessageDTO;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Message Validator Tests")
class MessageValidatorTest {

    private MessageValidator validator;

    @BeforeEach
    void setUp() {
        validator = new MessageValidator();
    }

    @Test
    @DisplayName("Validate valid MessageDTO - Positive")
    void testValidateMessageDTO_Positive() {
        MessageDTO message = createValidMessageDTO();
        assertThat(message).isNotNull();
        validator.validate(message);
    }

    @Test
    @DisplayName("Validate valid MessageBLM - Positive")
    void testValidateMessageBLM_Positive() {
        MessageBLM message = createValidMessageBLM();
        assertThat(message).isNotNull();
        validator.validate(message);
    }

    @Test
    @DisplayName("Validate valid MessageDALM - Positive")
    void testValidateMessageDALM_Positive() {
        MessageDALM message = createValidMessageDALM();
        assertThat(message).isNotNull();
        validator.validate(message);
    }

    @Test
    @DisplayName("Validate null MessageDTO - Negative")
    void testValidateNullMessageDTO_Negative() {
        MessageDTO message = null;
        assertThatThrownBy(() -> validator.validate(message))
                .isInstanceOf(MessageValidateException.class);
    }

    @Test
    @DisplayName("Validate MessageDTO with invalid content - Negative")
    void testValidateMessageDTOWithInvalidContent_Negative() {
        MessageDTO message = createMessageDTOWithInvalidContent();
        assertThatThrownBy(() -> validator.validate(message))
                .isInstanceOf(MessageValidateException.class);
    }

    @Test
    @DisplayName("Validate MessageDTO with future date - Negative")
    void testValidateMessageDTOWithFutureDate_Negative() {
        MessageDTO message = createMessageDTOWithFutureDate();
        assertThatThrownBy(() -> validator.validate(message))
                .isInstanceOf(MessageValidateException.class);
    }

    @Test
    @DisplayName("Validate null MessageBLM - Negative")
    void testValidateNullMessageBLM_Negative() {
        MessageBLM message = null;
        assertThatThrownBy(() -> validator.validate(message))
                .isInstanceOf(MessageValidateException.class);
    }

    @Test
    @DisplayName("Validate MessageDTO with null fields - Negative")
    void testValidateMessageDTOWithNullFields_Negative() {
        MessageDTO message = createMessageDTOWithNullFields();
        assertThatThrownBy(() -> validator.validate(message))
                .isInstanceOf(MessageValidateException.class);
    }

    @Test
    @DisplayName("Validate MessageDTO with empty content - Negative")
    void testValidateMessageDTOWithEmptyContent_Negative() {
        MessageDTO message = MessageDTO.builder()
                .uid(UUID.randomUUID())
                .bufferUid(UUID.randomUUID())
                .content("")
                .contentType("application/json")
                .createdAt(new Date())
                .build();
        assertThatThrownBy(() -> validator.validate(message))
                .isInstanceOf(MessageValidateException.class);
    }

    @Test
    @DisplayName("Validate MessageDTO with long content - Negative")
    void testValidateMessageDTOWithLongContent_Negative() {
        String longContent = "a".repeat(10001);
        MessageDTO message = MessageDTO.builder()
                .uid(UUID.randomUUID())
                .bufferUid(UUID.randomUUID())
                .content(longContent)
                .contentType("application/json")
                .createdAt(new Date())
                .build();
        assertThatThrownBy(() -> validator.validate(message))
                .isInstanceOf(MessageValidateException.class);
    }

    @Test
    @DisplayName("Validate MessageDTO with null buffer UID - Negative")
    void testValidateMessageDTOWithNullBufferUid_Negative() {
        MessageDTO message = MessageDTO.builder()
                .uid(UUID.randomUUID())
                .bufferUid(null)
                .content("{\"test\":\"data\"}")
                .contentType("application/json")
                .createdAt(new Date())
                .build();
        assertThatThrownBy(() -> validator.validate(message))
                .isInstanceOf(MessageValidateException.class);
    }

    @Test
    @DisplayName("Validate MessageDTO with null content type - Negative")
    void testValidateMessageDTOWithNullContentType_Negative() {
        MessageDTO message = MessageDTO.builder()
                .uid(UUID.randomUUID())
                .bufferUid(UUID.randomUUID())
                .content("{\"test\":\"data\"}")
                .contentType(null)
                .createdAt(new Date())
                .build();
        assertThatThrownBy(() -> validator.validate(message))
                .isInstanceOf(MessageValidateException.class);
    }

    @Test
    @DisplayName("Validate MessageDTO with long content type - Negative")
    void testValidateMessageDTOWithLongContentType_Negative() {
        String longContentType = "a".repeat(101);
        MessageDTO message = MessageDTO.builder()
                .uid(UUID.randomUUID())
                .bufferUid(UUID.randomUUID())
                .content("{\"test\":\"data\"}")
                .contentType(longContentType)
                .createdAt(new Date())
                .build();
        assertThatThrownBy(() -> validator.validate(message))
                .isInstanceOf(MessageValidateException.class);
    }

    @Test
    @DisplayName("Validate MessageDTO with null created at - Negative")
    void testValidateMessageDTOWithNullCreatedAt_Negative() {
        MessageDTO message = MessageDTO.builder()
                .uid(UUID.randomUUID())
                .bufferUid(UUID.randomUUID())
                .content("{\"test\":\"data\"}")
                .contentType("application/json")
                .createdAt(null)
                .build();
        assertThatThrownBy(() -> validator.validate(message))
                .isInstanceOf(MessageValidateException.class);
    }
}// Object Mother для тестов
package com.connection.message.mother;

import java.util.Date;
import java.util.UUID;

import com.connection.message.model.MessageBLM;
import com.connection.message.model.MessageDALM;
import com.connection.message.model.MessageDTO;

public class MessageObjectMother {

    private static final UUID DEFAULT_UID = UUID.fromString("123e4567-e89b-12d3-a456-426614174001");
    private static final UUID DEFAULT_BUFFER_UID = UUID.fromString("223e4567-e89b-12d3-a456-426614174002");
    private static final String DEFAULT_CONTENT = "{\"type\":\"test\",\"data\":\"sample data\"}";
    private static final String DEFAULT_CONTENT_TYPE = "application/json";
    private static final Date DEFAULT_CREATED_AT = new Date(System.currentTimeMillis() - 1000L * 60 * 60); // 1 hour ago

    public static MessageDTO createValidMessageDTO() {
        return MessageDTO.builder()
                .uid(DEFAULT_UID)
                .bufferUid(DEFAULT_BUFFER_UID)
                .content(DEFAULT_CONTENT)
                .contentType(DEFAULT_CONTENT_TYPE)
                .createdAt(DEFAULT_CREATED_AT)
                .build();
    }

    public static MessageBLM createValidMessageBLM() {
        return MessageBLM.builder()
                .uid(DEFAULT_UID)
                .bufferUid(DEFAULT_BUFFER_UID)
                .content(DEFAULT_CONTENT)
                .contentType(DEFAULT_CONTENT_TYPE)
                .createdAt(DEFAULT_CREATED_AT)
                .build();
    }

    public static MessageDALM createValidMessageDALM() {
        return MessageDALM.builder()
                .uid(DEFAULT_UID)
                .bufferUid(DEFAULT_BUFFER_UID)
                .content(DEFAULT_CONTENT)
                .contentType(DEFAULT_CONTENT_TYPE)
                .createdAt(DEFAULT_CREATED_AT)
                .build();
    }

    public static MessageDTO createMessageDTOWithInvalidContent() {
        return MessageDTO.builder()
                .uid(DEFAULT_UID)
                .bufferUid(DEFAULT_BUFFER_UID)
                .content("") // Пустой контент
                .contentType(DEFAULT_CONTENT_TYPE)
                .createdAt(DEFAULT_CREATED_AT)
                .build();
    }

    public static MessageDTO createMessageDTOWithFutureDate() {
        return MessageDTO.builder()
                .uid(DEFAULT_UID)
                .bufferUid(DEFAULT_BUFFER_UID)
                .content(DEFAULT_CONTENT)
                .contentType(DEFAULT_CONTENT_TYPE)
                .createdAt(new Date(System.currentTimeMillis() + 1000L * 60 * 60)) // Будущее время
                .build();
    }

    public static MessageDTO createMessageDTOWithNullFields() {
        return MessageDTO.builder()
                .uid(null)
                .bufferUid(null)
                .content(null)
                .contentType(null)
                .createdAt(null)
                .build();
    }

    public static MessageDALM createMessageForBuffer(UUID bufferUid) {
        return MessageDALM.builder()
                .uid(UUID.randomUUID())
                .bufferUid(bufferUid)
                .content("{\"buffer\":\"" + bufferUid + "\",\"data\":\"test data\"}")
                .contentType(DEFAULT_CONTENT_TYPE)
                .createdAt(new Date())
                .build();
    }

    public static MessageDALM createMessageWithContentType(String contentType) {
        return MessageDALM.builder()
                .uid(UUID.randomUUID())
                .bufferUid(DEFAULT_BUFFER_UID)
                .content("{\"type\":\"custom\",\"contentType\":\"" + contentType + "\"}")
                .contentType(contentType)
                .createdAt(new Date())
                .build();
    }
}package com.connection.message.repository;

import static com.connection.message.mother.MessageObjectMother.createValidMessageDALM;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.UUID;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestMethodOrder;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.dao.EmptyResultDataAccessException;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.connection.message.exception.MessageAddException;
import com.connection.message.exception.MessageNotFoundException;
import com.connection.message.model.MessageDALM;

@TestMethodOrder(MethodOrderer.DisplayName.class)
@DisplayName("Message Repository Tests - SQL implementation tests")
class MessageRepositorySQLImplTest {

    @Mock
    private NamedParameterJdbcTemplate jdbcTemplate;

    @InjectMocks
    private MessageRepositorySQLImpl repository;

    private MessageDALM testMessage;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        testMessage = createValidMessageDALM();
    }

    @SuppressWarnings("unchecked")
    @Test
    @DisplayName("Add message - Positive")
    void testAddMessage_Positive() {
        when(jdbcTemplate.update(anyString(), any(MapSqlParameterSource.class))).thenReturn(1);

        repository.add(testMessage);

        verify(jdbcTemplate, times(1)).update(anyString(), any(MapSqlParameterSource.class));
    }

    @Test
    @DisplayName("Add message with exception - Negative")
    void testAddMessageWithException_Negative() {
        when(jdbcTemplate.update(anyString(), any(MapSqlParameterSource.class)))
                .thenThrow(new RuntimeException("Database error"));

        assertThatThrownBy(() -> repository.add(testMessage))
                .isInstanceOf(MessageAddException.class);
    }

    @SuppressWarnings("unchecked")
    @Test
    @DisplayName("Find message by UID - Positive")
    void testFindByUid_Positive() {
        when(jdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenReturn(testMessage);

        MessageDALM result = repository.findByUid(testMessage.getUid());

        assertThat(result).isEqualTo(testMessage);
        verify(jdbcTemplate, times(1)).queryForObject(
                eq("SELECT uid, buffer_uid, content, content_type, created_at FROM processing.message WHERE uid = :uid"),
                any(MapSqlParameterSource.class),
                any(RowMapper.class));
    }

    @SuppressWarnings("unchecked")
    @Test
    @DisplayName("Find non-existent message by UID - Negative")
    void testFindByUid_Negative() {
        when(jdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenThrow(new EmptyResultDataAccessException(1));

        assertThatThrownBy(() -> repository.findByUid(testMessage.getUid()))
                .isInstanceOf(MessageNotFoundException.class);
    }

    @SuppressWarnings("unchecked")
    @Test
    @DisplayName("Find messages by buffer UID - Positive")
    void testFindByBufferUid_Positive() {
        List<MessageDALM> messages = Arrays.asList(testMessage);
        when(jdbcTemplate.query(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenReturn(messages);

        List<MessageDALM> result = repository.findByBufferUid(testMessage.getBufferUid());

        assertThat(result).hasSize(1);
        assertThat(result.get(0)).isEqualTo(testMessage);
        verify(jdbcTemplate, times(1)).query(
                eq("SELECT uid, buffer_uid, content, content_type, created_at FROM processing.message WHERE buffer_uid = :buffer_uid ORDER BY created_at DESC"),
                any(MapSqlParameterSource.class),
                any(RowMapper.class));
    }

    @SuppressWarnings("unchecked")
    @Test
    @DisplayName("Find no messages by buffer UID - Negative")
    void testFindByBufferUid_Negative() {
        when(jdbcTemplate.query(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenReturn(Collections.emptyList());

        assertThatThrownBy(() -> repository.findByBufferUid(testMessage.getBufferUid()))
                .isInstanceOf(MessageNotFoundException.class);
    }

    @SuppressWarnings("unchecked")
    @Test
    @DisplayName("Find messages by buffer UID and time range - Positive")
    void testFindByBufferUidAndTimeRange_Positive() {
        List<MessageDALM> messages = Arrays.asList(testMessage);
        Date startTime = new Date(System.currentTimeMillis() - 1000 * 60 * 60); // 1 hour ago
        Date endTime = new Date();

        when(jdbcTemplate.query(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenReturn(messages);

        List<MessageDALM> result = repository.findByBufferUidAndTimeRange(testMessage.getBufferUid(), startTime, endTime);

        assertThat(result).hasSize(1);
        assertThat(result.get(0)).isEqualTo(testMessage);
        verify(jdbcTemplate, times(1)).query(
                eq("SELECT uid, buffer_uid, content, content_type, created_at FROM processing.message WHERE buffer_uid = :buffer_uid AND created_at BETWEEN :start_time AND :end_time ORDER BY created_at DESC"),
                any(MapSqlParameterSource.class),
                any(RowMapper.class));
    }

    @SuppressWarnings("unchecked")
    @Test
    @DisplayName("Find no messages by buffer UID and time range - Negative")
    void testFindByBufferUidAndTimeRange_Negative() {
        Date startTime = new Date(System.currentTimeMillis() - 1000 * 60 * 60);
        Date endTime = new Date();

        when(jdbcTemplate.query(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenReturn(Collections.emptyList());

        assertThatThrownBy(() -> repository.findByBufferUidAndTimeRange(testMessage.getBufferUid(), startTime, endTime))
                .isInstanceOf(MessageNotFoundException.class);
    }

    @SuppressWarnings("unchecked")
    @Test
    @DisplayName("Delete message by UID - Positive")
    void testDeleteByUid_Positive() {
        when(jdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenReturn(testMessage);
        when(jdbcTemplate.update(anyString(), any(MapSqlParameterSource.class))).thenReturn(1);

        repository.deleteByUid(testMessage.getUid());

        verify(jdbcTemplate, times(1)).update(
                eq("DELETE FROM processing.message WHERE uid = :uid"),
                any(MapSqlParameterSource.class));
    }

    @SuppressWarnings("unchecked")
    @Test
    @DisplayName("Delete non-existent message by UID - Negative")
    void testDeleteByUid_Negative() {
        when(jdbcTemplate.queryForObject(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenThrow(new EmptyResultDataAccessException(1));

        assertThatThrownBy(() -> repository.deleteByUid(testMessage.getUid()))
                .isInstanceOf(MessageNotFoundException.class);

        verify(jdbcTemplate, never()).update(anyString(), any(MapSqlParameterSource.class));
    }

    @SuppressWarnings("unchecked")
    @Test
    @DisplayName("Delete messages by buffer UID - Positive")
    void testDeleteByBufferUid_Positive() {
        List<MessageDALM> messages = Arrays.asList(testMessage);
        when(jdbcTemplate.query(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenReturn(messages);
        when(jdbcTemplate.update(anyString(), any(MapSqlParameterSource.class))).thenReturn(1);

        repository.deleteByBufferUid(testMessage.getBufferUid());

        verify(jdbcTemplate, times(1)).update(
                eq("DELETE FROM processing.message WHERE buffer_uid = :buffer_uid"),
                any(MapSqlParameterSource.class));
    }

    @SuppressWarnings("unchecked")
    @Test
    @DisplayName("Delete messages by non-existent buffer UID - Negative")
    void testDeleteByBufferUid_Negative() {
        when(jdbcTemplate.query(anyString(), any(MapSqlParameterSource.class), any(RowMapper.class)))
                .thenReturn(Collections.emptyList());

        assertThatThrownBy(() -> repository.deleteByBufferUid(testMessage.getBufferUid()))
                .isInstanceOf(MessageNotFoundException.class);

        verify(jdbcTemplate, never()).update(anyString(), any(MapSqlParameterSource.class));
    }
}