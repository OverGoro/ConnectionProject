// MessageKafkaConfig.java
package com.connection.message.config;

import java.util.HashMap;
import java.util.Map;

import org.apache.kafka.clients.admin.NewTopic;
import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.clients.producer.ProducerConfig;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.config.TopicBuilder;
import org.springframework.kafka.core.ConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaProducerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.core.ProducerFactory;
import org.springframework.kafka.listener.DefaultErrorHandler;
import org.springframework.kafka.support.serializer.ErrorHandlingDeserializer;
import org.springframework.kafka.support.serializer.JsonDeserializer;
import org.springframework.kafka.support.serializer.JsonSerializer;
import org.springframework.util.backoff.FixedBackOff;

import com.connection.message.events.MessageEventConstants;

@Configuration
public class MessageKafkaConfig {
    @Value("${spring.kafka.bootstrap-servers:localhost:29092}")
    private String bootstrapServers;

    @Bean
    public NewTopic messageCommandsTopic() {
        return TopicBuilder.name(MessageEventConstants.MESSAGE_COMMANDS_TOPIC)
                .partitions(3)
                .replicas(1)
                .build();
    }

    @Bean
    public NewTopic messageResponsesTopic() {
        return TopicBuilder.name(MessageEventConstants.MESSAGE_RESPONSES_TOPIC)
                .partitions(3)
                .replicas(1)
                .build();
    }

    @Bean
    public NewTopic messageEventsTopic() {
        return TopicBuilder.name(MessageEventConstants.MESSAGE_EVENTS_TOPIC)
                .partitions(3)
                .replicas(1)
                .build();
    }

    // Конфигурация для Consumer
    @Bean
    public ConsumerFactory<String, Object> consumerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        configProps.put(ConsumerConfig.GROUP_ID_CONFIG, "message-service-group");
        configProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");
        configProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer.class);
        configProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer.class);
        
        configProps.put(ErrorHandlingDeserializer.KEY_DESERIALIZER_CLASS, org.apache.kafka.common.serialization.StringDeserializer.class);
        configProps.put(ErrorHandlingDeserializer.VALUE_DESERIALIZER_CLASS, JsonDeserializer.class);
        
        configProps.put(JsonDeserializer.TRUSTED_PACKAGES, "com.connection.message.events.commands,com.connection.common.events,com.connection.device.token.events,com.connection.scheme.events");
        configProps.put(JsonDeserializer.USE_TYPE_INFO_HEADERS, true);
        configProps.put(JsonDeserializer.REMOVE_TYPE_INFO_HEADERS, false);
        configProps.put(JsonDeserializer.VALUE_DEFAULT_TYPE, "com.connection.common.events.Command");
        
        return new DefaultKafkaConsumerFactory<>(configProps);
    }

    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, Object> kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory<String, Object> factory = 
            new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory());
        
        DefaultErrorHandler errorHandler = new DefaultErrorHandler(
                (record, exception) -> {
                    org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger("KafkaErrorHandler");
                    logger.error("Skipping invalid message - Topic: {}, Partition: {}, Offset: {}, Key: {}, Error: {}",
                            record.topic(),
                            record.partition(),
                            record.offset(),
                            record.key(),
                            exception.getMessage());
                },
                new FixedBackOff(0L, 0L)
        );

        factory.setCommonErrorHandler(errorHandler);
        
        return factory;
    }

    // Конфигурация для Producer
    @Bean
    public ProducerFactory<String, Object> producerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, org.apache.kafka.common.serialization.StringSerializer.class);
        configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
        configProps.put(JsonSerializer.ADD_TYPE_INFO_HEADERS, true);
        return new DefaultKafkaProducerFactory<>(configProps);
    }

    @Bean
    public KafkaTemplate<String, Object> kafkaTemplate() {
        return new KafkaTemplate<>(producerFactory());
    }
}// MessageUtilsConfig.java
package com.connection.message.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.connection.message.converter.MessageConverter;
import com.connection.message.validator.MessageValidator;

@Configuration
public class MessageUtilsConfig {
    @Bean("MessageConverter")
    MessageConverter messageConverter(){
        return new MessageConverter();
    }

    @Bean("MessageValidator")
    MessageValidator messageValidator(){
        return new MessageValidator();
    }
}// MessageRepositoryConfig.java
package com.connection.message.config;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.connection.message.repository.MessageRepository;
import com.connection.message.repository.MessageRepositorySQLImpl;

@Configuration
public class MessageRepositoryConfig {
    @Bean("MessageRepository")
    MessageRepository messageRepository(@Qualifier("MessageJdbcTemplate") NamedParameterJdbcTemplate template){
        return new MessageRepositorySQLImpl(template);
    }
}// SecurityConfig.java
package com.connection.message.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import com.connection.message.client.DeviceAuthKafkaAuthenticationFilter;

import lombok.RequiredArgsConstructor;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
@RequiredArgsConstructor
public class SecurityConfig {

    private final DeviceAuthKafkaAuthenticationFilter deviceAuthKafkaAuthenticationFilter;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                .csrf(csrf -> csrf.disable())
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/swagger-ui.html").permitAll()
                        .requestMatchers("/swagger-ui/**").permitAll()
                        .requestMatchers("/api-docs/**").permitAll()
                        .requestMatchers("/webjars/**").permitAll()
                        .requestMatchers("/v3/api-docs/**").permitAll()
                        .requestMatchers("/api/message-service/health").permitAll()
                        .requestMatchers("/api/message-service/**").authenticated()
                        .anyRequest().denyAll()
                )
                .addFilterBefore(deviceAuthKafkaAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)
                .build();
    }
}// MessageResponse.java
package com.connection.message.controller;

import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class MessageResponse {
    private final UUID messageUid;
}// HealthResponse.java
package com.connection.message.controller;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class HealthResponse {
    private final String message;
}package com.connection.message.controller;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.connection.message.converter.MessageConverter;
import com.connection.message.model.MessageBLM;
import com.connection.message.model.MessageDTO;
import com.connection.message.validator.MessageValidator;
import com.connection.message.MessageService;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/message-service")
public class MessageController {
    
    private final MessageService messageService;
    private final MessageValidator messageValidator;
    private final MessageConverter messageConverter;

    // Константы для пагинации по умолчанию
    private static final int DEFAULT_OFFSET = 0;
    private static final int DEFAULT_LIMIT = 50;
    private static final int MAX_LIMIT = 1000;

    private static final String DEVICE_ACCESS_TOKEN_HEADER = "Device-Access-Token";

    @PostMapping("/messages")
    public ResponseEntity<MessageResponse> addMessage(
            @RequestHeader(DEVICE_ACCESS_TOKEN_HEADER) String deviceAccessToken,
            @RequestBody MessageDTO messageDTO) {
        
        log.info("Adding message to buffer: {} with contentType: {}", 
                messageDTO.getBufferUid(), messageDTO.getContentType());

        messageValidator.validate(messageDTO);
        MessageBLM message = messageService.addMessage(deviceAccessToken, messageDTO);

        return ResponseEntity.ok(new MessageResponse(message.getUid()));
    }

    @GetMapping("/messages/{messageUid}")
    public ResponseEntity<MessageResponse> getMessage(
            @RequestHeader(DEVICE_ACCESS_TOKEN_HEADER) String deviceAccessToken,
            @PathVariable UUID messageUid) {
        
        log.info("Getting message: {}", messageUid);
        
        MessageBLM message = messageService.getMessage(deviceAccessToken, messageUid);

        return ResponseEntity.ok(new MessageResponse(message.getUid()));
    }

    @GetMapping("/messages/buffer/{bufferUid}")
    public ResponseEntity<MessagesListResponse> getMessagesByBuffer(
            @RequestHeader(DEVICE_ACCESS_TOKEN_HEADER) String deviceAccessToken,
            @PathVariable UUID bufferUid,
            @RequestParam(required = false) String contentType,
            @RequestParam(defaultValue = "" + DEFAULT_OFFSET) int offset,
            @RequestParam(defaultValue = "" + DEFAULT_LIMIT) int limit) {
        
        log.info("Getting messages for buffer: {} with contentType: {}, offset: {}, limit: {}", 
                bufferUid, contentType, offset, limit);
        
        List<MessageBLM> allMessages = messageService.getMessagesByBuffer(deviceAccessToken, bufferUid, contentType);
        
        // Применяем пагинацию
        List<MessageBLM> paginatedMessages = applyPagination(allMessages, offset, limit);
        List<MessageDTO> messageDTOs = paginatedMessages.stream()
                .map(messageConverter::toDTO)
                .collect(Collectors.toList());

        // Создаем информацию о пагинации
        MessagesListResponse.PaginationInfo paginationInfo = 
            new MessagesListResponse.PaginationInfo(
                offset, 
                limit, 
                allMessages.size(), 
                (offset + limit) < allMessages.size()
            );

        return ResponseEntity.ok(new MessagesListResponse(messageDTOs, paginationInfo));
    }

    @PostMapping("/messages/{messageUid}/route")
    public ResponseEntity<Void> routeMessage(
            @RequestHeader(DEVICE_ACCESS_TOKEN_HEADER) String deviceAccessToken,
            @PathVariable UUID messageUid) {
        
        log.info("Routing message: {}", messageUid);
        
        messageService.routeOutgoingMessage(deviceAccessToken, messageUid);

        return ResponseEntity.ok().build();
    }

    @DeleteMapping("/messages/{messageUid}")
    public ResponseEntity<Void> deleteMessage(
            @RequestHeader(DEVICE_ACCESS_TOKEN_HEADER) String deviceAccessToken,
            @PathVariable UUID messageUid) {
        
        log.info("Deleting message: {}", messageUid);

        messageService.deleteMessage(deviceAccessToken, messageUid);

        return ResponseEntity.noContent().build();
    }

    @GetMapping("/health")
    public ResponseEntity<HealthResponse> healthCheck() {
        log.info("Health check: status: OK, service: message-service, timestamp: {}", 
                System.currentTimeMillis());
                
        return ResponseEntity.ok().body(new HealthResponse(messageService.getHealthStatus().toString()));
    }

    /**
     * Применяет пагинацию к списку сообщений
     */
    private List<MessageBLM> applyPagination(List<MessageBLM> messages, int offset, int limit) {
        // Валидация параметров пагинации
        if (offset < 0) {
            offset = DEFAULT_OFFSET;
        }
        
        if (limit <= 0 || limit > MAX_LIMIT) {
            limit = DEFAULT_LIMIT;
        }
        
        // Применяем пагинацию
        return messages.stream()
                .skip(offset)
                .limit(limit)
                .collect(Collectors.toList());
    }
}// MessagesListResponse.java
package com.connection.message.controller;

import com.connection.message.model.MessageDTO;

import lombok.AllArgsConstructor;
import lombok.Getter;

import java.util.List;

@AllArgsConstructor
@Getter
public class MessagesListResponse {
    private final List<MessageDTO> messages;
    private final PaginationInfo pagination;

    @AllArgsConstructor
    @Getter
    public static class PaginationInfo {
        private final int offset;
        private final int limit;
        private final int totalCount;
        private final boolean hasMore;
    }
}package com.connection.message.kafka;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

import com.connection.scheme.events.commands.GetConnectionSchemeByUidCommand;
import com.connection.scheme.events.commands.HealthCheckCommand;
import com.connection.scheme.events.commands.ValidateBufferOwnershipCommand;
import com.connection.scheme.events.responses.GetConnectionSchemeByUidResponse;
import com.connection.scheme.events.responses.HealthCheckResponse;
import com.connection.scheme.events.responses.BufferOwnershipResponse;
import com.connection.scheme.model.ConnectionSchemeBLM;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class TypedConnectionSchemeKafkaClient {

    private final KafkaTemplate<String, Object> kafkaTemplate;
    
    private final Map<String, PendingRequest<?>> pendingRequests = new ConcurrentHashMap<>();

    private static class PendingRequest<T> {
        final CompletableFuture<T> future;
        final Class<T> responseType;

        PendingRequest(CompletableFuture<T> future, Class<T> responseType) {
            this.future = future;
            this.responseType = responseType;
        }
    }

    public CompletableFuture<BufferOwnershipResponse> validateBufferOwnership(UUID bufferUid, UUID deviceUid, String sourceService) {
        return sendRequest(
            ValidateBufferOwnershipCommand.builder()
                .bufferUid(bufferUid)
                .deviceUid(deviceUid)
                .sourceService(sourceService)
                .replyTopic("scheme.responses")
                .correlationId(generateCorrelationId())
                .build(),
            BufferOwnershipResponse.class,
            "scheme.commands" // Правильный топик
        );
    }

    public CompletableFuture<GetConnectionSchemeByUidResponse> getSchemeByDeviceBuffer(UUID bufferUid, UUID deviceUid, String sourceService) {
        return sendRequest(
            GetConn.builder()
                .
                .deviceUid(deviceUid)
                .sourceService(sourceService)
                .replyTopic("scheme.responses")
                .correlationId(generateCorrelationId())
                .build(),
            GetConnectionSchemeByUidResponse.class,
            "scheme.commands" // Правильный топик
        );
    }

    public CompletableFuture<HealthCheckResponse> healthCheck(String sourceService) {
        return sendRequest(
            HealthCheckCommand.builder()
                .sourceService(sourceService)
                .replyTopic("scheme.responses")
                .correlationId(generateCorrelationId())
                .build(),
            HealthCheckResponse.class,
            "scheme.commands" // Правильный топик
        );
    }

    public boolean isBufferOwnedByDevice(UUID bufferUid, UUID deviceUid) {
        try {
            BufferOwnershipResponse response = validateBufferOwnership(bufferUid, deviceUid, "message-service")
                    .get(10, java.util.concurrent.TimeUnit.SECONDS);
            
            return response.isSuccess() && response.isOwned();
        } catch (java.util.concurrent.TimeoutException e) {
            throw new SecurityException("Buffer ownership validation timeout");
        } catch (Exception e) {
            throw new SecurityException("Buffer ownership validation failed: " + e.getMessage());
        }
    }

    public ConnectionSchemeBLM getSchemeByDeviceBuffer(UUID bufferUid, UUID deviceUid) {
        try {
            GetConnectionSchemeByUidResponse response = getSchemeByDeviceBuffer(bufferUid, deviceUid, "message-service")
                    .get(10, java.util.concurrent.TimeUnit.SECONDS);
            
            if (response.isSuccess() && response.getConnectionSchemeDTO() != null) {
                // Конвертируем ConnectionSchemeDTO в ConnectionSchemeBLM
                // Здесь нужно добавить конвертер или использовать соответствующий метод
                return convertToBLM(response.getConnectionSchemeDTO());
            } else {
                log.warn("No connection scheme found for buffer: {} and device: {}", bufferUid, deviceUid);
                return null;
            }
        } catch (java.util.concurrent.TimeoutException e) {
            throw new SecurityException("Connection scheme retrieval timeout");
        } catch (Exception e) {
            log.warn("Failed to get connection scheme for buffer: {} and device: {}", bufferUid, deviceUid, e);
            return null;
        }
    }

    private <T> CompletableFuture<T> sendRequest(Object command, Class<T> responseType, String topic) {
        String correlationId = getCorrelationId(command);
        
        CompletableFuture<T> future = new CompletableFuture<>();
        pendingRequests.put(correlationId, new PendingRequest<>(future, responseType));

        kafkaTemplate.send(topic, correlationId, command)
                .whenComplete((result, ex) -> {
                    if (ex != null) {
                        future.completeExceptionally(ex);
                        pendingRequests.remove(correlationId);
                        log.error("Failed to send connection scheme command to topic {}: {}", topic, ex.getMessage());
                    } else {
                        log.debug("Successfully sent connection scheme command to topic {} with correlationId: {}", topic, correlationId);
                    }
                });

        return future;
    }

    @SuppressWarnings("unchecked")
    public void handleResponse(String correlationId, Object response) {
        PendingRequest<?> pendingRequest = pendingRequests.remove(correlationId);
        if (pendingRequest != null) {
            try {
                if (pendingRequest.responseType.isInstance(response)) {
                    CompletableFuture<Object> future = (CompletableFuture<Object>) pendingRequest.future;
                    future.complete(response);
                } else {
                    log.warn("Type mismatch for correlationId: {}. Expected: {}, Got: {}", 
                            correlationId, pendingRequest.responseType, response.getClass());
                    pendingRequest.future.completeExceptionally(
                        new ClassCastException("Type mismatch in response")
                    );
                }
            } catch (Exception e) {
                pendingRequest.future.completeExceptionally(e);
            }
        } else {
            log.warn("Received response for unknown correlationId: {}", correlationId);
        }
    }

    private String getCorrelationId(Object command) {
        // Получаем correlationId из команды через рефлексию
        try {
            java.lang.reflect.Method getCorrelationIdMethod = command.getClass().getMethod("getCorrelationId");
            return (String) getCorrelationIdMethod.invoke(command);
        } catch (Exception e) {
            return generateCorrelationId();
        }
    }

    private String generateCorrelationId() {
        return UUID.randomUUID().toString();
    }

    /**
     * Вспомогательный метод для конвертации ConnectionSchemeDTO в ConnectionSchemeBLM
     * В реальной реализации нужно использовать соответствующий конвертер
     */
    private ConnectionSchemeBLM convertToBLM(com.connection.scheme.model.ConnectionSchemeDTO dto) {
        // Временная реализация - в реальном коде нужно использовать ConnectionSchemeConverter
        return ConnectionSchemeBLM.builder()
                .uid(UUID.fromString(dto.getUid()))
                .clientUid(UUID.fromString(dto.getClientUid()))
                .schemeJson(dto.getSchemeJson())
                .usedBuffers(dto.getUsedBuffers())
                .bufferTransitions(java.util.Collections.emptyMap()) // Нужно извлечь из schemeJson
                .build();
    }
}package com.connection.message.kafka;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

import com.connection.device.auth.events.commands.ValidateTokenCommand;
import com.connection.device.auth.events.commands.ValidateTokenCommand.TokenType;
import com.connection.device.auth.events.commands.ExtractDeviceUidCommand;
import com.connection.device.auth.events.commands.HealthCheckCommand;
import com.connection.device.auth.events.responses.TokenValidationResponse;
import com.connection.device.auth.events.responses.DeviceUidResponse;
import com.connection.device.auth.events.responses.HealthCheckResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class TypedDeviceAuthKafkaClient {

    private final KafkaTemplate<String, Object> kafkaTemplate;
    
    private final Map<String, PendingRequest<?>> pendingRequests = new ConcurrentHashMap<>();

    private static class PendingRequest<T> {
        final CompletableFuture<T> future;
        final Class<T> responseType;

        PendingRequest(CompletableFuture<T> future, Class<T> responseType) {
            this.future = future;
            this.responseType = responseType;
        }
    }

    public CompletableFuture<TokenValidationResponse> validateDeviceAccessToken(String token, String sourceService) {
        return sendRequest(
            ValidateTokenCommand.builder()
                .token(token)
                .tokenType(TokenType.ACCESS)
                .sourceService(sourceService)
                .replyTopic("device-auth.responses")
                .correlationId(generateCorrelationId())
                .build(),
            TokenValidationResponse.class,
            "device.auth.commands" // Правильный топик
        );
    }

    public CompletableFuture<DeviceUidResponse> extractDeviceUidFromAccessToken(String token, String sourceService) {
        return sendRequest(
            ExtractDeviceUidCommand.builder()
                .token(token)
                .sourceService(sourceService)
                .replyTopic("device-auth.responses")
                .correlationId(generateCorrelationId())
                .build(),
            DeviceUidResponse.class,
            "device.auth.commands" // Правильный топик
        );
    }

    public CompletableFuture<HealthCheckResponse> healthCheck(String sourceService) {
        return sendRequest(
            HealthCheckCommand.builder()
                .sourceService(sourceService)
                .replyTopic("device-auth.responses")
                .correlationId(generateCorrelationId())
                .build(),
            HealthCheckResponse.class,
            "device.auth.commands" // Правильный топик
        );
    }

    public UUID extractDeviceUidFromAccessToken(String deviceAccessToken) {
        try {
            DeviceUidResponse response = extractDeviceUidFromAccessToken(deviceAccessToken, "message-service")
                    .get(10, java.util.concurrent.TimeUnit.SECONDS);
            
            if (response.isSuccess() && response.getDeviceUid() != null) {
                return response.getDeviceUid();
            } else {
                throw new SecurityException("Failed to extract device UID from token: " + response.getError());
            }
        } catch (java.util.concurrent.TimeoutException e) {
            throw new SecurityException("Device UID extraction timeout");
        } catch (Exception e) {
            throw new SecurityException("Device UID extraction failed: " + e.getMessage());
        }
    }

    public boolean validateDeviceAccessToken(String deviceAccessToken) {
        try {
            TokenValidationResponse response = validateDeviceAccessToken(deviceAccessToken, "message-service")
                    .get(10, java.util.concurrent.TimeUnit.SECONDS);
            
            return response.isSuccess() && response.isValid();
        } catch (java.util.concurrent.TimeoutException e) {
            throw new SecurityException("Device token validation timeout");
        } catch (Exception e) {
            throw new SecurityException("Device token validation failed: " + e.getMessage());
        }
    }

    private <T> CompletableFuture<T> sendRequest(Object command, Class<T> responseType, String topic) {
        String correlationId = getCorrelationId(command);
        
        CompletableFuture<T> future = new CompletableFuture<>();
        pendingRequests.put(correlationId, new PendingRequest<>(future, responseType));

        kafkaTemplate.send(topic, correlationId, command)
                .whenComplete((result, ex) -> {
                    if (ex != null) {
                        future.completeExceptionally(ex);
                        pendingRequests.remove(correlationId);
                        log.error("Failed to send device auth command to topic {}: {}", topic, ex.getMessage());
                    } else {
                        log.debug("Successfully sent device auth command to topic {} with correlationId: {}", topic, correlationId);
                    }
                });

        return future;
    }

    @SuppressWarnings("unchecked")
    public void handleResponse(String correlationId, Object response) {
        PendingRequest<?> pendingRequest = pendingRequests.remove(correlationId);
        if (pendingRequest != null) {
            try {
                if (pendingRequest.responseType.isInstance(response)) {
                    CompletableFuture<Object> future = (CompletableFuture<Object>) pendingRequest.future;
                    future.complete(response);
                } else {
                    log.warn("Type mismatch for correlationId: {}. Expected: {}, Got: {}", 
                            correlationId, pendingRequest.responseType, response.getClass());
                    pendingRequest.future.completeExceptionally(
                        new ClassCastException("Type mismatch in response")
                    );
                }
            } catch (Exception e) {
                pendingRequest.future.completeExceptionally(e);
            }
        } else {
            log.warn("Received response for unknown correlationId: {}", correlationId);
        }
    }

    private String getCorrelationId(Object command) {
        // Получаем correlationId из команды через рефлексию
        try {
            java.lang.reflect.Method getCorrelationIdMethod = command.getClass().getMethod("getCorrelationId");
            return (String) getCorrelationIdMethod.invoke(command);
        } catch (Exception e) {
            return generateCorrelationId();
        }
    }

    private String generateCorrelationId() {
        return UUID.randomUUID().toString();
    }
}package com.connection.message;

import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.connection.message.converter.MessageConverter;
import com.connection.message.exception.MessageAddException;
import com.connection.message.exception.MessageRoutingException;
import com.connection.message.model.MessageBLM;
import com.connection.message.model.MessageDALM;
import com.connection.message.model.MessageDTO;
import com.connection.message.repository.MessageRepository;
import com.connection.message.validator.MessageValidator;
import com.connection.scheme.model.ConnectionSchemeBLM;
import com.connection.message.kafka.TypedConnectionSchemeKafkaClient;
import com.connection.message.kafka.TypedDeviceAuthKafkaClient;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RequiredArgsConstructor
@Service
@EnableAutoConfiguration(exclude = {
        JpaRepositoriesAutoConfiguration.class
})
@Transactional("atomicosTransactionManager")
public class MessageServiceImpl implements MessageService {

    private final MessageRepository messageRepository;
    private final MessageConverter messageConverter;
    private final MessageValidator messageValidator;
    private final TypedConnectionSchemeKafkaClient connectionSchemeClient;
    private final TypedDeviceAuthKafkaClient deviceAuthClient;

    // Константы для определения типа сообщения через contentType
    private static final String CONTENT_TYPE_INCOMING = "INCOMING";
    private static final String CONTENT_TYPE_OUTGOING = "OUTGOING";

    @Override
    public MessageBLM addMessage(String deviceAccessToken, MessageDTO messageDTO) {
        // Валидируем сообщение
        messageValidator.validate(messageDTO);
        
        // Извлекаем deviceUid из токена
        UUID deviceUid = deviceAuthClient.extractDeviceUidFromAccessToken(deviceAccessToken);
        
        // Проверяем, что буфер принадлежит устройству
        if (!connectionSchemeClient.isBufferOwnedByDevice(messageDTO.getBufferUid(), deviceUid)) {
            throw new SecurityException("Buffer doesn't belong to the authenticated device");
        }

        // Конвертируем и сохраняем сообщение
        MessageBLM messageBLM = messageConverter.toBLM(messageDTO);
        MessageDALM messageDALM = messageConverter.toDALM(messageBLM);
        
        try {
            messageRepository.add(messageDALM);
        } catch (MessageAddException e) {
            throw new MessageAddException("Failed to add message: " + e.getMessage());
        }

        log.info("Message created: {} in buffer: {} with contentType: {} for device: {}", 
                messageBLM.getUid(), messageBLM.getBufferUid(), messageBLM.getContentType(), deviceUid);

        // Если сообщение исходящее - запускаем маршрутизацию
        if (isOutgoingMessage(messageBLM)) {
            try {
                routeOutgoingMessage(deviceAccessToken, messageBLM.getUid());
            } catch (Exception e) {
                log.error("Failed to route outgoing message: {}", messageBLM.getUid(), e);
                // Не прерываем создание сообщения при ошибке маршрутизации
            }
        }

        return messageBLM;
    }

    @Override
    public MessageBLM getMessage(String deviceAccessToken, UUID messageUid) {
        // Извлекаем deviceUid из токена
        UUID deviceUid = deviceAuthClient.extractDeviceUidFromAccessToken(deviceAccessToken);
        
        // Получаем сообщение
        MessageDALM messageDALM;
        try {
            messageDALM = messageRepository.findByUid(messageUid);
        } catch (Exception e) {
            throw new RuntimeException("Message not found: " + messageUid);
        }
        
        MessageBLM messageBLM = messageConverter.toBLM(messageDALM);

        // Проверяем, что буфер сообщения принадлежит устройству
        if (!connectionSchemeClient.isBufferOwnedByDevice(messageBLM.getBufferUid(), deviceUid)) {
            throw new SecurityException("Message doesn't belong to the authenticated device");
        }

        return messageBLM;
    }

    @Override
    public List<MessageBLM> getMessagesByBuffer(String deviceAccessToken, UUID bufferUid, String contentTypeFilter) {
        // Извлекаем deviceUid из токена
        UUID deviceUid = deviceAuthClient.extractDeviceUidFromAccessToken(deviceAccessToken);
        
        // Проверяем, что буфер принадлежит устройству
        if (!connectionSchemeClient.isBufferOwnedByDevice(bufferUid, deviceUid)) {
            throw new SecurityException("Buffer doesn't belong to the authenticated device");
        }

        // Получаем сообщения из буфера
        List<MessageDALM> messagesDALM;
        try {
            messagesDALM = messageRepository.findByBufferUid(bufferUid);
        } catch (Exception e) {
            throw new RuntimeException("Failed to get messages for buffer: " + bufferUid);
        }

        // Фильтруем по contentType если указано
        return messagesDALM.stream()
                .map(messageConverter::toBLM)
                .filter(message -> contentTypeFilter == null || contentTypeFilter.equals(message.getContentType()))
                .collect(Collectors.toList());
    }

    @Override
    public void routeOutgoingMessage(String deviceAccessToken, UUID messageUid) {
        // Извлекаем deviceUid из токена
        UUID deviceUid = deviceAuthClient.extractDeviceUidFromAccessToken(deviceAccessToken);
        
        // Получаем сообщение
        MessageBLM outgoingMessage = getMessage(deviceAccessToken, messageUid);
        
        if (!isOutgoingMessage(outgoingMessage)) {
            throw new MessageRoutingException("Cannot route non-outgoing message");
        }

        // Получаем схему подключения для буфера устройства
        ConnectionSchemeBLM scheme = connectionSchemeClient.getSchemeByDeviceBuffer(outgoingMessage.getBufferUid(), deviceUid);
        
        if (scheme == null || scheme.getBufferTransitions() == null) {
            log.warn("No connection scheme found for buffer: {} of device: {}", outgoingMessage.getBufferUid(), deviceUid);
            return;
        }

        // Получаем целевые буферы из схемы
        List<UUID> targetBuffers = scheme.getBufferTransitions().get(outgoingMessage.getBufferUid());
        
        if (targetBuffers == null || targetBuffers.isEmpty()) {
            log.warn("No target buffers found in scheme for buffer: {}", outgoingMessage.getBufferUid());
            return;
        }

        // Создаем входящие сообщения в целевых буферах
        for (UUID targetBufferUid : targetBuffers) {
            try {
                MessageBLM incomingMessage = MessageBLM.builder()
                        .uid(UUID.randomUUID())
                        .bufferUid(targetBufferUid)
                        .content(outgoingMessage.getContent())
                        .contentType(CONTENT_TYPE_INCOMING) // Меняем тип на входящий
                        .createdAt(new java.util.Date())
                        .build();

                MessageDALM incomingMessageDALM = messageConverter.toDALM(incomingMessage);
                messageRepository.add(incomingMessageDALM);

                log.info("Routed message from buffer: {} to buffer: {} for device: {}", 
                        outgoingMessage.getBufferUid(), targetBufferUid, deviceUid);
                        
            } catch (Exception e) {
                log.error("Failed to route message to buffer: {} for device: {}", targetBufferUid, deviceUid, e);
                // Продолжаем маршрутизацию для остальных буферов
            }
        }

        log.info("Successfully routed outgoing message: {} for device: {}", messageUid, deviceUid);
    }

    @Override
    public void deleteMessage(String deviceAccessToken, UUID messageUid) {
        // Извлекаем deviceUid из токена и проверяем права
        MessageBLM message = getMessage(deviceAccessToken, messageUid);
        
        try {
            messageRepository.deleteByUid(messageUid);
            log.info("Message deleted: {} for device", messageUid);
        } catch (Exception e) {
            throw new RuntimeException("Failed to delete message: " + messageUid);
        }
    }

    @Override
    public Map<String, Object> getHealthStatus() {
        try {
            // Проверяем доступность зависимых сервисов
            var schemeHealth = connectionSchemeClient.healthCheck("message-service")
                    .get(5, java.util.concurrent.TimeUnit.SECONDS);
            var deviceAuthHealth = deviceAuthClient.healthCheck("message-service")
                    .get(5, java.util.concurrent.TimeUnit.SECONDS);

            return Map.of(
                    "status", "OK",
                    "service", "message-service",
                    "timestamp", System.currentTimeMillis(),
                    "connection-scheme-service", schemeHealth.isSuccess() ? "AVAILABLE" : "UNAVAILABLE",
                    "device-auth-service", deviceAuthHealth.isSuccess() ? "AVAILABLE" : "UNAVAILABLE");
        } catch (Exception e) {
            log.error("Health check failed: ", e);
            return Map.of(
                    "status", "DEGRADED",
                    "service", "message-service",
                    "timestamp", System.currentTimeMillis(),
                    "error", e.getMessage());
        }
    }

    /**
     * Проверяет, является ли сообщение исходящим на основе contentType
     */
    private boolean isOutgoingMessage(MessageBLM message) {
        return CONTENT_TYPE_OUTGOING.equals(message.getContentType());
    }
}package com.connection.message;

import java.util.List;
import java.util.Map;
import java.util.UUID;

import com.connection.message.model.MessageBLM;
import com.connection.message.model.MessageDTO;

public interface MessageService {
    MessageBLM addMessage(String deviceAccessToken, MessageDTO messageDTO);
    MessageBLM getMessage(String deviceAccessToken, UUID messageUid);
    List<MessageBLM> getMessagesByBuffer(String deviceAccessToken, UUID bufferUid, String contentTypeFilter);
    void routeOutgoingMessage(String deviceAccessToken, UUID messageUid);
    void deleteMessage(String deviceAccessToken, UUID messageUid);
    Map<String, Object> getHealthStatus();
}// DeviceAuthKafkaAuthenticationFilter.java
package com.connection.message.client;

import java.io.IOException;
import java.util.Collections;

import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import com.connection.message.kafka.TypedDeviceAuthKafkaClient;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class DeviceAuthKafkaAuthenticationFilter extends OncePerRequestFilter {

    private final TypedDeviceAuthKafkaClient deviceAuthKafkaClient;
    private static final String DEVICE_ACCESS_TOKEN_HEADER = "Device-Access-Token";

    @Override
    protected void doFilterInternal(HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain) throws ServletException, IOException {

        String deviceAccessToken = request.getHeader(DEVICE_ACCESS_TOKEN_HEADER);

        if (deviceAccessToken == null || deviceAccessToken.trim().isEmpty()) {
            filterChain.doFilter(request, response);
            return;
        }

        try {
            authenticateWithDeviceToken(deviceAccessToken, request);
        } catch (Exception e) {
            log.error("Device authentication failed: {}", e.getMessage());
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            return;
        }

        filterChain.doFilter(request, response);
    }

    private void authenticateWithDeviceToken(String deviceAccessToken, HttpServletRequest request) {
        try {
            String cleanToken = deviceAccessToken.trim();

            log.info("Validating device access token");

            // Валидируем токен через device-auth сервис
            var validationFuture = deviceAuthKafkaClient.validateDeviceAccessToken(cleanToken, "message-service");
            var validationResponse = validationFuture.get(10, java.util.concurrent.TimeUnit.SECONDS);

            if (!validationResponse.isValid()) {
                throw new SecurityException("Device token validation failed: " + validationResponse.getErrorDetails());
            }

            // Извлекаем deviceUid из токена
            var deviceUidFuture = deviceAuthKafkaClient.extractDeviceUidFromAccessToken(cleanToken, "message-service");
            var deviceUidResponse = deviceUidFuture.get(10, java.util.concurrent.TimeUnit.SECONDS);

            if (!deviceUidResponse.isSuccess() || deviceUidResponse.getDeviceUid() == null) {
                throw new SecurityException("Failed to extract device UID from token");
            }

            // Создаем аутентификацию
            UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                    deviceUidResponse.getDeviceUid(),
                    null,
                    Collections.singletonList(new SimpleGrantedAuthority("ROLE_DEVICE")));

            authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
            SecurityContextHolder.getContext().setAuthentication(authentication);

            log.info("Successfully authenticated device: {}", deviceUidResponse.getDeviceUid());

        } catch (java.util.concurrent.TimeoutException e) {
            throw new SecurityException("Device token validation timeout");
        } catch (java.util.concurrent.ExecutionException e) {
            throw new SecurityException("Device token validation error: " + e.getCause().getMessage());
        } catch (Exception e) {
            throw new SecurityException("Device authentication failed: " + e.getMessage());
        }
    }
}// MessageServiceApplication.java
package com.connection.message;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MessageServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(MessageServiceApplication.class, args);
    }
}