package com.connection.message.config;

import io.swagger.v3.oas.annotations.enums.SecuritySchemeType;
import io.swagger.v3.oas.annotations.security.SecurityScheme;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@SecurityScheme(
    name = "bearerAuth",
    type = SecuritySchemeType.HTTP,
    bearerFormat = "JWT",
    scheme = "bearer"
)
public class SwaggerConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("Message Service API")
                        .version("1.0")
                        .description("API для управления сообщениями устрйоств"))
                .addSecurityItem(new SecurityRequirement().addList("bearerAuth"))
                .components(new Components()
                        .addSecuritySchemes("bearerAuth", 
                            new io.swagger.v3.oas.models.security.SecurityScheme()
                                .type(io.swagger.v3.oas.models.security.SecurityScheme.Type.HTTP)
                                .scheme("bearer")
                                .bearerFormat("JWT")));
    }
}// MessageResponse.java
package com.connection.message.controller;

import java.util.List;

import com.connection.message.model.MessageDTO;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class MessageResponse {
    private final List<MessageDTO> messageDTOs;
}// HealthResponse.java
package com.connection.message.controller;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class HealthResponse {
    private final String message;
}package com.connection.message.controller;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.UUID;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.connection.message.MessageService;
import com.connection.message.converter.MessageConverter;
import com.connection.message.model.MessageBLM;
import com.connection.message.model.MessageDTO;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/v1")
public class MessageController {
    
    // Константы для пагинации по умолчанию
    private static final int DEFAULT_OFFSET = 0;
    private static final int DEFAULT_LIMIT = 1;
    private static final int MAX_LIMIT = 1000;

    protected MessageConverter messageConverter;
    protected MessageService messageService;

    @PostMapping("/messages")
    public ResponseEntity<Void> addMessage(
            @RequestBody MessageDTO messageDTO) {
        throw new UnsupportedOperationException("Unimplemented method 'addMessage'");
    }

    @GetMapping("/messages/")
    public ResponseEntity<MessageResponse> getMessage(
            @RequestParam(required = false) List<UUID> schemeUids,
            @RequestParam(required = false) List<UUID> bufferUids,
            @RequestParam(required = false) List<UUID> deviceUids,
            @RequestParam(defaultValue = "false") Boolean deleteOnGet,
            @RequestParam(defaultValue = "" + DEFAULT_OFFSET) int offset,
            @RequestParam(defaultValue = "" + DEFAULT_LIMIT) int limit) {
        Set<MessageBLM> messageBLMs = new HashSet<>();
        log.info("Getting messages");

        if (schemeUids != null){
            for (UUID schemeUid : schemeUids){
                log.info("Getting messages for schemeUid: {}", schemeUid);
                messageBLMs.addAll(messageService.getMessagesByScheme(schemeUid, deleteOnGet, offset, limit));
            }
        }

        if (bufferUids != null){
            for (UUID bufferUid : bufferUids){
                log.info("Getting messages for bufferUid: {}", bufferUid);
                messageBLMs.addAll(messageService.getMessagesByScheme(bufferUid, deleteOnGet, offset, limit));
            }
        }

        if (deviceUids != null){
            for (UUID deviceUid : deviceUids){
                log.info("Getting messages for deviceUid: {}", deviceUid);
                messageBLMs.addAll(messageService.getMessagesByScheme(deviceUid, deleteOnGet, offset, limit));
            }
        }
        log.info("Got messages: {}", messageBLMs.size());

        List<MessageBLM> resultBLM = new ArrayList<>(messageBLMs);
        List<MessageDTO> resultDTO = resultBLM.stream().map(messageConverter::toDTO).toList();
        return ResponseEntity.ok().body( new MessageResponse(resultDTO));
    }

    @GetMapping("/health")
    public ResponseEntity<HealthResponse> healthCheck() {
        log.info("Health check: service: message-service, timestamp: {}",
                System.currentTimeMillis());

        return ResponseEntity.ok().body(new HealthResponse(messageService.health().toString()));

    }
}// MessagesListResponse.java
package com.connection.message.controller;

import com.connection.message.model.MessageDTO;

import lombok.AllArgsConstructor;
import lombok.Getter;

import java.util.List;

@AllArgsConstructor
@Getter
public class MessagesListResponse {
    private final List<MessageDTO> messages;
    private final PaginationInfo pagination;

    @AllArgsConstructor
    @Getter
    public static class PaginationInfo {
        private final int offset;
        private final int limit;
        private final int totalCount;
        private final boolean hasMore;
    }
}// ConnectionSchemeResponseConsumer.java
package com.connection.message.kafka;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Component;

import com.connection.common.events.CommandResponse;
import com.connection.scheme.events.responses.GetConnectionSchemeByUidResponse;
import com.connection.scheme.events.responses.HealthCheckResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class ConnectionSchemeResponseConsumer {

    private final TypedConnectionSchemeKafkaClient connectionSchemeKafkaClient;

    @KafkaListener(topics = "${app.kafka.topics.connection-scheme-responses:connection-scheme.responses}")
    public void handleConnectionSchemeResponse(ConsumerRecord<String, CommandResponse> record) {
        try {
            CommandResponse message = record.value();
            String correlationId = record.key();
            
            log.info("Received connection scheme response: correlationId={}", correlationId);
                
            if (message instanceof GetConnectionSchemeByUidResponse) {
                GetConnectionSchemeByUidResponse typedResponse = (GetConnectionSchemeByUidResponse) message;
                connectionSchemeKafkaClient.handleResponse(correlationId, typedResponse);
            } else if (message instanceof HealthCheckResponse) {
                HealthCheckResponse typedResponse = (HealthCheckResponse) message;
                connectionSchemeKafkaClient.handleResponse(correlationId, typedResponse);
            } else {
                log.warn("Unknown connection scheme response type for correlationId: {}", correlationId);
            }
            
        } catch (Exception e) {
            log.error("Error processing connection scheme response: correlationId={}", record.key(), e);
        }
    }
}package com.connection.message.kafka;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Component;

import com.connection.buffer.events.responses.GetBufferByUidResponse;
import com.connection.buffer.events.responses.GetBuffersByClientResponse;
import com.connection.buffer.events.responses.GetBuffersByConnectionSchemeResponse;
import com.connection.buffer.events.responses.GetBuffersByDeviceResponse;
import com.connection.buffer.events.responses.HealthCheckResponse;
import com.connection.common.events.CommandResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class BufferResponseConsumer {

    private final TypedBufferKafkaClient bufferKafkaClient;

    @KafkaListener(topics = "${app.kafka.topics.buffer-responses:buffer.responses}")
    public void handleBufferResponse(ConsumerRecord<String, CommandResponse> record) {
        try {
            CommandResponse message = record.value();
            String correlationId = record.key();
            
            log.info("Received buffer response: correlationId={}", correlationId);
                
            if (message instanceof GetBufferByUidResponse) {
                GetBufferByUidResponse typedResponse = (GetBufferByUidResponse) message;
                bufferKafkaClient.handleResponse(correlationId, typedResponse);
            } else if (message instanceof GetBuffersByClientResponse) {
                GetBuffersByClientResponse typedResponse = (GetBuffersByClientResponse) message;
                bufferKafkaClient.handleResponse(correlationId, typedResponse);
            } else if (message instanceof GetBuffersByDeviceResponse) {
                GetBuffersByDeviceResponse typedResponse = (GetBuffersByDeviceResponse) message;
                bufferKafkaClient.handleResponse(correlationId, typedResponse);
            } else if (message instanceof GetBuffersByConnectionSchemeResponse) {
                GetBuffersByConnectionSchemeResponse typedResponse = (GetBuffersByConnectionSchemeResponse) message;
                bufferKafkaClient.handleResponse(correlationId, typedResponse);
            } else if (message instanceof HealthCheckResponse) {
                HealthCheckResponse typedResponse = (HealthCheckResponse) message;
                bufferKafkaClient.handleResponse(correlationId, typedResponse);
            } else {
                log.warn("Unknown buffer response type for correlationId: {}", correlationId);
            }
            
        } catch (Exception e) {
            log.error("Error processing buffer response: correlationId={}", record.key(), e);
        }
    }
}package com.connection.message.kafka;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Component;

import com.connection.auth.events.responses.TokenValidationResponse;
import com.connection.common.events.CommandResponse;
import com.connection.auth.events.responses.ClientUidResponse;
import com.connection.auth.events.responses.HealthCheckResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class AuthResponseConsumer {

    private final TypedAuthKafkaClient authKafkaClient;

    @KafkaListener(topics = "${app.kafka.topics.auth-responses:auth.responses}")
    public void handleAuthResponse(ConsumerRecord<String, CommandResponse> record) {
        try {
            CommandResponse message = record.value();
            String correlationId = record.key();
            
            log.info("Received auth response: correlationId={}", correlationId);
                
            if (message instanceof TokenValidationResponse) {
                TokenValidationResponse typedResponse = (TokenValidationResponse) message;
                authKafkaClient.handleResponse(correlationId, typedResponse);
            } else if (message instanceof ClientUidResponse) {
                ClientUidResponse typedResponse = (ClientUidResponse) message;
                authKafkaClient.handleResponse(correlationId, typedResponse);
            } else if (message instanceof HealthCheckResponse) {
                HealthCheckResponse typedResponse = (HealthCheckResponse) message;
                authKafkaClient.handleResponse(correlationId, typedResponse);
            } else {
                log.warn("Unknown response type for correlationId: {}", correlationId);
            }
            
        } catch (Exception e) {
            log.error("Error processing auth response: correlationId={}", record.key(), e);
        }
    }
}package com.connection.message.kafka;

import java.util.Date;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

import com.connection.buffer.events.BufferEventConstants;
import com.connection.buffer.events.BufferEventUtils;
import com.connection.buffer.events.commands.GetBufferByUidCommand;
import com.connection.buffer.events.commands.GetBuffersByClientUidCommand;
import com.connection.buffer.events.commands.GetBuffersByConnectionSchemeUidCommand;
import com.connection.buffer.events.commands.GetBuffersByDeviceUidCommand;
import com.connection.buffer.events.commands.HealthCheckCommand;
import com.connection.buffer.events.responses.GetBufferByUidResponse;
import com.connection.buffer.events.responses.GetBuffersByClientResponse;
import com.connection.buffer.events.responses.GetBuffersByConnectionSchemeResponse;
import com.connection.buffer.events.responses.GetBuffersByDeviceResponse;
import com.connection.buffer.events.responses.HealthCheckResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class TypedBufferKafkaClient {

    private final KafkaTemplate<String, Object> kafkaTemplate;
    
    private final Map<String, PendingRequest<?>> pendingRequests = new ConcurrentHashMap<>();

    private static class PendingRequest<T> {
        final CompletableFuture<T> future;
        final Class<T> responseType;

        PendingRequest(CompletableFuture<T> future, Class<T> responseType) {
            this.future = future;
            this.responseType = responseType;
        }
    }

    public CompletableFuture<GetBufferByUidResponse> getBufferByUid(UUID bufferUid, String sourceService) {
        return sendRequest(
            GetBufferByUidCommand.builder()
                .bufferUid(bufferUid)
                .sourceService(sourceService)
                .replyTopic(BufferEventConstants.BUFFER_RESPONSES_TOPIC)
                .correlationId(BufferEventUtils.generateCorrelationId())
                .build(),
            GetBufferByUidResponse.class
        );
    }

    public CompletableFuture<GetBuffersByClientResponse> getBuffersByClientUid(UUID clientUid, String sourceService) {
        return sendRequest(
            GetBuffersByClientUidCommand.builder()
                .clientUid(clientUid)
                .sourceService(sourceService)
                .replyTopic(BufferEventConstants.BUFFER_RESPONSES_TOPIC)
                .correlationId(BufferEventUtils.generateCorrelationId())
                .build(),
            GetBuffersByClientResponse.class
        );
    }

    public CompletableFuture<GetBuffersByDeviceResponse> getBuffersByDeviceUid(UUID deviceUid, String sourceService) {
        return sendRequest(
            GetBuffersByDeviceUidCommand.builder()
                .deviceUid(deviceUid)
                .sourceService(sourceService)
                .replyTopic(BufferEventConstants.BUFFER_RESPONSES_TOPIC)
                .correlationId(BufferEventUtils.generateCorrelationId())
                .build(),
            GetBuffersByDeviceResponse.class
        );
    }

    public CompletableFuture<GetBuffersByConnectionSchemeResponse> getBuffersByConnectionSchemeUid(UUID connectionSchemeUid, String sourceService) {
        return sendRequest(
            GetBuffersByConnectionSchemeUidCommand.builder()
                .connectionSchemeUid(connectionSchemeUid)
                .sourceService(sourceService)
                .replyTopic(BufferEventConstants.BUFFER_RESPONSES_TOPIC)
                .correlationId(BufferEventUtils.generateCorrelationId())
                .build(),
            GetBuffersByConnectionSchemeResponse.class
        );
    }

    public CompletableFuture<HealthCheckResponse> healthCheck(String sourceService) {
        return sendRequest(
            HealthCheckCommand.builder()
                .eventId(UUID.randomUUID().toString())
                .sourceService(sourceService)
                .timestamp(new Date().toInstant())
                .replyTopic(BufferEventConstants.BUFFER_RESPONSES_TOPIC)
                .correlationId(BufferEventUtils.generateCorrelationId())
                .commandType(BufferEventConstants.COMMAND_HEALTH_CHECK)
                .build(),
            HealthCheckResponse.class
        );
    }

    private <T> CompletableFuture<T> sendRequest(Object command, Class<T> responseType) {
        String correlationId;
        
        if (command instanceof GetBufferByUidCommand) {
            correlationId = ((GetBufferByUidCommand) command).getCorrelationId();
        } else if (command instanceof GetBuffersByClientUidCommand) {
            correlationId = ((GetBuffersByClientUidCommand) command).getCorrelationId();
        } else if (command instanceof GetBuffersByDeviceUidCommand) {
            correlationId = ((GetBuffersByDeviceUidCommand) command).getCorrelationId();
        } else if (command instanceof GetBuffersByConnectionSchemeUidCommand) {
            correlationId = ((GetBuffersByConnectionSchemeUidCommand) command).getCorrelationId();
        } else if (command instanceof HealthCheckCommand) {
            correlationId = ((HealthCheckCommand) command).getCorrelationId();
        } else {
            throw new IllegalArgumentException("Unsupported command type: " + command.getClass());
        }

        CompletableFuture<T> future = new CompletableFuture<>();
        pendingRequests.put(correlationId, new PendingRequest<>(future, responseType));

        kafkaTemplate.send(BufferEventConstants.BUFFER_COMMANDS_TOPIC, correlationId, command)
                .whenComplete((result, ex) -> {
                    if (ex != null) {
                        future.completeExceptionally(ex);
                        pendingRequests.remove(correlationId);
                        log.error("Failed to send buffer command: {}", ex.getMessage());
                    }
                });

        return future;
    }

    @SuppressWarnings("unchecked")
    public void handleResponse(String correlationId, Object response) {
        PendingRequest<?> pendingRequest = pendingRequests.remove(correlationId);
        if (pendingRequest != null) {
            try {
                if (pendingRequest.responseType.isInstance(response)) {
                    CompletableFuture<Object> future = (CompletableFuture<Object>) pendingRequest.future;
                    future.complete(response);
                } else {
                    log.warn("Type mismatch for correlationId: {}. Expected: {}, Got: {}", 
                            correlationId, pendingRequest.responseType, response.getClass());
                    pendingRequest.future.completeExceptionally(
                        new ClassCastException("Type mismatch in buffer response")
                    );
                }
            } catch (Exception e) {
                pendingRequest.future.completeExceptionally(e);
            }
        } else {
            log.warn("Received buffer response for unknown correlationId: {}", correlationId);
        }
    }
}package com.connection.message.kafka;

import java.util.Date;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

import com.connection.auth.events.AuthEventConstants;
import com.connection.auth.events.AuthEventUtils;
import com.connection.auth.events.commands.ExtractClientUidCommand;
import com.connection.auth.events.commands.HealthCheckCommand;
import com.connection.auth.events.commands.ValidateTokenCommand;
import com.connection.auth.events.responses.ClientUidResponse;
import com.connection.auth.events.responses.HealthCheckResponse;
import com.connection.auth.events.responses.TokenValidationResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class TypedAuthKafkaClient {

    private final KafkaTemplate<String, Object> kafkaTemplate;
    
    private final Map<String, PendingRequest<?>> pendingRequests = new ConcurrentHashMap<>();

    private static class PendingRequest<T> {
        final CompletableFuture<T> future;
        final Class<T> responseType;

        PendingRequest(CompletableFuture<T> future, Class<T> responseType) {
            this.future = future;
            this.responseType = responseType;
        }
    }

    public CompletableFuture<TokenValidationResponse> validateToken(String token, String sourceService) {
        return sendRequest(
            ValidateTokenCommand.builder()
                .token(token)
                .tokenType(ValidateTokenCommand.TokenType.ACCESS)
                .sourceService(sourceService)
                .replyTopic(AuthEventConstants.AUTH_RESPONSES_TOPIC)
                .correlationId(AuthEventUtils.generateCorrelationId())
                .build(),
            TokenValidationResponse.class
        );
    }

    public CompletableFuture<ClientUidResponse> getClientUid(String token, String sourceService) {
        return sendRequest(
            ExtractClientUidCommand.builder()
                .token(token)
                .tokenType(ExtractClientUidCommand.TokenType.ACCESS)
                .sourceService(sourceService)
                .replyTopic(AuthEventConstants.AUTH_RESPONSES_TOPIC)
                .correlationId(AuthEventUtils.generateCorrelationId())
                .build(),
            ClientUidResponse.class
        );
    }

    public CompletableFuture<HealthCheckResponse> healthCheck(String sourceService) {
        return sendRequest(
            HealthCheckCommand.builder()
                .eventId(UUID.randomUUID().toString())
                .sourceService(sourceService)
                .timestamp(new Date().toInstant())
                .replyTopic(AuthEventConstants.AUTH_RESPONSES_TOPIC)
                .correlationId(AuthEventUtils.generateCorrelationId())
                .commandType(AuthEventConstants.COMMAND_HEALTH_CHECK)
                .build(),
            HealthCheckResponse.class
        );
    }

    private <T> CompletableFuture<T> sendRequest(Object command, Class<T> responseType) {
        String correlationId;
        
        if (command instanceof ValidateTokenCommand) {
            correlationId = ((ValidateTokenCommand) command).getCorrelationId();
        } else if (command instanceof ExtractClientUidCommand) {
            correlationId = ((ExtractClientUidCommand) command).getCorrelationId();
        } else if (command instanceof HealthCheckCommand) {
            correlationId = ((HealthCheckCommand) command).getCorrelationId();
        } else {
            throw new IllegalArgumentException("Unsupported command type: " + command.getClass());
        }

        CompletableFuture<T> future = new CompletableFuture<>();
        pendingRequests.put(correlationId, new PendingRequest<>(future, responseType));

        kafkaTemplate.send(AuthEventConstants.AUTH_COMMANDS_TOPIC, correlationId, command)
                .whenComplete((result, ex) -> {
                    if (ex != null) {
                        future.completeExceptionally(ex);
                        pendingRequests.remove(correlationId);
                        log.error("Failed to send command: {}", ex.getMessage());
                    }
                });

        return future;
    }

    @SuppressWarnings("unchecked")
    public void handleResponse(String correlationId, Object response) {
        PendingRequest<?> pendingRequest = pendingRequests.remove(correlationId);
        if (pendingRequest != null) {
            try {
                if (pendingRequest.responseType.isInstance(response)) {
                    CompletableFuture<Object> future = (CompletableFuture<Object>) pendingRequest.future;
                    future.complete(response);
                } else {
                    log.warn("Type mismatch for correlationId: {}. Expected: {}, Got: {}", 
                            correlationId, pendingRequest.responseType, response.getClass());
                    pendingRequest.future.completeExceptionally(
                        new ClassCastException("Type mismatch in response")
                    );
                }
            } catch (Exception e) {
                pendingRequest.future.completeExceptionally(e);
            }
        } else {
            log.warn("Received response for unknown correlationId: {}", correlationId);
        }
    }
}// TypedDeviceKafkaClient.java
package com.connection.message.kafka;

import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

import com.connection.device.events.DeviceEventConstants;
import com.connection.device.events.DeviceEventUtils;
import com.connection.device.events.commands.GetDeviceByUidCommand;
import com.connection.device.events.commands.GetDevicesByClientUid;
import com.connection.device.events.commands.HealthCheckCommand;
import com.connection.device.events.responses.GetDeviceByUidResponse;
import com.connection.device.events.responses.GetDevicesByClientResponse;
import com.connection.device.events.responses.HealthCheckResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class TypedDeviceKafkaClient {

    private final KafkaTemplate<String, Object> kafkaTemplate;
    private final Map<String, PendingRequest<?>> pendingRequests = new ConcurrentHashMap<>();

    private static class PendingRequest<T> {
        final CompletableFuture<T> future;
        final Class<T> responseType;

        PendingRequest(CompletableFuture<T> future, Class<T> responseType) {
            this.future = future;
            this.responseType = responseType;
        }
    }

    public CompletableFuture<GetDeviceByUidResponse> getDeviceByUid(UUID deviceUid, String sourceService) {
        return sendRequest(
            GetDeviceByUidCommand.builder()
                .deviceUid(deviceUid)
                .sourceService(sourceService)
                .replyTopic(DeviceEventConstants.DEVICE_RESPONSES_TOPIC)
                .correlationId(DeviceEventUtils.generateCorrelationId())
                .build(),
            GetDeviceByUidResponse.class
        );
    }

    public CompletableFuture<GetDevicesByClientResponse> getDevicesByClient(UUID clientUid, String sourceService) {
        return sendRequest(
            GetDevicesByClientUid.builder()
                .clientUid(clientUid)
                .sourceService(sourceService)
                .replyTopic(DeviceEventConstants.DEVICE_RESPONSES_TOPIC)
                .correlationId(DeviceEventUtils.generateCorrelationId())
                .build(),
            GetDevicesByClientResponse.class
        );
    }

    public CompletableFuture<HealthCheckResponse> healthCheck(String sourceService) {
        return sendRequest(
            HealthCheckCommand.builder()
                .sourceService(sourceService)
                .replyTopic(DeviceEventConstants.DEVICE_RESPONSES_TOPIC)
                .correlationId(DeviceEventUtils.generateCorrelationId())
                .build(),
            HealthCheckResponse.class
        );
    }

    // Вспомогательные методы для удобства
    public boolean deviceExistsAndBelongsToClient(UUID deviceUid) {
        try {
            GetDeviceByUidResponse response = getDeviceByUid(deviceUid, "buffer-service")
                    .get(10, java.util.concurrent.TimeUnit.SECONDS);
            return response.isSuccess() && response.getDeviceDTO() != null;
        } catch (Exception e) {
            log.error("Error checking device existence: {}", e.getMessage());
            return false;
        }
    }

    public List<UUID> getClientDeviceUids(UUID clientUid) {
        try {
            GetDevicesByClientResponse response = getDevicesByClient(clientUid, "buffer-service")
                    .get(10, java.util.concurrent.TimeUnit.SECONDS);
            
            if (response.isSuccess() && response.getDeviceDTOs() != null) {
                return response.getDeviceDTOs().stream()
                        .map(device -> UUID.fromString(device.getUid()))
                        .collect(java.util.stream.Collectors.toList());
            }
            return List.of();
        } catch (Exception e) {
            log.error("Error getting client devices: {}", e.getMessage());
            return List.of();
        }
    }

    private <T> CompletableFuture<T> sendRequest(Object command, Class<T> responseType) {
        String correlationId = extractCorrelationId(command);
        
        CompletableFuture<T> future = new CompletableFuture<>();
        pendingRequests.put(correlationId, new PendingRequest<>(future, responseType));

        kafkaTemplate.send(DeviceEventConstants.DEVICE_COMMANDS_TOPIC, correlationId, command)
                .whenComplete((result, ex) -> {
                    if (ex != null) {
                        future.completeExceptionally(ex);
                        pendingRequests.remove(correlationId);
                        log.error("Failed to send device command: {}", ex.getMessage());
                    }
                });

        return future;
    }

    @SuppressWarnings("unchecked")
    public void handleResponse(String correlationId, Object response) {
        PendingRequest<?> pendingRequest = pendingRequests.remove(correlationId);
        if (pendingRequest != null) {
            try {
                if (pendingRequest.responseType.isInstance(response)) {
                    CompletableFuture<Object> future = (CompletableFuture<Object>) pendingRequest.future;
                    future.complete(response);
                } else {
                    log.warn("Type mismatch for correlationId: {}. Expected: {}, Got: {}", 
                            correlationId, pendingRequest.responseType, response.getClass());
                    pendingRequest.future.completeExceptionally(
                        new ClassCastException("Type mismatch in device response")
                    );
                }
            } catch (Exception e) {
                pendingRequest.future.completeExceptionally(e);
            }
        } else {
            log.warn("Received device response for unknown correlationId: {}", correlationId);
        }
    }

    private String extractCorrelationId(Object command) {
        if (command instanceof GetDeviceByUidCommand) {
            return ((GetDeviceByUidCommand) command).getCorrelationId();
        } else if (command instanceof GetDevicesByClientUid) {
            return ((GetDevicesByClientUid) command).getCorrelationId();
        } else if (command instanceof HealthCheckCommand) {
            return ((HealthCheckCommand) command).getCorrelationId();
        } else {
            throw new IllegalArgumentException("Unsupported device command type: " + command.getClass());
        }
    }
}// TypedConnectionSchemeKafkaClient.java
package com.connection.message.kafka;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

import com.connection.scheme.events.ConnectionSchemeEventConstants;
import com.connection.scheme.events.ConnectionSchemeEventUtils;
import com.connection.scheme.events.commands.GetConnectionSchemeByUidCommand;
import com.connection.scheme.events.commands.GetConnectionSchemesByBufferUid;
import com.connection.scheme.events.commands.HealthCheckCommand;
import com.connection.scheme.events.responses.GetConnectionSchemeByUidResponse;
import com.connection.scheme.events.responses.GetConnectionSchemesByBufferResponse;
import com.connection.scheme.events.responses.HealthCheckResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class TypedConnectionSchemeKafkaClient {

    private final KafkaTemplate<String, Object> kafkaTemplate;
    private final Map<String, PendingRequest<?>> pendingRequests = new ConcurrentHashMap<>();

    private static class PendingRequest<T> {
        final CompletableFuture<T> future;
        final Class<T> responseType;

        PendingRequest(CompletableFuture<T> future, Class<T> responseType) {
            this.future = future;
            this.responseType = responseType;
        }
    }

    public CompletableFuture<GetConnectionSchemeByUidResponse> getConnectionSchemeByUid(UUID connectionSchemeUid, String sourceService) {
        return sendRequest(
            GetConnectionSchemeByUidCommand.builder()
                .connectionSchemeUid(connectionSchemeUid)
                .sourceService(sourceService)
                .replyTopic(ConnectionSchemeEventConstants.CONNECTION_SCHEME_RESPONSES_TOPIC)
                .correlationId(ConnectionSchemeEventUtils.generateCorrelationId())
                .build(),
            GetConnectionSchemeByUidResponse.class
        );
    }

    public CompletableFuture<GetConnectionSchemesByBufferResponse> getConnectionSchemesByBufferUid(UUID bufferUid, String sourceService) {
        return sendRequest(
            GetConnectionSchemesByBufferUid.builder()
                .bufferUid(bufferUid)
                .sourceService(sourceService)
                .replyTopic(ConnectionSchemeEventConstants.CONNECTION_SCHEME_RESPONSES_TOPIC)
                .correlationId(ConnectionSchemeEventUtils.generateCorrelationId())
                .build(),
            GetConnectionSchemesByBufferResponse.class
        );
    }

    public CompletableFuture<HealthCheckResponse> healthCheck(String sourceService) {
        return sendRequest(
            HealthCheckCommand.builder()
                .sourceService(sourceService)
                .replyTopic(ConnectionSchemeEventConstants.CONNECTION_SCHEME_RESPONSES_TOPIC)
                .correlationId(ConnectionSchemeEventUtils.generateCorrelationId())
                .build(),
            HealthCheckResponse.class
        );
    }

    // Вспомогательные методы для удобства
    public boolean connectionSchemeExistsAndBelongsToClient(UUID connectionSchemeUid) {
        try {
            GetConnectionSchemeByUidResponse response = getConnectionSchemeByUid(connectionSchemeUid, "buffer-service")
                    .get(10, java.util.concurrent.TimeUnit.SECONDS);
            return response.isSuccess() && response.getConnectionSchemeDTO() != null;
        } catch (Exception e) {
            log.error("Error checking connection scheme existence: {}", e.getMessage());
            return false;
        }
    }

    private <T> CompletableFuture<T> sendRequest(Object command, Class<T> responseType) {
        String correlationId = extractCorrelationId(command);
        
        CompletableFuture<T> future = new CompletableFuture<>();
        pendingRequests.put(correlationId, new PendingRequest<>(future, responseType));

        kafkaTemplate.send(ConnectionSchemeEventConstants.CONNECTION_SCHEME_COMMANDS_TOPIC, correlationId, command)
                .whenComplete((result, ex) -> {
                    if (ex != null) {
                        future.completeExceptionally(ex);
                        pendingRequests.remove(correlationId);
                        log.error("Failed to send connection scheme command: {}", ex.getMessage());
                    }
                });

        return future;
    }

    @SuppressWarnings("unchecked")
    public void handleResponse(String correlationId, Object response) {
        PendingRequest<?> pendingRequest = pendingRequests.remove(correlationId);
        if (pendingRequest != null) {
            try {
                if (pendingRequest.responseType.isInstance(response)) {
                    CompletableFuture<Object> future = (CompletableFuture<Object>) pendingRequest.future;
                    future.complete(response);
                } else {
                    log.warn("Type mismatch for correlationId: {}. Expected: {}, Got: {}", 
                            correlationId, pendingRequest.responseType, response.getClass());
                    pendingRequest.future.completeExceptionally(
                        new ClassCastException("Type mismatch in connection scheme response")
                    );
                }
            } catch (Exception e) {
                pendingRequest.future.completeExceptionally(e);
            }
        } else {
            log.warn("Received connection scheme response for unknown correlationId: {}", correlationId);
        }
    }

    private String extractCorrelationId(Object command) {
        if (command instanceof GetConnectionSchemeByUidCommand) {
            return ((GetConnectionSchemeByUidCommand) command).getCorrelationId();
        } else if (command instanceof HealthCheckCommand) {
            return ((HealthCheckCommand) command).getCorrelationId();
        } else {
            throw new IllegalArgumentException("Unsupported connection scheme command type: " + command.getClass());
        }
    }
}// DeviceResponseConsumer.java
package com.connection.message.kafka;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Component;

import com.connection.common.events.CommandResponse;
import com.connection.device.events.responses.GetDeviceByUidResponse;
import com.connection.device.events.responses.GetDevicesByClientResponse;
import com.connection.device.events.responses.HealthCheckResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class DeviceResponseConsumer {

    private final TypedDeviceKafkaClient deviceKafkaClient;

    @KafkaListener(topics = "${app.kafka.topics.device-responses:device.responses}")
    public void handleDeviceResponse(ConsumerRecord<String, CommandResponse> record) {
        try {
            CommandResponse message = record.value();
            String correlationId = record.key();
            
            log.info("Received device response: correlationId={}", correlationId);
                
            if (message instanceof GetDeviceByUidResponse) {
                GetDeviceByUidResponse typedResponse = (GetDeviceByUidResponse) message;
                deviceKafkaClient.handleResponse(correlationId, typedResponse);
            } else if (message instanceof GetDevicesByClientResponse) {
                GetDevicesByClientResponse typedResponse = (GetDevicesByClientResponse) message;
                deviceKafkaClient.handleResponse(correlationId, typedResponse);
            } else if (message instanceof HealthCheckResponse) {
                HealthCheckResponse typedResponse = (HealthCheckResponse) message;
                deviceKafkaClient.handleResponse(correlationId, typedResponse);
            } else {
                log.warn("Unknown device response type for correlationId: {}", correlationId);
            }
            
        } catch (Exception e) {
            log.error("Error processing device response: correlationId={}", record.key(), e);
        }
    }
}package com.connection.message.kafka;

import java.util.Date;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

import com.connection.device.auth.events.DeviceAuthEventConstants;
import com.connection.device.auth.events.DeviceAuthEventUtils;
import com.connection.device.auth.events.commands.ExtractDeviceUidCommand;
import com.connection.device.auth.events.commands.HealthCheckCommand;
import com.connection.device.auth.events.commands.ValidateTokenCommand;
import com.connection.device.auth.events.responses.DeviceUidResponse;
import com.connection.device.auth.events.responses.HealthCheckResponse;
import com.connection.device.auth.events.responses.TokenValidationResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class TypedDeviceAuthKafkaClient {

    private final KafkaTemplate<String, Object> kafkaTemplate;
    
    private final Map<String, PendingRequest<?>> pendingRequests = new ConcurrentHashMap<>();

    private static class PendingRequest<T> {
        final CompletableFuture<T> future;
        final Class<T> responseType;

        PendingRequest(CompletableFuture<T> future, Class<T> responseType) {
            this.future = future;
            this.responseType = responseType;
        }
    }

    public CompletableFuture<TokenValidationResponse> validateToken(String token, String sourceService) {
        return sendRequest(
            ValidateTokenCommand.builder()
                .token(token)
                .tokenType(ValidateTokenCommand.TokenType.ACCESS)
                .sourceService(sourceService)
                .replyTopic(DeviceAuthEventConstants.DEVICE_AUTH_RESPONSES_TOPIC)
                .correlationId(DeviceAuthEventUtils.generateCorrelationId())
                .build(),
            TokenValidationResponse.class
        );
    }

    public CompletableFuture<TokenValidationResponse> validateDeviceToken(String token, String sourceService) {
        return sendRequest(
            ValidateTokenCommand.builder()
                .token(token)
                .tokenType(ValidateTokenCommand.TokenType.ACCESS)
                .sourceService(sourceService)
                .replyTopic(DeviceAuthEventConstants.DEVICE_AUTH_RESPONSES_TOPIC)
                .correlationId(DeviceAuthEventUtils.generateCorrelationId())
                .build(),
            TokenValidationResponse.class
        );
    }

    public CompletableFuture<DeviceUidResponse> getDeviceUid(String token, String sourceService) {
        return sendRequest(
            ExtractDeviceUidCommand.builder()
                .token(token)
                .tokenType(ExtractDeviceUidCommand.TokenType.ACCESS)
                .sourceService(sourceService)
                .replyTopic(DeviceAuthEventConstants.DEVICE_AUTH_RESPONSES_TOPIC)
                .correlationId(DeviceAuthEventUtils.generateCorrelationId())
                .build(),
            DeviceUidResponse.class
        );
    }

    public CompletableFuture<DeviceUidResponse> getDeviceUidFromDeviceToken(String token, String sourceService) {
        return sendRequest(
            ExtractDeviceUidCommand.builder()
                .token(token)
                .tokenType(ExtractDeviceUidCommand.TokenType.ACCESS)
                .sourceService(sourceService)
                .replyTopic(DeviceAuthEventConstants.DEVICE_AUTH_RESPONSES_TOPIC)
                .correlationId(DeviceAuthEventUtils.generateCorrelationId())
                .build(),
            DeviceUidResponse.class
        );
    }

    public CompletableFuture<HealthCheckResponse> healthCheck(String sourceService) {
        return sendRequest(
            HealthCheckCommand.builder()
                .eventId(UUID.randomUUID().toString())
                .sourceService(sourceService)
                .timestamp(new Date().toInstant())
                .replyTopic(DeviceAuthEventConstants.DEVICE_AUTH_RESPONSES_TOPIC)
                .correlationId(DeviceAuthEventUtils.generateCorrelationId())
                .commandType(DeviceAuthEventConstants.COMMAND_HEALTH_CHECK)
                .build(),
            HealthCheckResponse.class
        );
    }

    private <T> CompletableFuture<T> sendRequest(Object command, Class<T> responseType) {
        String correlationId;
        
        if (command instanceof ValidateTokenCommand) {
            correlationId = ((ValidateTokenCommand) command).getCorrelationId();
        } else if (command instanceof ExtractDeviceUidCommand) {
            correlationId = ((ExtractDeviceUidCommand) command).getCorrelationId();
        } else if (command instanceof HealthCheckCommand) {
            correlationId = ((HealthCheckCommand) command).getCorrelationId();
        } else {
            throw new IllegalArgumentException("Unsupported command type: " + command.getClass());
        }

        CompletableFuture<T> future = new CompletableFuture<>();
        pendingRequests.put(correlationId, new PendingRequest<>(future, responseType));

        kafkaTemplate.send(DeviceAuthEventConstants.DEVICE_AUTH_COMMANDS_TOPIC, correlationId, command)
                .whenComplete((result, ex) -> {
                    if (ex != null) {
                        future.completeExceptionally(ex);
                        pendingRequests.remove(correlationId);
                        log.error("Failed to send device auth command: {}", ex.getMessage());
                    }
                });

        return future;
    }

    @SuppressWarnings("unchecked")
    public void handleResponse(String correlationId, Object response) {
        PendingRequest<?> pendingRequest = pendingRequests.remove(correlationId);
        if (pendingRequest != null) {
            try {
                if (pendingRequest.responseType.isInstance(response)) {
                    CompletableFuture<Object> future = (CompletableFuture<Object>) pendingRequest.future;
                    future.complete(response);
                } else {
                    log.warn("Type mismatch for correlationId: {}. Expected: {}, Got: {}", 
                            correlationId, pendingRequest.responseType, response.getClass());
                    pendingRequest.future.completeExceptionally(
                        new ClassCastException("Type mismatch in device auth response")
                    );
                }
            } catch (Exception e) {
                pendingRequest.future.completeExceptionally(e);
            }
        } else {
            log.warn("Received device auth response for unknown correlationId: {}", correlationId);
        }
    }
}package com.connection.message.kafka;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Component;

import com.connection.device.auth.events.responses.TokenValidationResponse;
import com.connection.common.events.CommandResponse;
import com.connection.device.auth.events.responses.DeviceUidResponse;
import com.connection.device.auth.events.responses.HealthCheckResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class DeviceAuthResponseConsumer {

    private final TypedDeviceAuthKafkaClient deviceAuthKafkaClient;

    @KafkaListener(topics = "${app.kafka.topics.device-auth-responses:device.auth.responses}")
    public void handleDeviceAuthResponse(ConsumerRecord<String, CommandResponse> record) {
        try {
            CommandResponse message = record.value();
            String correlationId = record.key();
            
            log.info("Received device auth response: correlationId={}", correlationId);
                
            if (message instanceof TokenValidationResponse) {
                TokenValidationResponse typedResponse = (TokenValidationResponse) message;
                deviceAuthKafkaClient.handleResponse(correlationId, typedResponse);
            } else if (message instanceof DeviceUidResponse) {
                DeviceUidResponse typedResponse = (DeviceUidResponse) message;
                deviceAuthKafkaClient.handleResponse(correlationId, typedResponse);
            } else if (message instanceof HealthCheckResponse) {
                HealthCheckResponse typedResponse = (HealthCheckResponse) message;
                deviceAuthKafkaClient.handleResponse(correlationId, typedResponse);
            } else {
                log.warn("Unknown device auth response type for correlationId: {}", correlationId);
            }
            
        } catch (Exception e) {
            log.error("Error processing device auth response: correlationId={}", record.key(), e);
        }
    }
}package com.connection.message;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration;
import org.springframework.stereotype.Service;

import com.connection.buffer.events.responses.GetBuffersByConnectionSchemeResponse;
import com.connection.buffer.events.responses.GetBuffersByDeviceResponse;
import com.connection.device.converter.DeviceConverter;
import com.connection.message.converter.MessageConverter;
import com.connection.message.kafka.TypedAuthKafkaClient;
import com.connection.message.kafka.TypedBufferKafkaClient;
import com.connection.message.kafka.TypedConnectionSchemeKafkaClient;
import com.connection.message.kafka.TypedDeviceAuthKafkaClient;
import com.connection.message.kafka.TypedDeviceKafkaClient;
import com.connection.message.model.MessageBLM;
import com.connection.message.model.MessageDALM;
import com.connection.message.repository.MessageRepository;
import com.connection.message.validator.MessageValidator;
import com.connection.processing.buffer.converter.BufferConverter;
import com.connection.processing.buffer.model.BufferBLM;
import com.connection.processing.buffer.model.BufferDTO;
import com.connection.scheme.converter.ConnectionSchemeConverter;
import com.connection.scheme.events.responses.GetConnectionSchemesByBufferResponse;
import com.connection.scheme.model.ConnectionSchemeBLM;
import com.connection.scheme.model.ConnectionSchemeDTO;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RequiredArgsConstructor
@Service
@EnableAutoConfiguration(exclude = {
        JpaRepositoriesAutoConfiguration.class
})
public class MessageServiceImpl implements MessageService {

    protected MessageRepository messageRepository;
    protected MessageValidator messageValidator;

    protected TypedAuthKafkaClient authKafkaClient;
    protected TypedBufferKafkaClient bufferKafkaClient;
    protected TypedConnectionSchemeKafkaClient connectionSchemeKafkaClient;
    protected TypedDeviceAuthKafkaClient deviceAuthKafkaClient;
    protected TypedDeviceKafkaClient deviceKafkaClient;

    protected BufferConverter bufferConverter;
    protected ConnectionSchemeConverter connectionSchemeConverter;
    protected DeviceConverter deviceConverter;
    protected MessageConverter messageConverter;

    @Override
    public void addMessage(MessageBLM messageBLM) {
        messageValidator.validate(messageBLM);
        MessageDALM messageDALM = messageConverter.toDALM(messageBLM);
        messageRepository.add(messageDALM);
        processMessageMovement(messageBLM);
    }

    @Override
    public List<MessageBLM> getMessagesByBuffer(UUID bufferUuid, boolean deleteOnGet, int offset, int limit) {
        List<MessageDALM> messageDALMs = messageRepository.findByBufferUid(bufferUuid)
                .stream()
                .sorted((x, y) -> {
                    return x.getCreatedAt().compareTo(y.getCreatedAt());
                })
                .toList()
                .subList(offset, offset + limit);

        List<MessageBLM> messageBLMs = messageDALMs.stream()
                .<MessageBLM>map(messageConverter::toBLM)
                .toList();

        if (deleteOnGet)
            messageBLMs.forEach(this::deleteMessage);

        return messageBLMs;
    }

    @Override
    public List<MessageBLM> getMessagesByScheme(UUID schemeUuid, boolean deleteOnGet, int offset, int limit) {
        List<BufferBLM> bufferBLMs = getSchemeBuffers(schemeUuid);
        Set<MessageBLM> set = new HashSet<>();
        for (BufferBLM b : bufferBLMs) {
            set.addAll(getMessagesByBuffer(b.getUid(), deleteOnGet, offset, limit));
        }
        List<MessageBLM> rMessageBLMs = new ArrayList<>(set)
                .stream()
                .sorted((x, y) -> {
                    return x.getCreatedAt().compareTo(y.getCreatedAt());
                })
                .toList()
                .subList(offset, offset + limit);
        if (deleteOnGet)
            rMessageBLMs.forEach(this::deleteMessage);
        return rMessageBLMs;
    }

    @Override
    public List<MessageBLM> getMessagesByDevice(UUID devicUuid, boolean deleteOnGet, int offset, int limit) {
        List<BufferBLM> bufferBLMs = getDeviceBuffers(devicUuid);
        Set<MessageBLM> set = new HashSet<>();
        for (BufferBLM b : bufferBLMs) {
            set.addAll(getMessagesByBuffer(b.getUid(), deleteOnGet, offset, limit));
        }
        List<MessageBLM> rMessageBLMs = new ArrayList<>(set)
                .stream()
                .sorted((x, y) -> {
                    return x.getCreatedAt().compareTo(y.getCreatedAt());
                })
                .toList()
                .subList(offset, offset + limit);
        if (deleteOnGet)
            rMessageBLMs.forEach(this::deleteMessage);
        return rMessageBLMs;
    }

    @Override
    public Map<String, String> health() {
        try {
            com.connection.auth.events.responses.HealthCheckResponse authHealth = authKafkaClient
                    .healthCheck("message-service")
                    .get(5, java.util.concurrent.TimeUnit.SECONDS);

            com.connection.buffer.events.responses.HealthCheckResponse buufferHealth = bufferKafkaClient
                    .healthCheck("message-service")
                    .get(5, java.util.concurrent.TimeUnit.SECONDS);

            com.connection.scheme.events.responses.HealthCheckResponse connectionSchemeHealth = connectionSchemeKafkaClient
                    .healthCheck("message-service")
                    .get(5, java.util.concurrent.TimeUnit.SECONDS);

            com.connection.device.events.responses.HealthCheckResponse deviceHealth = deviceKafkaClient
                    .healthCheck("message-service")
                    .get(5, java.util.concurrent.TimeUnit.SECONDS);

            com.connection.device.auth.events.responses.HealthCheckResponse deviceAuthHealth = deviceAuthKafkaClient
                    .healthCheck("message-service")
                    .get(5, java.util.concurrent.TimeUnit.SECONDS);

            return Map.of(
                    "status", "OK",
                    "service", "message-service",
                    "timestamp", String.valueOf(System.currentTimeMillis()),
                    "auth-service", authHealth.isSuccess() ? "AVAILABLE" : "UNAVAILABLE",
                    "auth-service", buufferHealth.isSuccess() ? "AVAILABLE" : "UNAVAILABLE",
                    "auth-service", connectionSchemeHealth.isSuccess() ? "AVAILABLE" : "UNAVAILABLE",
                    "device-service", deviceHealth.isSuccess() ? "AVAILABLE" : "UNAVAILABLE",
                    "device-auth-service", deviceAuthHealth.isSuccess() ? "AVAILABLE" : "UNAVAILABLE",
                    "database", "CONNECTED");

        } catch (Exception e) {
            log.error("Health check error: ", e);
            return Map.of(
                    "status", "DEGRADED",
                    "service", "buffer-service",
                    "timestamp", String.valueOf(System.currentTimeMillis()),
                    "error", e.getMessage());
        }
    }

    private void processMessageMovement(MessageBLM messageBLM) {
        if (messageBLM.getContentType() != "OUTGOING") {
            return;
        }
        List<ConnectionSchemeBLM> connectionSchemeBLMs = getBufferSchemes(messageBLM.getBufferUid());
        Map<UUID, List<UUID>> bufferTranstions = new HashMap<>();
        for (ConnectionSchemeBLM cs : connectionSchemeBLMs) {
            cs.getBufferTransitions().forEach((key, value) -> bufferTranstions.merge(key, value, (oldList, newList) -> {
                List<UUID> merged = new ArrayList<>(oldList);
                merged.addAll(newList);
                return merged;
            }));
        }

        for (UUID b : bufferTranstions.get(messageBLM.getBufferUid())) {
            MessageDALM messageDALM = MessageDALM.builder().bufferUid(b)
                    .content(messageBLM.getContent())
                    .contentType("INCOMMING")
                    .createdAt(new Date())
                    .uid(UUID.randomUUID())
                    .build();
            messageValidator.validate(messageDALM);
            messageRepository.add(messageDALM);
        }
    }

    private void deleteMessage(UUID messageUuid) {
        messageRepository.deleteByUid(messageUuid);
    }

    private void deleteMessage(MessageBLM messageBLM) {
        deleteMessage(messageBLM.getUid());
    }

    private List<ConnectionSchemeBLM> getBufferSchemes(UUID bufferUuid) {
        try {
            GetConnectionSchemesByBufferResponse response = connectionSchemeKafkaClient
                    .getConnectionSchemesByBufferUid(bufferUuid, "message-service")
                    .get(5, java.util.concurrent.TimeUnit.SECONDS);

            if (!response.isSuccess() || response.getConnectionSchemeDTOs() == null) {
                log.warn("Failed to get connection schemes for buffer: {}", bufferUuid);
                return List.of();
            }

            List<ConnectionSchemeDTO> connectionSchemeDTOs = response.getConnectionSchemeDTOs();
            List<ConnectionSchemeBLM> connectionSchemeBLMs = connectionSchemeDTOs.stream()
                    .map(connectionSchemeConverter::toBLM)
                    .collect(Collectors.toList());

            return connectionSchemeBLMs;

        } catch (java.util.concurrent.TimeoutException e) {
            log.error("Timeout getting connection schemes for bufferUuid: {}", bufferUuid, e);
            throw new RuntimeException("Device service timeout", e);
        } catch (java.util.concurrent.ExecutionException e) {
            log.error("Error getting devices for bufferUuid: {}", bufferUuid, e);
            throw new RuntimeException("Device service error", e);
        } catch (Exception e) {
            log.error("Unexpected error getting buffers for bufferUuid: {}", bufferUuid, e);
            throw new RuntimeException("Unexpected error", e);
        }
    }

    private List<BufferBLM> getSchemeBuffers(UUID connectionSchemeUuid) {
        try {
            GetBuffersByConnectionSchemeResponse response = bufferKafkaClient
                    .getBuffersByConnectionSchemeUid(connectionSchemeUuid, "message-service")
                    .get(5, java.util.concurrent.TimeUnit.SECONDS);

            if (!response.isSuccess() || response.getBufferDTOs() == null) {
                log.warn("Failed to get buffers for connection schemes: {}", connectionSchemeUuid);
                return List.of();
            }

            List<BufferDTO> bufferDTOs = response.getBufferDTOs();
            List<BufferBLM> bufferBLMs = bufferDTOs.stream()
                    .map(bufferConverter::toBLM)
                    .collect(Collectors.toList());

            return bufferBLMs;

        } catch (java.util.concurrent.TimeoutException e) {
            log.error("Timeout getting connection schemes for connectionSchemeUuid: {}", connectionSchemeUuid, e);
            throw new RuntimeException("Device service timeout", e);
        } catch (java.util.concurrent.ExecutionException e) {
            log.error("Error getting devices for connectionSchemeUuid: {}", connectionSchemeUuid, e);
            throw new RuntimeException("Device service error", e);
        } catch (Exception e) {
            log.error("Unexpected error getting buffers for connectionSchemeUuid: {}", connectionSchemeUuid, e);
            throw new RuntimeException("Unexpected error", e);
        }
    }

    private List<BufferBLM> getDeviceBuffers(UUID deviceUuid) {
        try {

            GetBuffersByDeviceResponse response = bufferKafkaClient
                    .getBuffersByDeviceUid(deviceUuid, "message-service")
                    .get(5, java.util.concurrent.TimeUnit.SECONDS);

            if (!response.isSuccess() || response.getBufferDTOs() == null) {
                log.warn("Failed to get buffers for device: {}", deviceUuid);
                return List.of();
            }

            List<BufferDTO> bufferDTOs = response.getBufferDTOs();
            List<BufferBLM> bufferBLMs = bufferDTOs.stream()
                    .map(bufferConverter::toBLM)
                    .collect(Collectors.toList());

            return bufferBLMs;

        } catch (java.util.concurrent.TimeoutException e) {
            log.error("Timeout getting connection schemes for bufferUuid: {}", deviceUuid, e);
            throw new RuntimeException("Device service timeout", e);
        } catch (java.util.concurrent.ExecutionException e) {
            log.error("Error getting devices for bufferUuid: {}", deviceUuid, e);
            throw new RuntimeException("Device service error", e);
        } catch (Exception e) {
            log.error("Unexpected error getting buffers for bufferUuid: {}", deviceUuid, e);
            throw new RuntimeException("Unexpected error", e);
        }
    }
}package com.connection.message;

import java.util.List;
import java.util.Map;
import java.util.UUID;

import com.connection.message.model.MessageBLM;

public interface MessageService {
    void addMessage(MessageBLM messageBLM);
    List<MessageBLM> getMessagesByBuffer(UUID bufferUuid, boolean deleteOnGet, int offset, int limit);
    List<MessageBLM> getMessagesByScheme(UUID schemeUuid, boolean deleteOnGet, int offset, int limit);
    List<MessageBLM> getMessagesByDevice(UUID devicUuid, boolean deleteOnGet, int offset, int limit);
    Map<String, String> health();
}// MessageServiceApplication.java
package com.connection.message;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MessageServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(MessageServiceApplication.class, args);
    }
}