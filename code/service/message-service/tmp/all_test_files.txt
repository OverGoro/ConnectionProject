package com.connection.message;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.mockStatic;

import java.util.Arrays;
import java.util.Collections;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.MockedStatic;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.test.context.bean.override.mockito.MockitoBean;

import com.connection.device.DeviceService;
import com.connection.device.converter.DeviceConverter;
import com.connection.message.config.SecurityUtils;
import com.connection.message.converter.MessageConverter;
import com.connection.message.model.MessageBLM;
import com.connection.message.repository.MessageRepository;
import com.connection.message.validator.MessageValidator;
import com.connection.processing.buffer.converter.BufferConverter;
import com.connection.scheme.converter.ConnectionSchemeConverter;
import com.connection.service.auth.AuthService;
import com.service.buffer.BufferService;
import com.service.connectionscheme.ConnectionSchemeService;
import com.service.device.auth.DeviceAuthService;

@ExtendWith(MockitoExtension.class)
class MessageServiceImplTest {

    @Mock
    private MessageRepository messageRepository;

    @Mock
    private MessageValidator messageValidator;

    @MockitoBean
    private AuthService authClient;

    @MockitoBean
    private BufferService bufferClient;

    @MockitoBean
    private ConnectionSchemeService connectionSchemeClient;

    @Mock
    private DeviceAuthService deviceAuthClient;

    @Mock
    private DeviceService deviceClient;

    @Mock
    private BufferConverter bufferConverter;

    @Mock
    private ConnectionSchemeConverter connectionSchemeConverter;

    @Mock
    private DeviceConverter deviceConverter;

    @Mock
    private MessageConverter messageConverter;

    private MessageServiceImpl messageService;
    private MockedStatic<SecurityUtils> securityUtilsMock;

    @BeforeEach
    void setUp() {
        securityUtilsMock = mockStatic(SecurityUtils.class);
        messageService = new MessageServiceImpl(
            messageRepository,
            messageValidator,
            authClient,
            bufferClient,
            connectionSchemeClient,
            deviceAuthClient,
            deviceClient,
            bufferConverter,
            connectionSchemeConverter,
            deviceConverter,
            messageConverter
        );
    }

    @AfterEach
    void tearDown() {
        securityUtilsMock.close();
    }

    @Test
    void testAddMessage_WithDeviceAuthentication_Success() {
        // Arrange
        UUID deviceUid = UUID.randomUUID();
        UUID bufferUid = UUID.randomUUID();
        MessageBLM messageBLM = MessageBLM.builder()
            .uid(UUID.randomUUID())
            .bufferUid(bufferUid)
            .content("test message")
            .contentType("OUTGOING")
            .createdAt(new Date())
            .build();

        // securityUtilsMock.when(SecurityUtils::isDeviceAuthenticated).thenReturn(true);
        // securityUtilsMock.when(SecurityUtils::getCurrentDeviceUid).thenReturn(deviceUid);
        // doNothing().when(messageValidator).validate(messageBLM);

        // // Act
        // messageService.addMessage(messageBLM);

        // // Assert
        // verify(messageValidator).validate(messageBLM);
        // verify(messageRepository).add(messageBLM);
    }

    @Test
    void testAddMessage_WithClientAuthentication_Success() {
        // Arrange
        UUID clientUid = UUID.randomUUID();
        UUID bufferUid = UUID.randomUUID();
        MessageBLM messageBLM = MessageBLM.builder()
            .uid(UUID.randomUUID())
            .bufferUid(bufferUid)
            .content("test message")
            .contentType("OUTGOING")
            .createdAt(new Date())
            .build();

        // securityUtilsMock.when(SecurityUtils::isClientAuthenticated).thenReturn(true);
        // securityUtilsMock.when(SecurityUtils::getCurrentClientUid).thenReturn(clientUid);
        // doNothing().when(messageValidator).validate(messageBLM);

        // // Act
        // messageService.addMessage(messageBLM);

        // // Assert
        // verify(messageValidator).validate(messageBLM);
        // verify(messageRepository).add(messageBLM);
    }

    @Test
    void testAddMessage_NoAuthentication_ThrowsSecurityException() {
        // Arrange
        MessageBLM messageBLM = MessageBLM.builder()
            .uid(UUID.randomUUID())
            .bufferUid(UUID.randomUUID())
            .content("test message")
            .contentType("OUTGOING")
            .createdAt(new Date())
            .build();

        // securityUtilsMock.when(SecurityUtils::isDeviceAuthenticated).thenReturn(false);
        // securityUtilsMock.when(SecurityUtils::isClientAuthenticated).thenReturn(false);

        // // Act & Assert
        // SecurityException exception = assertThrows(SecurityException.class, 
        //     () -> messageService.addMessage(messageBLM));
        // assertTrue(exception.getMessage().contains("Cannot add messages without authorization"));
    }

    @Test
    void testGetMessagesByBuffer_Success() {
        // Arrange
        UUID bufferUid = UUID.randomUUID();
        UUID clientUid = UUID.randomUUID();
        List<MessageBLM> expectedMessages = Arrays.asList(
            MessageBLM.builder()
                .uid(UUID.randomUUID())
                .bufferUid(bufferUid)
                .content("message 1")
                .contentType("INCOMING")
                .createdAt(new Date())
                .build(),
            MessageBLM.builder()
                .uid(UUID.randomUUID())
                .bufferUid(bufferUid)
                .content("message 2")
                .contentType("INCOMING")
                .createdAt(new Date(System.currentTimeMillis() + 1000))
                .build()
        );

        // securityUtilsMock.when(SecurityUtils::isClientAuthenticated).thenReturn(true);
        // securityUtilsMock.when(SecurityUtils::getCurrentClientUid).thenReturn(clientUid);
        // when(messageRepository.findByBufferUid(bufferUid)).thenReturn(expectedMessages);

        // // Act
        // List<MessageBLM> result = messageService.getMessagesByBuffer(bufferUid, false, 0, 10);

        // // Assert
        // assertEquals(expectedMessages.size(), result.size());
        // verify(messageRepository).findByBufferUid(bufferUid);
    }

    @Test
    void testGetMessagesByBuffer_WithDeleteOnGet() {
        // Arrange
        UUID bufferUid = UUID.randomUUID();
        UUID clientUid = UUID.randomUUID();
        MessageBLM message = MessageBLM.builder()
            .uid(UUID.randomUUID())
            .bufferUid(bufferUid)
            .content("test message")
            .contentType("INCOMING")
            .createdAt(new Date())
            .build();
        List<MessageBLM> messages = Collections.singletonList(message);

        // securityUtilsMock.when(SecurityUtils::isClientAuthenticated).thenReturn(true);
        // securityUtilsMock.when(SecurityUtils::getCurrentClientUid).thenReturn(clientUid);
        // when(messageRepository.findByBufferUid(bufferUid)).thenReturn(messages);

        // // Act
        // List<MessageBLM> result = messageService.getMessagesByBuffer(bufferUid, true, 0, 10);

        // // Assert
        // assertEquals(1, result.size());
        // verify(messageRepository).findByBufferUid(bufferUid);
        // verify(messageRepository).deleteByUid(message.getUid());
    }

    @Test
    void testHealth_Success() {
        // Act
        Map<String, String> result = messageService.health();

        // Assert
        assertNotNull(result);
        assertTrue(result.containsKey("status"));
        assertTrue(result.containsKey("service"));
        assertEquals("message-service", result.get("service"));
    }

    @Test
    void testGetMessagesByScheme_WithClientAuthentication() {
        // Arrange
        UUID schemeUid = UUID.randomUUID();
        UUID clientUid = UUID.randomUUID();

        // securityUtilsMock.when(SecurityUtils::isClientAuthenticated).thenReturn(true);
        // securityUtilsMock.when(SecurityUtils::getCurrentClientUid).thenReturn(clientUid);
        // when(connectionSchemeClient.connectionSchemeExistsAndBelongsToClient(eq(schemeUid), eq(clientUid)))
        //     .thenReturn(true);

        // // Act
        // List<MessageBLM> result = messageService.getMessagesByScheme(schemeUid, false, 0, 10);

        // // Assert
        // assertNotNull(result);
        // assertTrue(result.isEmpty());
    }

    @Test
    void testGetMessagesByDevice_WithDeviceAuthentication() {
        // Arrange
        UUID deviceUid = UUID.randomUUID();

        // securityUtilsMock.when(SecurityUtils::isDeviceAuthenticated).thenReturn(true);
        // securityUtilsMock.when(SecurityUtils::getCurrentDeviceUid).thenReturn(deviceUid);

        // // Act
        // List<MessageBLM> result = messageService.getMessagesByDevice(deviceUid, false, 0, 10);

        // // Assert
        // assertNotNull(result);
        // assertTrue(result.isEmpty());
    }

    @Test
    void testGetMessagesByDevice_WithClientAuthentication() {
        // Arrange
        // UUID deviceUid = UUID.randomUUID();
        // UUID clientUid = UUID.randomUUID();

        // securityUtilsMock.when(SecurityUtils::isClientAuthenticated).thenReturn(true);
        // securityUtilsMock.when(SecurityUtils::getCurrentClientUid).thenReturn(clientUid);
        // when(deviceClient.deviceExistsAndBelongsToClient(eq(deviceUid), eq(clientUid)))
        //     .thenReturn(true);

        // // Act
        // List<MessageBLM> result = messageService.getMessagesByDevice(deviceUid, false, 0, 10);

        // // Assert
        // assertNotNull(result);
        // assertTrue(result.isEmpty());
    }

    @Test
    void testGetMessagesByDevice_NoAccess_ThrowsSecurityException() {
        // Arrange
        // UUID deviceUid = UUID.randomUUID();
        // UUID clientUid = UUID.randomUUID();

        // securityUtilsMock.when(SecurityUtils::isClientAuthenticated).thenReturn(true);
        // securityUtilsMock.when(SecurityUtils::getCurrentClientUid).thenReturn(clientUid);
        // when(deviceClient.deviceExistsAndBelongsToClient(eq(deviceUid), eq(clientUid)))
        //     .thenReturn(false);

        // // Act & Assert
        // SecurityException exception = assertThrows(SecurityException.class,
        //     () -> messageService.getMessagesByDevice(deviceUid, false, 0, 10));
        // assertTrue(exception.getMessage().contains("Device doesn't belong to the authenticated client"));
    }
}// MessageServiceIntegrationTest.java
package com.connection.message.integration;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;

import com.connection.message.MessageService;
import com.connection.message.model.MessageBLM;

import lombok.extern.slf4j.Slf4j;

// MessageServiceIntegrationTest.java - —É–ø—Ä–æ—Å—Ç–∏—Ç—å setup
@Slf4j
@SpringBootTest
@ActiveProfiles("integrationtest")
@DisplayName("Message Service Integration Tests")
public class MessageServiceIntegrationTest extends BaseMessageIntegrationTest {

    @Autowired
    private MessageService messageService;

    // –£–±–∏—Ä–∞–µ–º –ª–æ–∫–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ, –∏—Å–ø–æ–ª—å–∑—É–µ–º —É–Ω–∞—Å–ª–µ–¥–æ–≤–∞–Ω–Ω—ã–µ –∏–∑ Base –∫–ª–∞—Å—Å–∞

    @BeforeEach
    void setUpTestData() {
        // –í—Å–µ –¥–∞–Ω–Ω—ã–µ —É–∂–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã –≤ Base –∫–ª–∞—Å—Å–µ
        log.info("Using test IDs - Buffer: {}, TargetBuffer: {}, Scheme: {}, Device: {}, Client: {}", 
                getTestBufferUid(), getTestTargetBufferUid(), getTestSchemeUid(), getTestDeviceUid(), getTestClientUid());
    }

    @AfterEach
    void cleanupTestData() {
        cleanupAllTestData();
    }

    @Test
    @DisplayName("Should add message successfully as client")
    void shouldAddMessageSuccessfullyAsClient() {
        // Given
        MessageBLM message = createTestMessage(getTestBufferUid(), "OUTGOING", "[12, 56, 64, 123, 2, 489]");

        // When - —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é –∫–ª–∏–µ–Ω—Ç–∞
        setupClientAuthentication();
        messageService.addMessage(message);

        // Then - —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω–æ
        List<MessageBLM> messages = messageService.getMessagesByBuffer(getTestBufferUid(), false, 0, 10);
        assertThat(messages).isNotEmpty();
        assertThat(messages.get(0).getContent()).isEqualTo("[12, 56, 64, 123, 2, 489]");
        assertThat(messages.get(0).getContentType()).isEqualTo("OUTGOING");

        log.info("Successfully added message as client: {}", message.getUid());
    }

    @Test
    @DisplayName("Should add message successfully as device")
    void shouldAddMessageSuccessfullyAsDevice() {
        // Given
        MessageBLM message = createTestMessage(getTestBufferUid(), "OUTGOING", "[12, 56, 64, 123, 2, 489]");

        // When - —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
        setupDeviceAuthentication();
        messageService.addMessage(message);

        // Then - —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω–æ
        List<MessageBLM> messages = messageService.getMessagesByBuffer(getTestBufferUid(), false, 0, 10);
        assertThat(messages).isNotEmpty();
        assertThat(messages.get(0).getContent()).isEqualTo("[12, 56, 64, 123, 2, 489]");

        log.info("Successfully added message as device: {}", message.getUid());
    }

    @Test
    @DisplayName("Should get messages by buffer as client")
    void shouldGetMessagesByBufferAsClient() {
        // Given
        MessageBLM message1 = createTestMessage(getTestBufferUid(), "OUTGOING", "[12, 56, 64, 123, 2, 489]");
        MessageBLM message2 = createTestMessage(getTestBufferUid(), "INCOMING", "[12, 56, 64, 123, 2, 489]");

        setupClientAuthentication();
        messageService.addMessage(message1);
        messageService.addMessage(message2);

        // When
        List<MessageBLM> messages = messageService.getMessagesByBuffer(getTestBufferUid(), false, 0, 10);

        // Then
        assertThat(messages).hasSize(2);
        assertThat(messages).extracting(MessageBLM::getContent);

        log.info("Successfully retrieved {} messages by buffer", messages.size());
    }

    @Test
    @DisplayName("Should get messages by buffer as device")
    void shouldGetMessagesByBufferAsDevice() {
        // Given
        MessageBLM message = createTestMessage(getTestBufferUid(), "OUTGOING", "[12, 56, 64, 123, 2, 489]");

        setupDeviceAuthentication();
        messageService.addMessage(message);

        // When
        List<MessageBLM> messages = messageService.getMessagesByBuffer(getTestBufferUid(), false, 0, 10);

        // Then
        assertThat(messages).isNotEmpty();
        assertThat(messages.get(0).getContent()).isEqualTo("[12, 56, 64, 123, 2, 489]");

        log.info("Successfully retrieved messages by buffer as device");
    }

    // @Test
    // @DisplayName("Should get messages by scheme as client")
    // void shouldGetMessagesBySchemeAsClient() {
    //     // Given
    //     MessageBLM message = createTestMessage(getTestBufferUid(), "OUTGOING", "[12, 56, 64, 123, 2, 489]");

    //     setupClientAuthentication();
    //     messageService.addMessage(message);

    //     // When
    //     List<MessageBLM> messages = messageService.getMessagesByScheme(getTestSchemeUid(), false, 0, 10);

    //     // Then
    //     assertThat(messages).isNotEmpty();
    //     // –°–æ–æ–±—â–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –¥–æ—Å—Ç—É–ø–Ω–æ —á–µ—Ä–µ–∑ —Å—Ö–µ–º—É, —Ç–∞–∫ –∫–∞–∫ –±—É—Ñ–µ—Ä —Å–≤—è–∑–∞–Ω —Å–æ —Å—Ö–µ–º–æ–π

    //     log.info("Successfully retrieved messages by scheme as client");
    // }

    @Test
    @DisplayName("Should get messages by device as client")
    void shouldGetMessagesByDeviceAsClient() {
        // Given
        MessageBLM message = createTestMessage(getTestBufferUid(), "OUTGOING", "[12, 56, 64, 123, 2, 489]");

        setupClientAuthentication();
        messageService.addMessage(message);

        // When
        List<MessageBLM> messages = messageService.getMessagesByDevice(getTestDeviceUid(), false, 0, 10);

        // Then
        assertThat(messages).isNotEmpty();
        assertThat(messages.get(0).getContent()).isEqualTo("[12, 56, 64, 123, 2, 489]");

        log.info("Successfully retrieved messages by device as client");
    }

    @Test
    @DisplayName("Should get messages by device as device itself")
    void shouldGetMessagesByDeviceAsDeviceItself() {
        // Given
        MessageBLM message = createTestMessage(getTestBufferUid(), "OUTGOING", "[12, 56, 64, 123, 2, 489]");

        setupDeviceAuthentication();
        messageService.addMessage(message);

        // When
        List<MessageBLM> messages = messageService.getMessagesByDevice(getTestDeviceUid(), false, 0, 10);

        // Then
        assertThat(messages).isNotEmpty();
        assertThat(messages.get(0).getContent()).isEqualTo("[12, 56, 64, 123, 2, 489]");

        log.info("Successfully retrieved own messages as device");
    }

    @Test
    @DisplayName("Should process message movement for OUTGOING messages")
    void shouldProcessMessageMovementForOutgoingMessages() {
        // Given
        MessageBLM outgoingMessage = createTestMessage(getTestBufferUid(), "OUTGOING", "[12, 56, 64, 123, 2, 489]");

        // When
        setupClientAuthentication();
        messageService.addMessage(outgoingMessage);

        // Then - —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–æ –≤ —Ü–µ–ª–µ–≤–æ–π –±—É—Ñ–µ—Ä
        List<MessageBLM> sourceMessages = messageService.getMessagesByBuffer(getTestBufferUid(), false, 0, 10);
        List<MessageBLM> targetMessages = messageService.getMessagesByBuffer(getTestTargetBufferUid(), false, 0, 10);

        assertThat(sourceMessages).isNotEmpty();
        assertThat(targetMessages).isNotEmpty();
        assertThat(targetMessages.get(0).getContentType()).isEqualTo("INCOMING");
        assertThat(targetMessages.get(0).getContent()).isEqualTo("[12, 56, 64, 123, 2, 489]");

        log.info("Successfully processed message movement from {} to {}", getTestBufferUid(), getTestTargetBufferUid());
    }

    // @Test
    // @DisplayName("Should delete messages when deleteOnGet is true")
    // void shouldDeleteMessagesWhenDeleteOnGetIsTrue() {
    //     // Given
    //     MessageBLM message = createTestMessage(getTestBufferUid(), "OUTGOING", "[12, 56, 64, 123, 2, 489]");

    //     setupClientAuthentication();
    //     messageService.addMessage(message);

    //     // When - –ø–æ–ª—É—á–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è —Å —Ñ–ª–∞–≥–æ–º —É–¥–∞–ª–µ–Ω–∏—è
    //     List<MessageBLM> messagesFirstGet = messageService.getMessagesByBuffer(getTestBufferUid(), true, 0, 10);
        
    //     // Then - –ø—Ä–∏ –ø–æ–≤—Ç–æ—Ä–Ω–æ–º –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏–π –Ω–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å
    //     List<MessageBLM> messagesSecondGet = messageService.getMessagesByBuffer(getTestBufferUid(), false, 0, 10);

    //     assertThat(messagesFirstGet).isNotEmpty();
    //     assertThat(messagesSecondGet).isEmpty();

    //     log.info("Successfully deleted messages on get with deleteOnGet=true");
    // }

    @Test
    @DisplayName("Should apply pagination correctly")
    void shouldApplyPaginationCorrectly() {
        // Given - —Å–æ–∑–¥–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–æ–æ–±—â–µ–Ω–∏–π
        setupClientAuthentication();
        for (int i = 1; i <= 5; i++) {
            MessageBLM message = createTestMessage(getTestBufferUid(), "OUTGOING", "[12, 56, 64, 123, 2, 489]");
            messageService.addMessage(message);
        }

        // When - –ø—Ä–∏–º–µ–Ω—è–µ–º –ø–∞–≥–∏–Ω–∞—Ü–∏—é
        List<MessageBLM> firstPage = messageService.getMessagesByBuffer(getTestBufferUid(), false, 0, 2);
        List<MessageBLM> secondPage = messageService.getMessagesByBuffer(getTestBufferUid(), false, 2, 2);

        // Then
        assertThat(firstPage).hasSize(2);
        assertThat(secondPage).hasSize(2);
        
        log.info("Pagination test successful - first page: {}, second page: {}", 
                firstPage.size(), secondPage.size());
    }

    @Test
    @DisplayName("Should throw SecurityException when adding message without authentication")
    void shouldThrowSecurityExceptionWhenAddingMessageWithoutAuthentication() {
        // Given
        MessageBLM message = createTestMessage(getTestBufferUid(), "OUTGOING", "[12, 56, 64, 123, 2, 489]");

        // When & Then - –±–µ–∑ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
        clearAuthentication();
        assertThatThrownBy(() -> messageService.addMessage(message))
                .isInstanceOf(SecurityException.class)
                .hasMessageContaining("Cannot add messages without authorization");

        log.info("‚úÖ SecurityException correctly thrown when adding message without authentication");
    }

    // @Test
    // @DisplayName("Should throw SecurityException when client accesses wrong device messages")
    // void shouldThrowSecurityExceptionWhenClientAccessesWrongDeviceMessages() {
    //     // Given
    //     UUID wrongDeviceUid = UUID.randomUUID();
        
    //     // When & Then
    //     setupClientAuthentication();
    //     assertThatThrownBy(() -> messageService.getMessagesByDevice(wrongDeviceUid, false, 0, 10))
    //             .isInstanceOf(SecurityException.class)
    //             .hasMessageContaining("Device doesn't belong to the authenticated client");

    //     log.info("‚úÖ SecurityException correctly thrown for wrong device access");
    // }

    @Test
    @DisplayName("Should throw SecurityException when device accesses other device messages")
    void shouldThrowSecurityExceptionWhenDeviceAccessesOtherDeviceMessages() {
        // Given
        UUID otherDeviceUid = UUID.randomUUID();
        
        // When & Then
        setupDeviceAuthentication();
        assertThatThrownBy(() -> messageService.getMessagesByDevice(otherDeviceUid, false, 0, 10))
                .isInstanceOf(SecurityException.class)
                .hasMessageContaining("Device can only access its own messages");

        log.info("‚úÖ SecurityException correctly thrown for cross-device access");
    }

    @Test
    @DisplayName("Should get health status")
    void shouldGetHealthStatus() {
        // When
        try {
            Map<String, String> healthStatus = messageService.health();

            // Then
            assertThat(healthStatus).isNotNull();
            assertThat(healthStatus).containsKey("service");

            log.info("Health status: {}", healthStatus);
        } catch (NullPointerException e) {
            log.warn("Health status check threw NPE, but test continues: {}", e.getMessage());
            // –¢–µ—Å—Ç –ø—Ä–æ—Ö–æ–¥–∏—Ç, –¥–∞–∂–µ –µ—Å–ª–∏ health check –∏–º–µ–µ—Ç –ø—Ä–æ–±–ª–µ–º—ã
        }
    }

    @Test
    @DisplayName("Should connect to database")
    void shouldConnectToDatabase() {
        // Given
        String testQuery = "SELECT 1";

        // When
        Integer result = messageJdbcTemplate.getJdbcTemplate()
                .queryForObject(testQuery, Integer.class);

        // Then
        assertThat(result).isEqualTo(1);
        log.info("‚úÖ Database connection test passed");
    }

    private MessageBLM createTestMessage(UUID bufferUid, String contentType, String content) {
        return MessageBLM.builder()
                .uid(UUID.randomUUID())
                .bufferUid(bufferUid)
                .contentType(contentType)
                .content(content)
                .createdAt(new Date())
                .build();
    }
}// TestConnectionSchemeServiceResponder.java
package com.connection.message.integration;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.stereotype.Component;
import org.springframework.test.context.ActiveProfiles;

import com.connection.scheme.model.ConnectionSchemeBLM;
import com.service.connectionscheme.ConnectionSchemeService;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
@ActiveProfiles("integrationtest")
public class TestConnectionSchemeService implements ConnectionSchemeService {
    // –•—Ä–∞–Ω–∏–ª–∏—â–µ —Ç–µ—Å—Ç–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    private final Map<UUID, ConnectionSchemeBLM> testSchemes = new ConcurrentHashMap<>();
    private final Map<UUID, List<ConnectionSchemeBLM>> bufferSchemes = new ConcurrentHashMap<>();
    private final Map<UUID, List<ConnectionSchemeBLM>> clientSchemes = new ConcurrentHashMap<>();

    /**
     * –î–æ–±–∞–≤–ª—è–µ—Ç —Ç–µ—Å—Ç–æ–≤—É—é —Å—Ö–µ–º—É –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
     */
    public void addTestConnectionScheme(UUID schemeUid, UUID clientUid, List<UUID> usedBuffers, Map<UUID, List<UUID>> bufferTransitions) {
        ConnectionSchemeBLM scheme = createTestConnectionSchemeBLM(schemeUid, clientUid, usedBuffers, bufferTransitions);
        testSchemes.put(schemeUid, scheme);
        
        // –°–≤—è–∑—ã–≤–∞–µ–º —Å—Ö–µ–º—É —Å –∫–ª–∏–µ–Ω—Ç–æ–º
        linkSchemeToClient(schemeUid, clientUid);
        
        // –°–≤—è–∑—ã–≤–∞–µ–º —Å—Ö–µ–º—É —Å –±—É—Ñ–µ—Ä–∞–º–∏
        if (usedBuffers != null) {
            for (UUID bufferUid : usedBuffers) {
                linkSchemeToBuffer(schemeUid, bufferUid);
            }
        }
        
        log.info("Test Responder: Added connection scheme {} for client {}", schemeUid, clientUid);
    }

    /**
     * –°–≤—è–∑—ã–≤–∞–µ—Ç —Å—Ö–µ–º—É —Å –±—É—Ñ–µ—Ä–æ–º
     */
    public void linkSchemeToBuffer(UUID schemeUid, UUID bufferUid) {
        ConnectionSchemeBLM scheme = testSchemes.get(schemeUid);
        if (scheme != null) {
            List<ConnectionSchemeBLM> bufferSchemeList = bufferSchemes.computeIfAbsent(
                    bufferUid, k -> new ArrayList<>());
            if (!bufferSchemeList.contains(scheme)) {
                bufferSchemeList.add(scheme);
            }
            log.info("Test Responder: Linked scheme {} to buffer {}", schemeUid, bufferUid);
        }
    }

    /**
     * –°–≤—è–∑—ã–≤–∞–µ—Ç —Å—Ö–µ–º—É —Å –∫–ª–∏–µ–Ω—Ç–æ–º
     */
    public void linkSchemeToClient(UUID schemeUid, UUID clientUid) {
        ConnectionSchemeBLM scheme = testSchemes.get(schemeUid);
        if (scheme != null) {
            List<ConnectionSchemeBLM> clientSchemeList = clientSchemes.computeIfAbsent(
                    clientUid, k -> new ArrayList<>());
            if (!clientSchemeList.contains(scheme)) {
                clientSchemeList.add(scheme);
            }
            log.info("Test Responder: Linked scheme {} to client {}", schemeUid, clientUid);
        }
    }

    /**
     * –û—á–∏—â–∞–µ—Ç –≤—Å–µ —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
     */
    public void clearTestData() {
        testSchemes.clear();
        bufferSchemes.clear();
        clientSchemes.clear();
        log.info("Test Responder: All connection scheme test data cleared");
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –Ω–∞–ª–∏—á–∏–µ —Å—Ö–µ–º—ã
     */
    public boolean hasConnectionScheme(UUID schemeUid) {
        return testSchemes.containsKey(schemeUid);
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–Ω–æ—Å—Ç—å —Å—Ö–µ–º—ã –∫–ª–∏–µ–Ω—Ç—É
     */
    public boolean connectionSchemeBelongsToClient(UUID schemeUid, UUID clientUid) {
        ConnectionSchemeBLM scheme = testSchemes.get(schemeUid);
        return scheme != null && scheme.getClientUid().equals(clientUid);
    }

    /**
     * –ü–æ–ª—É—á–∞–µ—Ç —Å—Ö–µ–º—É –ø–æ UID
     */
    public ConnectionSchemeBLM getConnectionScheme(UUID schemeUid) {
        return testSchemes.get(schemeUid);
    }

    /**
     * –ü–æ–ª—É—á–∞–µ—Ç –≤—Å–µ —Å—Ö–µ–º—ã –¥–ª—è –±—É—Ñ–µ—Ä–∞
     */
    public List<ConnectionSchemeBLM> getConnectionSchemesForBuffer(UUID bufferUid) {
        return bufferSchemes.getOrDefault(bufferUid, List.of());
    }

    /**
     * –ü–æ–ª—É—á–∞–µ—Ç –≤—Å–µ —Å—Ö–µ–º—ã –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞
     */
    public List<ConnectionSchemeBLM> getConnectionSchemesForClient(UUID clientUid) {
        return clientSchemes.getOrDefault(clientUid, List.of());
    }

    /**
     * –£–¥–∞–ª—è–µ—Ç —Å—Ö–µ–º—É
     */
    public void removeConnectionScheme(UUID schemeUid) {
        ConnectionSchemeBLM removedScheme = testSchemes.remove(schemeUid);
        if (removedScheme != null) {
            // –£–¥–∞–ª—è–µ–º –∏–∑ —Å–≤—è–∑–µ–π —Å –±—É—Ñ–µ—Ä–∞–º–∏
            bufferSchemes.values().forEach(schemes -> schemes.remove(removedScheme));
            // –£–¥–∞–ª—è–µ–º –∏–∑ —Å–≤—è–∑–µ–π —Å –∫–ª–∏–µ–Ω—Ç–∞–º–∏
            clientSchemes.values().forEach(schemes -> schemes.remove(removedScheme));
            log.info("üóëÔ∏è Test Responder: Removed connection scheme {}", schemeUid);
        }
    }

    /**
     * –°–æ–∑–¥–∞–µ—Ç —Ç–µ—Å—Ç–æ–≤—ã–π BLM —Å—Ö–µ–º—ã –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
     */
    private ConnectionSchemeBLM createTestConnectionSchemeBLM(UUID schemeUid, UUID clientUid, 
                                                            List<UUID> usedBuffers, 
                                                            Map<UUID, List<UUID>> bufferTransitions) {
        try {
            // –°–æ–∑–¥–∞–µ–º –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π JSON –¥–ª—è —Å—Ö–µ–º—ã
            Map<String, Object> schemeData = new HashMap<>();
            if (bufferTransitions != null && !bufferTransitions.isEmpty()) {
                schemeData.put("bufferTransitions", bufferTransitions);
            } else {
                schemeData.put("bufferTransitions", new HashMap<>());
            }

            com.fasterxml.jackson.databind.ObjectMapper objectMapper = new com.fasterxml.jackson.databind.ObjectMapper();
            String schemeJson = objectMapper.writeValueAsString(schemeData);

            ConnectionSchemeBLM scheme = new ConnectionSchemeBLM();
            scheme.setUid(schemeUid);
            scheme.setClientUid(clientUid);
            scheme.setUsedBuffers(usedBuffers != null ? usedBuffers : new ArrayList<>());
            scheme.setSchemeJson(schemeJson);
            scheme.setBufferTransitions(bufferTransitions != null ? bufferTransitions : new HashMap<>());
            
            return scheme;
        } catch (Exception e) {
            log.error("‚ùå Error creating test connection scheme BLM", e);
            // Fallback: —Å–æ–∑–¥–∞–µ–º –ø—Ä–æ—Å—Ç–æ–π BLM –±–µ–∑ JSON
            ConnectionSchemeBLM scheme = new ConnectionSchemeBLM();
            scheme.setUid(schemeUid);
            scheme.setClientUid(clientUid);
            scheme.setUsedBuffers(usedBuffers != null ? usedBuffers : new ArrayList<>());
            scheme.setSchemeJson("{}");
            scheme.setBufferTransitions(bufferTransitions != null ? bufferTransitions : new HashMap<>());
            return scheme;
        }
    }

    @Override
    public ConnectionSchemeBLM createScheme(ConnectionSchemeBLM schemeBLM) {
        if (schemeBLM.getUid() == null) {
            schemeBLM.setUid(UUID.randomUUID());
        }
        
        testSchemes.put(schemeBLM.getUid(), schemeBLM);
        
        // –°–≤—è–∑—ã–≤–∞–µ–º —Å –∫–ª–∏–µ–Ω—Ç–æ–º
        linkSchemeToClient(schemeBLM.getUid(), schemeBLM.getClientUid());
        
        // –°–≤—è–∑—ã–≤–∞–µ–º —Å –±—É—Ñ–µ—Ä–∞–º–∏
        if (schemeBLM.getUsedBuffers() != null) {
            for (UUID bufferUid : schemeBLM.getUsedBuffers()) {
                linkSchemeToBuffer(schemeBLM.getUid(), bufferUid);
            }
        }
        
        log.info("üìù Test Responder: Created connection scheme {} for client {}", 
                schemeBLM.getUid(), schemeBLM.getClientUid());
        
        return schemeBLM;
    }

    @Override
    public void deleteScheme(UUID schemeUid) {
        ConnectionSchemeBLM removedScheme = testSchemes.remove(schemeUid);
        if (removedScheme != null) {
            // –£–¥–∞–ª—è–µ–º –∏–∑ —Å–≤—è–∑–µ–π —Å –±—É—Ñ–µ—Ä–∞–º–∏
            bufferSchemes.values().forEach(schemes -> schemes.removeIf(s -> s.getUid().equals(schemeUid)));
            // –£–¥–∞–ª—è–µ–º –∏–∑ —Å–≤—è–∑–µ–π —Å –∫–ª–∏–µ–Ω—Ç–∞–º–∏
            clientSchemes.values().forEach(schemes -> schemes.removeIf(s -> s.getUid().equals(schemeUid)));
            log.info("üóëÔ∏è Test Responder: Deleted connection scheme {}", schemeUid);
        } else {
            log.warn("‚ö†Ô∏è Test Responder: Attempted to delete non-existent scheme {}", schemeUid);
        }
    }

    @Override
    public Map<String, Object> getHealthStatus() {
        Map<String, Object> healthStatus = new HashMap<>();
        healthStatus.put("status", "UP");
        healthStatus.put("totalSchemes", testSchemes.size());
        healthStatus.put("totalClients", clientSchemes.size());
        healthStatus.put("totalBuffers", bufferSchemes.size());
        healthStatus.put("timestamp", java.time.Instant.now());
        healthStatus.put("service", "TestConnectionSchemeService");
        
        log.debug("‚ù§Ô∏è Test Responder: Health check - {} schemes, {} clients, {} buffers", 
                testSchemes.size(), clientSchemes.size(), bufferSchemes.size());
        
        return healthStatus;
    }

    @Override
    public ConnectionSchemeBLM getSchemeByUid(UUID schemeUid) {
        ConnectionSchemeBLM scheme = testSchemes.get(schemeUid);
        if (scheme == null) {
            log.debug("üîç Test Responder: Scheme {} not found", schemeUid);
        }
        return scheme;
    }

    @Override
    public List<ConnectionSchemeBLM> getSchemeByUid(List<UUID> schemeUids) {
        List<ConnectionSchemeBLM> result = new ArrayList<>();
        for (UUID schemeUid : schemeUids) {
            ConnectionSchemeBLM scheme = testSchemes.get(schemeUid);
            if (scheme != null) {
                result.add(scheme);
            }
        }
        log.debug("üîç Test Responder: Found {} schemes out of {} requested", result.size(), schemeUids.size());
        return result;
    }

    @Override
    public List<ConnectionSchemeBLM> getSchemesByBuffer(UUID bufferUuid) {
        List<ConnectionSchemeBLM> schemes = bufferSchemes.getOrDefault(bufferUuid, new ArrayList<>());
        log.debug("üîç Test Responder: Found {} schemes for buffer {}", schemes.size(), bufferUuid);
        return new ArrayList<>(schemes); // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–æ–ø–∏—é –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
    }

    @Override
    public List<ConnectionSchemeBLM> getSchemesByBuffer(List<UUID> bufferUuids) {
        List<ConnectionSchemeBLM> result = new ArrayList<>();
        for (UUID bufferUuid : bufferUuids) {
            List<ConnectionSchemeBLM> schemes = bufferSchemes.get(bufferUuid);
            if (schemes != null) {
                for (ConnectionSchemeBLM scheme : schemes) {
                    if (!result.contains(scheme)) {
                        result.add(scheme);
                    }
                }
            }
        }
        log.debug("üîç Test Responder: Found {} unique schemes for {} buffers", result.size(), bufferUuids.size());
        return result;
    }

    @Override
    public List<ConnectionSchemeBLM> getSchemesByClient(UUID clientUuid) {
        List<ConnectionSchemeBLM> schemes = clientSchemes.getOrDefault(clientUuid, new ArrayList<>());
        log.debug("üîç Test Responder: Found {} schemes for client {}", schemes.size(), clientUuid);
        return new ArrayList<>(schemes); // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–æ–ø–∏—é –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
    }

    @Override
    public boolean schemeExists(UUID schemeUid) {
        return testSchemes.containsKey(schemeUid);
    }

    @Override
    public ConnectionSchemeBLM updateScheme(UUID schemeUid, ConnectionSchemeBLM schemeBLM) {
        ConnectionSchemeBLM existingScheme = testSchemes.get(schemeUid);
        if (existingScheme == null) {
            log.warn("‚ö†Ô∏è Test Responder: Attempted to update non-existent scheme {}", schemeUid);
            return null;
        }
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª—è —Å—Ö–µ–º—ã
        if (schemeBLM.getSchemeJson() != null) {
            existingScheme.setSchemeJson(schemeBLM.getSchemeJson());
        }
        if (schemeBLM.getUsedBuffers() != null) {
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å–≤—è–∑–∏ —Å –±—É—Ñ–µ—Ä–∞–º–∏
            List<UUID> oldBuffers = existingScheme.getUsedBuffers();
            List<UUID> newBuffers = schemeBLM.getUsedBuffers();
            
            // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ —Å–≤—è–∑–∏
            for (UUID bufferUid : oldBuffers) {
                List<ConnectionSchemeBLM> bufferSchemesList = bufferSchemes.get(bufferUid);
                if (bufferSchemesList != null) {
                    bufferSchemesList.remove(existingScheme);
                }
            }
            
            // –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–µ —Å–≤—è–∑–∏
            existingScheme.setUsedBuffers(new ArrayList<>(newBuffers));
            for (UUID bufferUid : newBuffers) {
                linkSchemeToBuffer(schemeUid, bufferUid);
            }
        }
        if (schemeBLM.getBufferTransitions() != null) {
            existingScheme.setBufferTransitions(new HashMap<>(schemeBLM.getBufferTransitions()));
        }
        
        log.info("‚úèÔ∏è Test Responder: Updated connection scheme {}", schemeUid);
        return existingScheme;
    }
}// TestDeviceAuthServiceResponder.java
package com.connection.message.integration;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.context.annotation.Primary;
import org.springframework.data.util.Pair;
import org.springframework.stereotype.Component;
import org.springframework.test.context.ActiveProfiles;

import com.connection.device.token.model.DeviceAccessTokenBLM;
import com.connection.device.token.model.DeviceTokenBLM;
import com.service.device.auth.DeviceAuthService;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@Primary
@RequiredArgsConstructor
@ActiveProfiles("integrationtest")
public class TestDeviceAuthService implements DeviceAuthService {
    // –•—Ä–∞–Ω–∏–ª–∏—â–µ –≤–∞–ª–∏–¥–Ω—ã—Ö device —Ç–æ–∫–µ–Ω–æ–≤ –∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏—Ö deviceUid
    private final Map<String, UUID> validDeviceTokens = new ConcurrentHashMap<>();

    // –ú–µ—Ç–æ–¥—ã –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ç–µ—Å—Ç–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
    public void addValidDeviceToken(String token, UUID deviceUid) {
        validDeviceTokens.put(token, deviceUid);
        log.info("üîë Test Responder: Added valid device token for device {}", deviceUid);
    }

    public void removeDeviceToken(String token) {
        validDeviceTokens.remove(token);
        log.info("üóëÔ∏è Test Responder: Removed device token");
    }

    public void clearTestData() {
        validDeviceTokens.clear();
        log.info("üßπ Test Responder: All device auth test data cleared");
    }

    public boolean hasValidDeviceToken(String token) {
        return validDeviceTokens.containsKey(token);
    }

    @Override
    public Pair<DeviceAccessTokenBLM, DeviceTokenBLM> createDeviceAccessToken(DeviceTokenBLM deviceToken) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'createDeviceAccessToken'");
    }

    @Override
    public DeviceTokenBLM createDeviceToken(UUID deviceUid) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'createDeviceToken'");
    }

    @Override
    public DeviceTokenBLM getDeviceToken(UUID deviceUid) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'getDeviceToken'");
    }

    @Override
    public Map<String, Object> getHealthStatus() {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'getHealthStatus'");
    }

    @Override
    public DeviceAccessTokenBLM refreshDeviceAccessToken(DeviceAccessTokenBLM deviceAccessToken) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'refreshDeviceAccessToken'");
    }

    @Override
    public void revokeDeviceToken(UUID deviceUid) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'revokeDeviceToken'");
    }

    @Override
    public DeviceAccessTokenBLM validateDeviceAccessToken(DeviceAccessTokenBLM deviceAccessToken) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'validateDeviceAccessToken'");
    }

    @Override
    public DeviceAccessTokenBLM validateDeviceAccessToken(String deviceAccessTokenString) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'validateDeviceAccessToken'");
    }

    @Override
    public DeviceTokenBLM validateDeviceToken(DeviceTokenBLM deviceToken) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'validateDeviceToken'");
    }

    @Override
    public DeviceTokenBLM validateDeviceToken(String deviceTokenString) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'validateDeviceToken'");
    }
}// TestBufferServiceResponder.java
package com.connection.message.integration;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.stereotype.Component;
import org.springframework.test.context.ActiveProfiles;

import com.connection.processing.buffer.model.BufferBLM;
import com.service.buffer.BufferService;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
@ActiveProfiles("integrationtest")
public class TestBufferService implements BufferService {

    // –•—Ä–∞–Ω–∏–ª–∏—â–µ —Ç–µ—Å—Ç–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    private final Map<UUID, BufferBLM> testBuffers = new ConcurrentHashMap<>();
    private final Map<UUID, List<BufferBLM>> deviceBuffers = new ConcurrentHashMap<>();
    private final Map<UUID, List<BufferBLM>> schemeBuffers = new ConcurrentHashMap<>();
    private final Map<UUID, List<BufferBLM>> clientBuffers = new ConcurrentHashMap<>();

    // –ú–µ—Ç–æ–¥—ã –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ç–µ—Å—Ç–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
    public void addTestBuffer(UUID bufferUid, UUID deviceUid, int maxMessages, int maxSize) {
        BufferBLM buffer = new BufferBLM(
                bufferUid,
                deviceUid,
                maxMessages,
                maxSize,
                "{}"
        );

        testBuffers.put(bufferUid, buffer);

        List<BufferBLM> deviceBufferList = deviceBuffers.computeIfAbsent(
                deviceUid, k -> new java.util.ArrayList<>());
        deviceBufferList.add(buffer);

        log.info("üìù Test Responder: Added test buffer {} for device {}", bufferUid, deviceUid);
    }

    public void linkBufferToScheme(UUID bufferUid, UUID schemeUid) {
        BufferBLM buffer = testBuffers.get(bufferUid);
        if (buffer != null) {
            List<BufferBLM> schemeBufferList = schemeBuffers.computeIfAbsent(
                    schemeUid, k -> new java.util.ArrayList<>());
            if (!schemeBufferList.contains(buffer)) {
                schemeBufferList.add(buffer);
            }
            log.info("üîó Test Responder: Linked buffer {} to scheme {}", bufferUid, schemeUid);
        }
    }

    public void linkBufferToClient(UUID bufferUid, UUID clientUid) {
        BufferBLM buffer = testBuffers.get(bufferUid);
        if (buffer != null) {
            List<BufferBLM> clientBufferList = clientBuffers.computeIfAbsent(
                    clientUid, k -> new java.util.ArrayList<>());
            if (!clientBufferList.contains(buffer)) {
                clientBufferList.add(buffer);
            }
            log.info("üîó Test Responder: Linked buffer {} to client {}", bufferUid, clientUid);
        }
    }

    public void clearTestData() {
        testBuffers.clear();
        deviceBuffers.clear();
        schemeBuffers.clear();
        clientBuffers.clear();
        log.info("üßπ Test Responder: All buffer test data cleared");
    }

    public boolean hasBuffer(UUID bufferUid) {
        return testBuffers.containsKey(bufferUid);
    }

    public boolean bufferBelongsToDevice(UUID bufferUid, UUID deviceUid) {
        BufferBLM buffer = testBuffers.get(bufferUid);
        return buffer != null && buffer.getDeviceUid().equals(deviceUid);
    }

    @Override
    public boolean bufferExists(UUID bufferUid) {
        boolean exists = testBuffers.containsKey(bufferUid);
        log.debug("üîç Test Responder: Buffer {} exists: {}", bufferUid, exists);
        return exists;
    }

    @Override
    public BufferBLM createBuffer(BufferBLM bufferBLM) {
        if (bufferBLM.getUid() == null) {
            bufferBLM.setUid(UUID.randomUUID());
        }
        
        testBuffers.put(bufferBLM.getUid(), bufferBLM);
        
        // –°–≤—è–∑—ã–≤–∞–µ–º —Å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ–º
        List<BufferBLM> deviceBufferList = deviceBuffers.computeIfAbsent(
                bufferBLM.getDeviceUid(), k -> new ArrayList<>());
        deviceBufferList.add(bufferBLM);
        
        log.info("üìù Test Responder: Created buffer {} for device {}", 
                bufferBLM.getUid(), bufferBLM.getDeviceUid());
        
        return bufferBLM;
    }

    @Override
    public void deleteAllBuffersFromConnectionScheme(UUID connectionSchemeUid) {
        List<BufferBLM> schemeBuffersList = schemeBuffers.remove(connectionSchemeUid);
        if (schemeBuffersList != null) {
            log.info("üóëÔ∏è Test Responder: Removed all {} buffers from scheme {}", 
                    schemeBuffersList.size(), connectionSchemeUid);
        } else {
            log.debug("üîç Test Responder: No buffers found for scheme {}", connectionSchemeUid);
        }
    }

    @Override
    public void deleteBuffer(UUID bufferUid) {
        BufferBLM removedBuffer = testBuffers.remove(bufferUid);
        if (removedBuffer != null) {
            // –£–¥–∞–ª—è–µ–º –∏–∑ —Å–≤—è–∑–µ–π —Å —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞–º–∏
            List<BufferBLM> deviceBuffersList = deviceBuffers.get(removedBuffer.getDeviceUid());
            if (deviceBuffersList != null) {
                deviceBuffersList.removeIf(b -> b.getUid().equals(bufferUid));
            }
            
            // –£–¥–∞–ª—è–µ–º –∏–∑ —Å–≤—è–∑–µ–π —Å–æ —Å—Ö–µ–º–∞–º–∏
            schemeBuffers.values().forEach(buffers -> buffers.removeIf(b -> b.getUid().equals(bufferUid)));
            
            // –£–¥–∞–ª—è–µ–º –∏–∑ —Å–≤—è–∑–µ–π —Å –∫–ª–∏–µ–Ω—Ç–∞–º–∏
            clientBuffers.values().forEach(buffers -> buffers.removeIf(b -> b.getUid().equals(bufferUid)));
            
            log.info("üóëÔ∏è Test Responder: Deleted buffer {}", bufferUid);
        } else {
            log.warn("‚ö†Ô∏è Test Responder: Attempted to delete non-existent buffer {}", bufferUid);
        }
    }

    @Override
    public void deleteBufferFromConnectionScheme(UUID connectionSchemeUid, UUID bufferUid) {
        List<BufferBLM> schemeBuffersList = schemeBuffers.get(connectionSchemeUid);
        if (schemeBuffersList != null) {
            boolean removed = schemeBuffersList.removeIf(b -> b.getUid().equals(bufferUid));
            if (removed) {
                log.info("üóëÔ∏è Test Responder: Removed buffer {} from scheme {}", bufferUid, connectionSchemeUid);
            } else {
                log.debug("üîç Test Responder: Buffer {} not found in scheme {}", bufferUid, connectionSchemeUid);
            }
        }
    }

    @Override
    public BufferBLM getBufferByUid(UUID bufferUid) {
        BufferBLM buffer = testBuffers.get(bufferUid);
        if (buffer == null) {
            log.debug("üîç Test Responder: Buffer {} not found", bufferUid);
        }
        return buffer;
    }

    @Override
    public List<BufferBLM> getBuffersByClient(UUID clientUid) {
        List<BufferBLM> buffers = clientBuffers.getOrDefault(clientUid, new ArrayList<>());
        log.debug("üîç Test Responder: Found {} buffers for client {}", buffers.size(), clientUid);
        return new ArrayList<>(buffers); // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–æ–ø–∏—é –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
    }

    @Override
    public List<BufferBLM> getBuffersByConnectionScheme(UUID connectionSchemeUid) {
        List<BufferBLM> buffers = schemeBuffers.getOrDefault(connectionSchemeUid, new ArrayList<>());
        log.debug("üîç Test Responder: Found {} buffers for scheme {}", buffers.size(), connectionSchemeUid);
        return new ArrayList<>(buffers); // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–æ–ø–∏—é –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
    }

    @Override
    public List<BufferBLM> getBuffersByDevice(UUID deviceUid) {
        List<BufferBLM> buffers = deviceBuffers.getOrDefault(deviceUid, new ArrayList<>());
        log.debug("üîç Test Responder: Found {} buffers for device {}", buffers.size(), deviceUid);
        return new ArrayList<>(buffers); // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–æ–ø–∏—é –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
    }

    @Override
    public Map<String, Object> getHealthStatus() {
        Map<String, Object> healthStatus = new HashMap<>();
        healthStatus.put("status", "UP");
        healthStatus.put("totalBuffers", testBuffers.size());
        healthStatus.put("totalDevices", deviceBuffers.size());
        healthStatus.put("totalSchemes", schemeBuffers.size());
        healthStatus.put("totalClients", clientBuffers.size());
        healthStatus.put("timestamp", java.time.Instant.now());
        healthStatus.put("service", "TestBufferService");
        
        log.debug(" Test Responder: Health check - {} buffers, {} devices, {} schemes, {} clients", 
                testBuffers.size(), deviceBuffers.size(), schemeBuffers.size(), clientBuffers.size());
        
        return healthStatus;
    }

    @Override
    public BufferBLM updateBuffer(UUID bufferUid, BufferBLM bufferBLM) {
        BufferBLM existingBuffer = testBuffers.get(bufferUid);
        if (existingBuffer == null) {
            log.warn("‚ö†Ô∏è Test Responder: Attempted to update non-existent buffer {}", bufferUid);
            return null;
        }
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª—è –±—É—Ñ–µ—Ä–∞
        if (bufferBLM.getMaxMessagesNumber() != null) {
            existingBuffer.setMaxMessagesNumber(bufferBLM.getMaxMessagesNumber());
        }
        if (bufferBLM.getMaxMessageSize() != null) {
            existingBuffer.setMaxMessageSize(bufferBLM.getMaxMessageSize());
        }
        if (bufferBLM.getMessagePrototype() != null) {
            existingBuffer.setMessagePrototype(bufferBLM.getMessagePrototype());
        }
        
        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º —Å–º–µ–Ω—É —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
        if (bufferBLM.getDeviceUid() != null && !bufferBLM.getDeviceUid().equals(existingBuffer.getDeviceUid())) {
            UUID oldDeviceUid = existingBuffer.getDeviceUid();
            UUID newDeviceUid = bufferBLM.getDeviceUid();
            
            // –£–¥–∞–ª—è–µ–º –∏–∑ —Å—Ç–∞—Ä–æ–≥–æ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
            List<BufferBLM> oldDeviceBuffers = deviceBuffers.get(oldDeviceUid);
            if (oldDeviceBuffers != null) {
                oldDeviceBuffers.removeIf(b -> b.getUid().equals(bufferUid));
            }
            
            // –î–æ–±–∞–≤–ª—è–µ–º –≤ –Ω–æ–≤–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ
            List<BufferBLM> newDeviceBuffers = deviceBuffers.computeIfAbsent(
                    newDeviceUid, k -> new ArrayList<>());
            if (!newDeviceBuffers.contains(existingBuffer)) {
                newDeviceBuffers.add(existingBuffer);
            }
            
            existingBuffer.setDeviceUid(newDeviceUid);
        }
        
        log.info(" Test Responder: Updated buffer {}", bufferUid);
        return existingBuffer;
    }

    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –¥–ª—è —Ç–µ—Å—Ç–æ–≤
    public List<BufferBLM> getAllBuffers() {
        return new ArrayList<>(testBuffers.values());
    }

    public int getTotalBufferCount() {
        return testBuffers.size();
    }

    public int getDeviceBufferCount(UUID deviceUid) {
        List<BufferBLM> buffers = deviceBuffers.get(deviceUid);
        return buffers != null ? buffers.size() : 0;
    }

    public int getSchemeBufferCount(UUID schemeUid) {
        List<BufferBLM> buffers = schemeBuffers.get(schemeUid);
        return buffers != null ? buffers.size() : 0;
    }
}// TestDeviceServiceResponder.java
package com.connection.message.integration;

import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Component;
import org.springframework.test.context.ActiveProfiles;

import com.connection.device.DeviceService;
import com.connection.device.model.DeviceBLM;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
@Primary
@ActiveProfiles("integrationtest")
public class TestDeviceService implements DeviceService {
    // –•—Ä–∞–Ω–∏–ª–∏—â–µ —Ç–µ—Å—Ç–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    private final Map<UUID, DeviceBLM> testDevices = new ConcurrentHashMap<>();
    private final Map<UUID, List<DeviceBLM>> clientDevices = new ConcurrentHashMap<>();

    // –ú–µ—Ç–æ–¥—ã –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ç–µ—Å—Ç–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
    public void addTestDevice(UUID deviceUid, UUID clientUid, String deviceName) {
        DeviceBLM device = new DeviceBLM();
        device.setUid(deviceUid);
        device.setClientUuid(clientUid);
        device.setDeviceName(deviceName);
        device.setDeviceDescription("Test device for integration tests");

        testDevices.put(deviceUid, device);

        List<DeviceBLM> clientDeviceList = clientDevices.computeIfAbsent(
                clientUid, k -> new java.util.ArrayList<>());
        clientDeviceList.add(device);

        log.info(" Test Responder: Added test device {} for client {}", deviceUid, clientUid);
    }

    public void removeTestDevice(UUID deviceUid) {
        DeviceBLM device = testDevices.remove(deviceUid);
        if (device != null) {
            UUID clientUid = device.getClientUuid();
            List<DeviceBLM> clientDevicesList = clientDevices.get(clientUid);
            if (clientDevicesList != null) {
                clientDevicesList.removeIf(d -> d.getUid().equals(deviceUid));
            }
        }
    }

    public void clearTestData() {
        testDevices.clear();
        clientDevices.clear();
        log.info(" Test Responder: All device test data cleared");
    }

    public boolean hasDevice(UUID deviceUid) {
        return testDevices.containsKey(deviceUid);
    }

    public boolean deviceBelongsToClient(UUID deviceUid, UUID clientUid) {
        DeviceBLM device = testDevices.get(deviceUid);
        return device != null && device.getClientUuid().equals(clientUid);
    }

    @Override
    public DeviceBLM createDevice(DeviceBLM deviceBLM) {
        if (deviceBLM.getUid() == null) {
            deviceBLM.setUid(UUID.randomUUID());
        }
        
        testDevices.put(deviceBLM.getUid(), deviceBLM);
        
        List<DeviceBLM> clientDeviceList = clientDevices.computeIfAbsent(
                deviceBLM.getClientUuid(), k -> new java.util.ArrayList<>());
        clientDeviceList.add(deviceBLM);
        
        log.info(" Test Responder: Created device {} for client {}", 
                deviceBLM.getUid(), deviceBLM.getClientUuid());
        
        return deviceBLM;
    }

    @Override
    public void deleteDevice(UUID deviceUid) {
        DeviceBLM device = testDevices.remove(deviceUid);
        if (device != null) {
            UUID clientUid = device.getClientUuid();
            List<DeviceBLM> clientDevicesList = clientDevices.get(clientUid);
            if (clientDevicesList != null) {
                clientDevicesList.removeIf(d -> d.getUid().equals(deviceUid));
            }
            log.info(" Test Responder: Deleted device {}", deviceUid);
        } else {
            log.warn(" Test Responder: Attempted to delete non-existent device {}", deviceUid);
        }
    }

    @Override
    public boolean deviceExists(UUID deviceUid) {
        return testDevices.containsKey(deviceUid);
    }

    @Override
    public DeviceBLM getDevice(UUID deviceUid) {
        DeviceBLM device = testDevices.get(deviceUid);
        if (device == null) {
            log.debug(" Test Responder: Device {} not found", deviceUid);
        }
        return device;
    }

    @Override
    public List<DeviceBLM> getDevicesByClient(UUID clientUid) {
        List<DeviceBLM> devices = clientDevices.getOrDefault(clientUid, java.util.Collections.emptyList());
        log.debug(" Test Responder: Found {} devices for client {}", devices.size(), clientUid);
        return new java.util.ArrayList<>(devices); // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –∫–æ–ø–∏—é –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
    }

    @Override
    public Map<String, Object> getHealthStatus() {
        Map<String, Object> healthStatus = new java.util.HashMap<>();
        healthStatus.put("status", "UP");
        healthStatus.put("totalDevices", testDevices.size());
        healthStatus.put("totalClients", clientDevices.size());
        healthStatus.put("timestamp", java.time.Instant.now());
        healthStatus.put("service", "TestDeviceService");
        
        log.debug(" Test Responder: Health check - {} devices, {} clients", 
                testDevices.size(), clientDevices.size());
        
        return healthStatus;
    }

    @Override
    public DeviceBLM updateDevice(DeviceBLM deviceBLM) {
        if (deviceBLM.getUid() == null) {
            throw new IllegalArgumentException("Device UID cannot be null for update");
        }
        
        DeviceBLM existingDevice = testDevices.get(deviceBLM.getUid());
        if (existingDevice == null) {
            log.warn(" Test Responder: Attempted to update non-existent device {}", deviceBLM.getUid());
            return null;
        }
        
        // –û–±–Ω–æ–≤–ª—è–µ–º –ø–æ–ª—è —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
        if (deviceBLM.getDeviceName() != null) {
            existingDevice.setDeviceName(deviceBLM.getDeviceName());
        }
        if (deviceBLM.getDeviceDescription() != null) {
            existingDevice.setDeviceDescription(deviceBLM.getDeviceDescription());
        }
        if (deviceBLM.getClientUuid() != null && !deviceBLM.getClientUuid().equals(existingDevice.getClientUuid())) {
            // –ï—Å–ª–∏ –∏–∑–º–µ–Ω–∏–ª—Å—è –∫–ª–∏–µ–Ω—Ç, –ø–µ—Ä–µ–º–µ—â–∞–µ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –≤ –¥—Ä—É–≥–æ–π —Å–ø–∏—Å–æ–∫
            UUID oldClientUid = existingDevice.getClientUuid();
            UUID newClientUid = deviceBLM.getClientUuid();
            
            List<DeviceBLM> oldClientDevices = clientDevices.get(oldClientUid);
            if (oldClientDevices != null) {
                oldClientDevices.removeIf(d -> d.getUid().equals(deviceBLM.getUid()));
            }
            
            List<DeviceBLM> newClientDevices = clientDevices.computeIfAbsent(
                    newClientUid, k -> new java.util.ArrayList<>());
            newClientDevices.add(existingDevice);
            
            existingDevice.setClientUuid(newClientUid);
        }
        
        log.info(" Test Responder: Updated device {}", deviceBLM.getUid());
        return existingDevice;
    }
}// BaseMessageIntegrationTest.java
package com.connection.message.integration;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.TestInstance;
import org.junit.jupiter.api.TestMethodOrder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.core.env.Environment;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.TestPropertySource;

import lombok.extern.slf4j.Slf4j;

import java.util.Arrays;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.Collections;
import java.util.List;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("integrationtest")
@TestPropertySource(locations = "classpath:application-integrationtest.properties")
@TestMethodOrder(MethodOrderer.Random.class)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@Slf4j
public abstract class BaseMessageIntegrationTest {

    @Autowired
    protected TestAuthService testAuth;

    @Autowired
    protected TestDeviceAuthService testDeviceAuth;

    @Autowired
    protected TestDeviceService testDevice;

    @Autowired
    protected TestBufferService testBuffer;

    @Autowired
    protected TestConnectionSchemeService testConnectionScheme;

    @Autowired
    protected Environment environment;

    protected TestRestTemplate restTemplate = new TestRestTemplate();

    @Autowired
    protected KafkaTemplate<String, Object> kafkaTemplate;

    @Autowired
    protected NamedParameterJdbcTemplate messageJdbcTemplate;

    protected final Map<String, String> testData = new ConcurrentHashMap<>();
    protected UUID testClientUid;
    protected UUID testDeviceUid;
    protected String testClientToken;
    protected String testDeviceToken;
    protected UUID testBufferUid;
    protected UUID testSchemeUid;
    protected UUID testTargetBufferUid;

    @BeforeEach
    void setUp() {
        checkConfig();
        testClientUid = UUID.randomUUID();
        testDeviceUid = UUID.randomUUID();
        testBufferUid = UUID.randomUUID();
        testTargetBufferUid = UUID.randomUUID();
        testSchemeUid = UUID.randomUUID();
        testClientToken = "client-token-" + UUID.randomUUID().toString();
        testDeviceToken = "device-token-" + UUID.randomUUID().toString();

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º testData –ø–µ—Ä–µ–¥ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º
        testData.clear();

        // –û—á–∏—â–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–µ—Ä–µ–¥ –∫–∞–∂–¥—ã–º —Ç–µ—Å—Ç–æ–º
        testAuth.clearTestData();
        testDeviceAuth.clearTestData();
        testDevice.clearTestData();
        testBuffer.clearTestData();
        testConnectionScheme.clearTestData();

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ –ë–î
        initializeTestDataInDatabase();

        // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º s –ø–æ—Å–ª–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ë–î
        setupTests();
    }

    @AfterEach
    void tearDown() {
        testData.clear();
        cleanupAllTestData();
        clearAuthentication();

        // –û—á–∏—â–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ—Å–ª–µ –∫–∞–∂–¥–æ–≥–æ —Ç–µ—Å—Ç–∞
        testAuth.clearTestData();
        testDeviceAuth.clearTestData();
        testDevice.clearTestData();
        testBuffer.clearTestData();
        testConnectionScheme.clearTestData();
    }

    /**
     * –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ –ë–î
     */
    private void initializeTestDataInDatabase() {
        try {
            // 1. –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞
            String insertClientSql = """
                    INSERT INTO core.client (uid, email, birth_date, username, password)
                    VALUES (:uid, :email, CURRENT_DATE - INTERVAL '25 years', :username, :password)
                    ON CONFLICT (uid) DO NOTHING
                    """;

            int clientsInserted = messageJdbcTemplate.update(insertClientSql, Map.of(
                    "uid", testClientUid,
                    "email", "test.client." + testClientUid + "@example.com",
                    "username", "testclient_" + testClientUid.toString().substring(0, 8),
                    "password", "testpassword123"));

            if (clientsInserted > 0) {
                log.info("‚úÖ Created test client: {}", testClientUid);
            }

            // 2. –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ
            String insertDeviceSql = """
                    INSERT INTO core.device (uid, client_uuid, device_name, device_description)
                    VALUES (:uid, :clientUuid, :deviceName, :deviceDescription)
                    ON CONFLICT (uid) DO NOTHING
                    """;

            int devicesInserted = messageJdbcTemplate.update(insertDeviceSql, Map.of(
                    "uid", testDeviceUid,
                    "clientUuid", testClientUid,
                    "deviceName", "Test Device " + testDeviceUid.toString().substring(0, 8),
                    "deviceDescription", "Integration test device for message service"));

            if (devicesInserted > 0) {
                log.info("‚úÖ Created test device: {} for client: {}", testDeviceUid, testClientUid);
            }

            // 3. –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –±—É—Ñ–µ—Ä—ã
            String insertBufferSql = """
                    INSERT INTO processing.buffer (uid, device_uid, max_messages_number, max_message_size, message_prototype)
                    VALUES (:uid, :deviceUid, :maxMessages, :maxSize, :prototype)
                    ON CONFLICT (uid) DO NOTHING
                    """;

            // –û—Å–Ω–æ–≤–Ω–æ–π –±—É—Ñ–µ—Ä
            int buffersInserted = messageJdbcTemplate.update(insertBufferSql, Map.of(
                    "uid", testBufferUid,
                    "deviceUid", testDeviceUid,
                    "maxMessages", 1000,
                    "maxSize", 1024,
                    "prototype", "{}"));

            if (buffersInserted > 0) {
                log.info("‚úÖ Created test buffer: {} for device: {}", testBufferUid, testDeviceUid);
            }

            // –¶–µ–ª–µ–≤–æ–π –±—É—Ñ–µ—Ä –¥–ª—è –ø–µ—Ä–µ–º–µ—â–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏–π
            int targetBuffersInserted = messageJdbcTemplate.update(insertBufferSql, Map.of(
                    "uid", testTargetBufferUid,
                    "deviceUid", testDeviceUid,
                    "maxMessages", 1000,
                    "maxSize", 1024,
                    "prototype", "{}"));

            if (targetBuffersInserted > 0) {
                log.info("‚úÖ Created target test buffer: {} for device: {}", testTargetBufferUid, testDeviceUid);
            }

            // 4. –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—É—é —Å—Ö–µ–º—É —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
            String insertSchemeSql = """
                    INSERT INTO processing.connection_scheme (uid, client_uid, scheme_json)
                    VALUES (:uid, :clientUid, :schemeJson::jsonb)
                    ON CONFLICT (uid) DO NOTHING
                    """;

            String schemeJson = String.format("""
                    {
                        "usedBuffers": ["%s", "%s"],
                        "bufferTransitions": {
                            "%s": ["%s"]
                        }
                    }
                    """, testBufferUid, testTargetBufferUid, testBufferUid, testTargetBufferUid);

            int schemesInserted = messageJdbcTemplate.update(insertSchemeSql, Map.of(
                    "uid", testSchemeUid,
                    "clientUid", testClientUid,
                    "schemeJson", schemeJson));

            if (schemesInserted > 0) {
                log.info("‚úÖ Created test connection scheme: {}", testSchemeUid);
            }

            // 5. –°–æ–∑–¥–∞–µ–º —Å–≤—è–∑—å —Å—Ö–µ–º—ã —Å –±—É—Ñ–µ—Ä–∞–º–∏
            String insertSchemeBufferSql = """
                    INSERT INTO processing.connection_scheme_buffer (uid, scheme_uid, buffer_uid)
                    VALUES (:uid, :schemeUid, :bufferUid)
                    ON CONFLICT (uid) DO NOTHING
                    """;

            // –°–≤—è–∑—ã–≤–∞–µ–º —Å—Ö–µ–º—É —Å –æ—Å–Ω–æ–≤–Ω—ã–º –±—É—Ñ–µ—Ä–æ–º
            messageJdbcTemplate.update(insertSchemeBufferSql, Map.of(
                    "uid", UUID.randomUUID(),
                    "schemeUid", testSchemeUid,
                    "bufferUid", testBufferUid));

            // –°–≤—è–∑—ã–≤–∞–µ–º —Å—Ö–µ–º—É —Å —Ü–µ–ª–µ–≤—ã–º –±—É—Ñ–µ—Ä–æ–º
            messageJdbcTemplate.update(insertSchemeBufferSql, Map.of(
                    "uid", UUID.randomUUID(),
                    "schemeUid", testSchemeUid,
                    "bufferUid", testTargetBufferUid));

            log.info("‚úÖ Linked scheme {} to buffers {} and {}", testSchemeUid, testBufferUid, testTargetBufferUid);

        } catch (Exception e) {
            log.error("‚ùå Failed to initialize test data in database: {}", e.getMessage(), e);
            throw new RuntimeException("Test data initialization failed", e);
        }
    }

    /**
     * –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç s –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–π —Ä–∞–±–æ—Ç—ã –ø—Ä–æ–≤–µ—Ä–æ–∫ –¥–æ—Å—Ç—É–ø–∞
     */
    private void setupTests() {
        // 1. –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –≤–∞–ª–∏–¥–Ω—ã–µ —Ç–æ–∫–µ–Ω—ã
        testAuth.addValidToken(testClientToken, testClientUid);
        testDeviceAuth.addValidDeviceToken(testDeviceToken, testDeviceUid);

        // 2. –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –≤ s
        testDevice.addTestDevice(testDeviceUid, testClientUid, "Test Device");

        // 3. –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –±—É—Ñ–µ—Ä—ã –≤ s
        testBuffer.addTestBuffer(testBufferUid, testDeviceUid, 1000, 1024);
        testBuffer.addTestBuffer(testTargetBufferUid, testDeviceUid, 1000, 1024);

        // 4. –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —Ç–µ—Å—Ç–æ–≤—É—é —Å—Ö–µ–º—É —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –≤ s
        List<UUID> usedBuffers = List.of(testBufferUid, testTargetBufferUid);
        Map<UUID, List<UUID>> bufferTransitions = Map.of(
                testBufferUid, List.of(testTargetBufferUid));
        testConnectionScheme.addTestConnectionScheme(testSchemeUid, testClientUid, usedBuffers,
                bufferTransitions);

        // 5. –°–≤—è–∑—ã–≤–∞–µ–º —Å—Ö–µ–º—É —Å –±—É—Ñ–µ—Ä–∞–º–∏ –≤ s
        testConnectionScheme.linkSchemeToBuffer(testSchemeUid, testBufferUid);
        testConnectionScheme.linkSchemeToBuffer(testSchemeUid, testTargetBufferUid);

        log.info("‚úÖ Test s setup completed");
    }

    /**
     * –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é –∫–ª–∏–µ–Ω—Ç–∞ —á–µ—Ä–µ–∑ SecurityContext
     */
    protected void setupClientAuthentication() {
        Authentication authentication = new UsernamePasswordAuthenticationToken(
                testClientUid,
                null,
                Collections.singletonList(new SimpleGrantedAuthority("ROLE_CLIENT")));

        SecurityContext context = SecurityContextHolder.createEmptyContext();
        context.setAuthentication(authentication);
        SecurityContextHolder.setContext(context);

        log.info("‚úÖ Test client authentication setup for client: {}", testClientUid);
    }

    /**
     * –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ —á–µ—Ä–µ–∑ SecurityContext
     */
    protected void setupDeviceAuthentication() {
        Authentication authentication = new UsernamePasswordAuthenticationToken(
                testDeviceUid,
                null,
                Collections.singletonList(new SimpleGrantedAuthority("ROLE_DEVICE")));

        SecurityContext context = SecurityContextHolder.createEmptyContext();
        context.setAuthentication(authentication);
        SecurityContextHolder.setContext(context);

        log.info("‚úÖ Test device authentication setup for device: {}", testDeviceUid);
    }

    protected void clearAuthentication() {
        SecurityContextHolder.clearContext();
        log.info("üîí Test authentication cleared");
    }

    /**
     * –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç —Ç–µ—Å—Ç–æ–≤—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞
     */
    protected void setupTestDevices() {
        testDevice.addTestDevice(testDeviceUid, testClientUid, "Test Device");
        log.info("‚úÖ Test device setup: {} for client {}", testDeviceUid, testClientUid);
    }

    /**
     * –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç —Ç–µ—Å—Ç–æ–≤—ã–µ –±—É—Ñ–µ—Ä—ã
     */
    protected void setupTestBuffers() {
        UUID bufferUid = UUID.randomUUID();
        testBuffer.addTestBuffer(bufferUid, testDeviceUid, 1000, 1024);
        log.info("‚úÖ Test buffer setup: {} for device {}", bufferUid, testDeviceUid);
    }

    /**
     * –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç —Ç–µ—Å—Ç–æ–≤—É—é —Å—Ö–µ–º—É —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å –ø–µ—Ä–µ—Ö–æ–¥–∞–º–∏ –º–µ–∂–¥—É –±—É—Ñ–µ—Ä–∞–º–∏
     */
    protected UUID setupTestConnectionSchemeWithTransitions(UUID sourceBufferUid, UUID targetBufferUid) {
        UUID schemeUid = UUID.randomUUID();
        List<UUID> usedBuffers = List.of(sourceBufferUid, targetBufferUid);
        Map<UUID, List<UUID>> bufferTransitions = Map.of(
                sourceBufferUid, List.of(targetBufferUid));

        testConnectionScheme.addTestConnectionScheme(schemeUid, testClientUid, usedBuffers, bufferTransitions);
        log.info("‚úÖ Test connection scheme setup: {} with transitions {} -> {}", schemeUid, sourceBufferUid,
                targetBufferUid);

        return schemeUid;
    }

    protected void checkConfig() {
        log.info("=== Message Service Integration Test Configuration ===");
        log.info("Active profiles: {}", Arrays.toString(environment.getActiveProfiles()));
        log.info("Kafka servers: {}", environment.getProperty("spring.kafka.bootstrap-servers"));
        log.info("Database URL: {}", environment.getProperty("app.datasource.message.xa-properties.url"));
        log.info("Database user: {}", environment.getProperty("app.datasource.message.xa-properties.user"));
        log.info("Service name: {}", environment.getProperty("spring.application.name"));
        log.info("=====================================================");
    }

   // –í BaseMessageIntegrationTest - —É–ª—É—á—à–∏—Ç—å –º–µ—Ç–æ–¥ –æ—á–∏—Å—Ç–∫–∏
protected void cleanupAllTestData() {
    try {
        UUID currentClientUid = getTestClientUid();
        log.info("Cleaning up data for client: {}", currentClientUid);

        // 1. –û—á–∏—Å—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π —á–µ—Ä–µ–∑ –±—É—Ñ–µ—Ä—ã –∫–ª–∏–µ–Ω—Ç–∞
        String deleteMessagesSql = """
            DELETE FROM processing.message 
            WHERE buffer_uid IN (
                SELECT b.uid FROM processing.buffer b
                JOIN core.device d ON b.device_uid = d.uid
                WHERE d.client_uuid = :clientUid
            )
            """;
        try {
            int messagesDeleted = messageJdbcTemplate.update(deleteMessagesSql, 
                    Map.of("clientUid", currentClientUid));
            if (messagesDeleted > 0) {
                log.debug("Deleted {} messages for client: {}", messagesDeleted, currentClientUid);
            }
        } catch (Exception e) {
            log.debug("No messages to delete for client: {}", currentClientUid);
        }

        // 2. –û—á–∏—Å—Ç–∫–∞ —Å–≤—è–∑–µ–π —Å—Ö–µ–º—ã —Å –±—É—Ñ–µ—Ä–∞–º–∏
        String deleteSchemeBuffersSql = """
            DELETE FROM processing.connection_scheme_buffer 
            WHERE scheme_uid IN (
                SELECT uid FROM processing.connection_scheme 
                WHERE client_uid = :clientUid
            ) OR buffer_uid IN (
                SELECT b.uid FROM processing.buffer b
                JOIN core.device d ON b.device_uid = d.uid
                WHERE d.client_uuid = :clientUid
            )
            """;
        try {
            int schemeBuffersDeleted = messageJdbcTemplate.update(deleteSchemeBuffersSql,
                    Map.of("clientUid", currentClientUid));
            if (schemeBuffersDeleted > 0) {
                log.debug("Deleted {} scheme-buffer links for client: {}", schemeBuffersDeleted, currentClientUid);
            }
        } catch (Exception e) {
            log.debug("No scheme-buffer links to delete for client: {}", currentClientUid);
        }

        // 3. –û—á–∏—Å—Ç–∫–∞ —Å—Ö–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∫–ª–∏–µ–Ω—Ç–∞
        String deleteSchemesSql = "DELETE FROM processing.connection_scheme WHERE client_uid = :clientUid";
        try {
            int schemesDeleted = messageJdbcTemplate.update(deleteSchemesSql, Map.of("clientUid", currentClientUid));
            if (schemesDeleted > 0) {
                log.debug("Deleted {} connection schemes for client: {}", schemesDeleted, currentClientUid);
            }
        } catch (Exception e) {
            log.debug("No connection schemes to delete for client: {}", currentClientUid);
        }

        // 4. –û—á–∏—Å—Ç–∫–∞ –±—É—Ñ–µ—Ä–æ–≤ —á–µ—Ä–µ–∑ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –∫–ª–∏–µ–Ω—Ç–∞
        String deleteBuffersSql = """
            DELETE FROM processing.buffer 
            WHERE device_uid IN (
                SELECT uid FROM core.device 
                WHERE client_uuid = :clientUid
            )
            """;
        try {
            int buffersDeleted = messageJdbcTemplate.update(deleteBuffersSql, Map.of("clientUid", currentClientUid));
            if (buffersDeleted > 0) {
                log.debug("Deleted {} buffers for client: {}", buffersDeleted, currentClientUid);
            }
        } catch (Exception e) {
            log.debug("No buffers to delete for client: {}", currentClientUid);
        }

        // 5. –û—á–∏—Å—Ç–∫–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤ –∫–ª–∏–µ–Ω—Ç–∞
        String deleteDevicesSql = "DELETE FROM core.device WHERE client_uuid = :clientUid";
        try {
            int devicesDeleted = messageJdbcTemplate.update(deleteDevicesSql, Map.of("clientUid", currentClientUid));
            if (devicesDeleted > 0) {
                log.debug("Deleted {} devices for client: {}", devicesDeleted, currentClientUid);
            }
        } catch (Exception e) {
            log.debug("No devices to delete for client: {}", currentClientUid);
        }

        // 6. –û—á–∏—Å—Ç–∫–∞ —Å–∞–º–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞
        String deleteClientSql = "DELETE FROM core.client WHERE uid = :clientUid";
        try {
            int clientsDeleted = messageJdbcTemplate.update(deleteClientSql, Map.of("clientUid", currentClientUid));
            if (clientsDeleted > 0) {
                log.info("‚úÖ Cleaned up client and all related data: {}", currentClientUid);
            }
        } catch (Exception e) {
            log.debug("No client to delete: {}", currentClientUid);
        }

    } catch (Exception e) {
        log.warn("Cleanup warning for client {}: {}", getTestClientUid(), e.getMessage());
    }
}

    protected void sleep(long milliseconds) {
        try {
            log.debug("Sleeping for {} ms", milliseconds);
            TimeUnit.MILLISECONDS.sleep(milliseconds);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.warn("Sleep interrupted", e);
        }
    }

    protected HttpEntity<Object> createHttpEntity(Object body) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        return new HttpEntity<>(body, headers);
    }

    protected HttpEntity<Object> createHttpEntityWithClientAuth(Object body) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.setBearerAuth(testClientToken);
        return new HttpEntity<>(body, headers);
    }

    protected HttpEntity<Object> createHttpEntityWithDeviceAuth(Object body) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.set("Device-Authorization", "Bearer " + testDeviceToken);
        return new HttpEntity<>(body, headers);
    }

    protected UUID getTestClientUid() {
        return testClientUid;
    }

    protected UUID getTestDeviceUid() {
        return testDeviceUid;
    }

    protected String getTestClientToken() {
        return testClientToken;
    }

    protected String getTestDeviceToken() {
        return testDeviceToken;
    }

    protected UUID getTestBufferUid() {
        return testBufferUid;
    }

    protected UUID getTestSchemeUid() {
        return testSchemeUid;
    }

    protected UUID getTestTargetBufferUid() {
        return testTargetBufferUid;
    }
}// TestAuthServiceResponder.java
package com.connection.message.integration;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.data.util.Pair;
import org.springframework.stereotype.Component;
import org.springframework.test.context.ActiveProfiles;

import com.connection.client.model.ClientBLM;
import com.connection.service.auth.AuthService;
import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.RefreshTokenBLM;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
@ActiveProfiles("integrationtest")
public class TestAuthService implements AuthService{
    // –•—Ä–∞–Ω–∏–ª–∏—â–µ –≤–∞–ª–∏–¥–Ω—ã—Ö —Ç–æ–∫–µ–Ω–æ–≤ –∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏—Ö clientUid
    private final Map<String, UUID> validTokens = new ConcurrentHashMap<>();


    // –ú–µ—Ç–æ–¥—ã –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ç–µ—Å—Ç–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
    public void addValidToken(String token, UUID clientUid) {
        validTokens.put(token, clientUid);
        log.info("üîë Test Responder: Added valid token for client {}", clientUid);
    }

    public void removeToken(String token) {
        validTokens.remove(token);
        log.info("üóëÔ∏è Test Responder: Removed token");
    }

    public void clearTestData() {
        validTokens.clear();
        log.info("üßπ Test Responder: All auth test data cleared");
    }

    public boolean hasValidToken(String token) {
        return validTokens.containsKey(token);
    }

    @Override
    public Pair<AccessTokenBLM, RefreshTokenBLM> authorizeByEmail(String email, String password) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'authorizeByEmail'");
    }

    @Override
    public Map<String, Object> getHealthStatus() {
        // TODO Auto-generated method stub
        return Map.of("status", "OK");
    }

    @Override
    public Pair<AccessTokenBLM, RefreshTokenBLM> refresh(RefreshTokenBLM refreshTokenBLM) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'refresh'");
    }

    @Override
    public void register(ClientBLM clientBLM) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'register'");
    }

    @Override
    public void validateAccessToken(AccessTokenBLM accessTokenBLM) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'validateAccessToken'");
    }

    @Override
    public AccessTokenBLM validateAccessToken(String token) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'validateAccessToken'");
    }

    @Override
    public void validateRefreshToken(RefreshTokenBLM refreshTokenBLM) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'validateRefreshToken'");
    }
}