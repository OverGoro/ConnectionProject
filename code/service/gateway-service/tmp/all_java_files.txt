// SwaggerConfig.java
package com.connection.gateway.config.swagger;

import io.swagger.v3.oas.annotations.enums.SecuritySchemeIn;
import io.swagger.v3.oas.annotations.enums.SecuritySchemeType;
import io.swagger.v3.oas.annotations.security.SecurityScheme;
import io.swagger.v3.oas.annotations.security.SecuritySchemes;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import io.swagger.v3.oas.annotations.enums.SecuritySchemeType;
import io.swagger.v3.oas.annotations.security.SecurityScheme;
import io.swagger.v3.oas.annotations.security.SecuritySchemes;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@SecuritySchemes({
    @SecurityScheme(
        name = "clientAuth",
        type = SecuritySchemeType.HTTP,
        bearerFormat = "JWT",
        scheme = "bearer"

    ),
    @SecurityScheme(
        name = "deviceAuth", 
        type = SecuritySchemeType.HTTP,
        bearerFormat = "JWT",
        scheme = "bearer"
    )
})
public class SwaggerConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("Connection Project API")
                        .version("1.0")
                        .description("API with dual authentication support: Client and Device tokens"))
                .components(new Components()
                        .addSecuritySchemes("clientAuth", 
                            new io.swagger.v3.oas.models.security.SecurityScheme()
                                .type(io.swagger.v3.oas.models.security.SecurityScheme.Type.APIKEY)
                                .in(io.swagger.v3.oas.models.security.SecurityScheme.In.HEADER)
                                .name("Authorization")
                                .description("Client JWT Token. Format: Bearer {token}"))
                        .addSecuritySchemes("deviceAuth",
                            new io.swagger.v3.oas.models.security.SecurityScheme()
                                .type(io.swagger.v3.oas.models.security.SecurityScheme.Type.APIKEY)
                                .in(io.swagger.v3.oas.models.security.SecurityScheme.In.HEADER)
                                .name("X-Device-Authorization")
                                .description("Device JWT Token. Format: Bearer {token}")))
                .addSecurityItem(new SecurityRequirement().addList("clientAuth"))
                .addSecurityItem(new SecurityRequirement().addList("deviceAuth"));
    }
}package com.connection.gateway.config.spring;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ApplicationConfig {
    @Value("${spring.application.name:gateway-service}")
    private String appNameString;

    @Bean
    @Qualifier("appName")
    String appName(){
        return appNameString;
    }
}
package com.connection.gateway.config.transaction;

import java.util.UUID;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.jta.JtaTransactionManager;

import com.atomikos.icatch.jta.UserTransactionManager;

import jakarta.transaction.SystemException;

@Configuration
public class TransactionConfig {
    
    @Bean
    public UserTransactionManager userTransactionManager() throws SystemException {
        setPropertyIfNotExists("com.atomikos.icatch.log_base_name", "atomikos-tm-" + UUID.randomUUID().toString().substring(0, 8));
        setPropertyIfNotExists("com.atomikos.icatch.log_base_dir", "./logs");
        setPropertyIfNotExists("com.atomikos.icatch.tm_unique_name", "tm-" + UUID.randomUUID().toString().substring(0, 8));
        
        UserTransactionManager manager = new UserTransactionManager();
        manager.setTransactionTimeout(300);
        manager.setForceShutdown(true);
        return manager;
    }

    @Bean(name = "atomicosTransactionManager")
    public JtaTransactionManager jtaTransactionManager() throws SystemException {
        JtaTransactionManager jtaTransactionManager = new JtaTransactionManager();
        jtaTransactionManager.setTransactionManager(userTransactionManager());
        jtaTransactionManager.setUserTransaction(userTransactionManager());
        return jtaTransactionManager;
    }
    
    /**
     * Устанавливает системное свойство только если оно еще не было установлено
     * @param key ключ свойства
     * @param value значение свойства
     */
    private void setPropertyIfNotExists(String key, String value) {
        if (System.getProperty(key) == null) {
            System.setProperty(key, value);
            System.out.println("Set property: " + key + " = " + value);
        } else {
            System.out.println("Property already set: " + key + " = " + System.getProperty(key));
        }
    }
}package com.connection.gateway.config.security;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import com.connection.device.token.model.DeviceAccessTokenBLM;
import com.connection.device.token.model.DeviceTokenBLM;
import com.connection.service.auth.AuthService;
import com.connection.token.model.AccessTokenBLM;
import com.service.device.auth.DeviceAuthService;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Collections;

@Slf4j
@Component("gatewayAuthenticationFilter")
@RequiredArgsConstructor
public class AuthenticationFilter extends OncePerRequestFilter {

    private final AuthService authClient;
    private final DeviceAuthService deviceAuthClient;

    private static final String CLIENT_AUTH_HEADER = "Authorization";
    private static final String DEVICE_AUTH_HEADER = "X-Device-Authorization"; // Новый заголовок для device
    private static final String BEARER_PREFIX = "Bearer ";

    @Override
    protected void doFilterInternal(HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain) throws ServletException, IOException {
            log.info("=== FILTER STARTED ===");
        log.info("Request URI: {}", request.getRequestURI());
        log.info("Client Auth Header: {}", request.getHeader(CLIENT_AUTH_HEADER));
        log.info("Device Auth Header: {}", request.getHeader(DEVICE_AUTH_HEADER));


        String clientAuthHeader = request.getHeader(CLIENT_AUTH_HEADER);
        String deviceAuthHeader = request.getHeader(DEVICE_AUTH_HEADER);

        boolean clientAuthenticated = false;
        boolean deviceAuthenticated = false;

        // Сначала пробуем аутентифицировать клиента
        if (clientAuthHeader != null && clientAuthHeader.startsWith(BEARER_PREFIX)) {
            String jwtToken = clientAuthHeader.substring(BEARER_PREFIX.length());
            clientAuthenticated = authenticateClientWithToken(jwtToken, request);
        }

        // Если клиент не аутентифицирован, пробуем device
        if (!clientAuthenticated && deviceAuthHeader != null && deviceAuthHeader.startsWith(BEARER_PREFIX)) {
            String jwtToken = deviceAuthHeader.substring(BEARER_PREFIX.length());
            deviceAuthenticated = authenticateDeviceWithToken(jwtToken, request);
        }

        // Если ни один токен не прошел аутентификацию, но были предоставлены - возвращаем ошибку
        if ((clientAuthHeader != null && clientAuthHeader.startsWith(BEARER_PREFIX) && !clientAuthenticated) ||
            (deviceAuthHeader != null && deviceAuthHeader.startsWith(BEARER_PREFIX) && !deviceAuthenticated)) {
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            return;
        }

        filterChain.doFilter(request, response);
    }

    private boolean authenticateClientWithToken(String token, HttpServletRequest request) {
        try {
            String cleanToken = token.trim();
            log.info("Validating client token: {}...", cleanToken.substring(0, Math.min(cleanToken.length(), 20)));

            AccessTokenBLM accessTokenBLM = authClient.validateAccessToken(cleanToken);

            UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                    accessTokenBLM.getClientUID(),
                    null,
                    Collections.singletonList(new SimpleGrantedAuthority("ROLE_CLIENT")));

            authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
            SecurityContextHolder.getContext().setAuthentication(authentication);

            log.info("Successfully authenticated client: {}", accessTokenBLM.getClientUID());
            return true;
        } catch (Exception e) {
            log.warn("Client authentication failed: {}", e.getMessage());
            return false;
        }
    }

    private boolean authenticateDeviceWithToken(String token, HttpServletRequest request) {
        try {
            String cleanToken = token.trim();
            log.info("Validating device token: {}...", cleanToken.substring(0, Math.min(cleanToken.length(), 20)));

            DeviceAccessTokenBLM deviceAccessTokenBLM = deviceAuthClient.validateDeviceAccessToken(cleanToken);
            DeviceTokenBLM deviceTokenBLM = deviceAuthClient.getDeviceToken(deviceAccessTokenBLM.getDeviceTokenUid());

            UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                    deviceTokenBLM.getDeviceUid(),
                    null,
                    Collections.singletonList(new SimpleGrantedAuthority("ROLE_DEVICE")));

            authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
            SecurityContextHolder.getContext().setAuthentication(authentication);

            log.info("Successfully authenticated device: {}", deviceTokenBLM.getDeviceUid());
            return true;
        } catch (Exception e) {
            log.warn("Device authentication failed: {}", e.getMessage());
            return false;
        }
    }
}package com.connection.gateway.config.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;


import lombok.RequiredArgsConstructor;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
@RequiredArgsConstructor
public class SecurityConfig {

    private final AuthenticationFilter clientAuthenticationFilter;
    // Убираем deviceAuthenticationFilter, т.к. он теперь объединен

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                .csrf(csrf -> csrf.disable())
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/swagger-ui.html").permitAll()
                        .requestMatchers("/swagger-ui/**").permitAll()
                        .requestMatchers("/api-docs/**").permitAll()
                        .requestMatchers("/webjars/**").permitAll()
                        .requestMatchers("/v3/api-docs/**").permitAll()

                        .requestMatchers("/api/v1/auth/**").permitAll()

                        .requestMatchers("/api/v1/device/auth/device-token").hasAuthority("ROLE_CLIENT")
                        .requestMatchers("/api/v1/device/auth/device-token/**").hasAuthority("ROLE_CLIENT")
                        .requestMatchers("/api/v1/device/auth/**").permitAll()

                        .requestMatchers("/api/v1/message/health").permitAll()
                        .requestMatchers("/api/v1/message/messages").hasAnyAuthority("ROLE_CLIENT", "ROLE_DEVICE")
                        .requestMatchers("/api/v1/message/messages/**").hasAnyAuthority("ROLE_CLIENT", "ROLE_DEVICE")
                        
                        .requestMatchers("/api/v1/scheme/health").permitAll()
                        .requestMatchers("/api/v1/scheme/**").hasAuthority("ROLE_CLIENT")
                        
                        .requestMatchers("/api/v1/device/health").permitAll()
                        .requestMatchers("/api/v1/device/**").authenticated()//hasAuthority("ROLE_CLIENT")

                        .requestMatchers("/api/v1/buffer/health").permitAll()
                        .requestMatchers("/api/v1/buffer/**").hasAuthority("ROLE_CLIENT")
                        
                        .anyRequest().denyAll()
                )
                // Оставляем только один фильтр
                .addFilterBefore(clientAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)
                .build();
    }
}// GatewayServiceApplication.java
package com.connection.gateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.FilterType;


@SpringBootApplication
@ComponentScan(
    basePackages = {
        "com.connection.gateway",
        "com.connection.service.auth",
        "com.service.device.auth", 
        "com.connection.device",
        "com.connection.message",
        "com.service.buffer",
        "com.service.connectionscheme"
    },
    excludeFilters = {
        @ComponentScan.Filter(
            type = FilterType.ASSIGNABLE_TYPE,
            classes = {                
                com.connection.service.auth.AuthServiceApplication.class,
                com.connection.device.DeviceServiceApplication.class,
                com.service.buffer.BufferServiceApplication.class,
                com.service.connectionscheme.ConnectionSchemeServiceApplication.class,
                com.service.device.auth.DeviceAuthServiceApplication.class,
                com.connection.message.MessageServiceApplication.class,
            }
        ),
        @ComponentScan.Filter(
            type = FilterType.REGEX,
            pattern = {
                "com.connection.service.auth.config.kafka.*",
                "com.connection.device.config.kafka.*",
                "com.service.buffer.config.kafka.*",
                "com.service.connectionscheme.config.kafka.*",
                "com.service.device.auth.config.kafka.*",
                "com.connection.message.config.kafka.*",
            }
        ),
        @ComponentScan.Filter(
            type = FilterType.REGEX,
            pattern = {
                "com.connection.service.auth.config.security.*",
                "com.connection.device.config.security.*",
                "com.service.buffer.config.security.*",
                "com.service.connectionscheme.config.security.*",
                "com.service.device.auth.config.security.*",
                "com.connection.message.config.security.*",
            }
        ),
        @ComponentScan.Filter(
            type = FilterType.REGEX,
            pattern = {
                "com.connection.service.auth.config.spring.*",
                "com.connection.device.config.spring.*",
                "com.service.buffer.config.spring.*",
                "com.service.connectionscheme.config.spring.*",
                "com.service.device.auth.config.spring.*",
                "com.connection.message.config.spring.*",
            }
        ),
        @ComponentScan.Filter(
            type = FilterType.REGEX,
            pattern = {
                "com.connection.service.auth.config.swagger.*",
                "com.connection.device.config.swagger.*",
                "com.service.buffer.config.swagger.*",
                "com.service.connectionscheme.config.swagger.*",
                "com.service.device.auth.config.swagger.*",
                "com.connection.message.config.swagger.*",
            }
        ),
        @ComponentScan.Filter(
            type = FilterType.REGEX,
            pattern = {
                "com.connection.service.auth.config.transaction.*",
                "com.connection.device.config.transaction.*",
                "com.service.buffer.config.transaction.*",
                "com.service.connectionscheme.config.transaction.*",
                "com.service.device.auth.config.transaction.*",
                "com.connection.message.config.transaction.*",
            }
        ),
                @ComponentScan.Filter(
            type = FilterType.REGEX,
            pattern = {
                "com.connection.service.auth.*Filter.*",
                "com.connection.device.*Filter.*",
                "com.service.buffer.*Filter.*",
                "com.service.connectionscheme.*Filter.*",
                "com.service.device.auth.*Filter.*",
                "com.connection.message.*Filter.*",
            }
        ),
        
    }
)
public class GatewayServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(GatewayServiceApplication.class, args);
    }
}package com.connection.gateway;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.http.*;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.TestPropertySource;

import java.util.*;

import static org.assertj.core.api.Assertions.assertThat;

// @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
// @TestPropertySource(properties = {"server.port=18081"})
@ActiveProfiles("test")
public class GatewayE2ETest {

    @Autowired
    private TestRestTemplate restTemplate;

    private static final Random random = new Random();

    // Вспомогательные методы для генерации уникальных данных
    private String generateUniqueEmail() {
        return "testuser" + random.nextInt(100000) + "@test.com";
    }

    private String generateUniqueUsername() {
        return "testuser" + random.nextInt(100000);
    }

    private String generateUniqueDeviceName() {
        return "TestDevice" + random.nextInt(100000);
    }

    @Test
    public void testFullIntegrationFlow() {
        System.out.println("=== STARTING E2E TEST ===");
        
        // 1. Регистрация нового клиента
        System.out.println("Step 1: Registering new client");
        String clientEmail = generateUniqueEmail();
        String username = generateUniqueUsername();
        UUID userId = UUID.randomUUID();
        UUID deviceId = UUID.randomUUID();
        
        Map<String, Object> clientRegistration = new HashMap<>();
        clientRegistration.put("email", clientEmail);
        clientRegistration.put("username", username);
        clientRegistration.put("password", "TestPassword123!");
        clientRegistration.put("birthDate", "2002-01-01T01:31:40.067Z");
        clientRegistration.put("uid", userId.toString());

        ResponseEntity<Map> registrationResponse = restTemplate.postForEntity(
            "/api/v1/auth/register",
            clientRegistration,
            Map.class
        );
        
        assertThat(registrationResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(registrationResponse.getBody()).isNotNull();
        System.out.println("Client registered successfully: " + clientEmail);

        // 2. Логин для получения токенов
        System.out.println("Step 2: Logging in to get tokens");
        Map<String, String> loginRequest = new HashMap<>();
        loginRequest.put("email", clientEmail);
        loginRequest.put("password", "TestPassword123!");

        ResponseEntity<Map> loginResponse = restTemplate.postForEntity(
            "/api/v1/auth/login",
            loginRequest,
            Map.class
        );
        
        assertThat(loginResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(loginResponse.getBody()).isNotNull();
        
        String accessToken = (String) loginResponse.getBody().get("accessToken");
        String refreshToken = (String) loginResponse.getBody().get("refreshToken");
        String clientUid = (String) loginResponse.getBody().get("clientUid");
        
        assertThat(accessToken).isNotBlank();
        assertThat(refreshToken).isNotBlank();
        assertThat(clientUid).isEqualTo(userId.toString());
        System.out.println("Login successful, client UID: " + clientUid);

        // Создаем заголовки с авторизацией клиента (Bearer token)
        HttpHeaders clientHeaders = new HttpHeaders();
        clientHeaders.set("Authorization", "Bearer " + accessToken); // Правильный формат Bearer token
        clientHeaders.setContentType(MediaType.APPLICATION_JSON);

        // 3. Создание устройства
        System.out.println("Step 3: Creating device");
        String deviceName = generateUniqueDeviceName();
        Map<String, Object> deviceRequest = new HashMap<>();
        deviceRequest.put("uid", deviceId.toString());
        deviceRequest.put("clientUuid", clientUid);
        deviceRequest.put("deviceName", deviceName);
        deviceRequest.put("deviceDescription", "Test Device Description");

        HttpEntity<Map<String, Object>> deviceEntity = new HttpEntity<>(deviceRequest, clientHeaders);
        ResponseEntity<Map> deviceResponse = restTemplate.postForEntity(
            "/api/v1/device/devices",
            deviceEntity,
            Map.class
        );
        
        assertThat(deviceResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(deviceResponse.getBody()).isNotNull();
        
        String deviceUid = (String) deviceResponse.getBody().get("deviceUid");
        assertThat(deviceUid).isEqualTo(deviceId.toString());
        System.out.println("Device created successfully: " + deviceUid);

        // 6. Создание буфера (требует авторизации клиента)
        System.out.println("Step 6: Creating buffer");
        Map<String, Object> bufferRequest = new HashMap<>();
        bufferRequest.put("uid", UUID.randomUUID().toString());
        bufferRequest.put("deviceUid", deviceUid);
        bufferRequest.put("maxMessagesNumber", 100);
        bufferRequest.put("maxMessageSize", 1024);
        bufferRequest.put("messagePrototype", "{\"type\":\"test\"}");

        HttpEntity<Map<String, Object>> bufferEntity = new HttpEntity<>(bufferRequest, clientHeaders);
        ResponseEntity<Map> bufferResponse = restTemplate.postForEntity(
            "/api/v1/buffer/buffers",
            bufferEntity,
            Map.class
        );
        
        assertThat(bufferResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(bufferResponse.getBody()).isNotNull();
        
        String bufferUid = (String) bufferResponse.getBody().get("bufferUuid");
        assertThat(bufferUid).isNotBlank();
        System.out.println("Buffer created successfully: " + bufferUid);

        // 7. Создание схемы подключения (требует авторизации клиента)
        System.out.println("Step 7: Creating connection scheme");
        Map<String, Object> schemeRequest = new HashMap<>();
        schemeRequest.put("uid", UUID.randomUUID().toString());
        schemeRequest.put("clientUid", clientUid);
        schemeRequest.put("schemeJson", "{\"" + bufferUid + "\":[]}"); // Правильный формат JSON согласно валидатору
        schemeRequest.put("usedBuffers", Collections.singletonList(bufferUid));

        HttpEntity<Map<String, Object>> schemeEntity = new HttpEntity<>(schemeRequest, clientHeaders);
        ResponseEntity<Map> schemeResponse = restTemplate.postForEntity(
            "/api/v1/scheme/schemes",
            schemeEntity,
            Map.class
        );

        assertThat(schemeResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(schemeResponse.getBody()).isNotNull();

        String schemeUid = (String) schemeResponse.getBody().get("schemeUid");
        assertThat(schemeUid).isNotBlank();
        System.out.println("Connection scheme created successfully: " + schemeUid);

        // 8. Добавление сообщения от устройства (используем device Bearer token)
        System.out.println("Step 8: Adding message from device");
        HttpHeaders deviceHeaders = new HttpHeaders();
        deviceHeaders.set("Authorization", "Bearer " + accessToken);
        deviceHeaders.setContentType(MediaType.APPLICATION_JSON);

        Map<String, Object> messageRequest = new HashMap<>();
        messageRequest.put("uid", UUID.randomUUID().toString()); // Добавляем обязательный uid
        messageRequest.put("bufferUid", bufferUid);
        messageRequest.put("content", "{\"sensor\":\"temperature\",\"value\":25.5}");
        messageRequest.put("contentType", "application/json");
        messageRequest.put("createdAt", new Date().toInstant().toString()); // Добавляем обязательное поле createdAt

        HttpEntity<Map<String, Object>> messageEntity = new HttpEntity<>(messageRequest, deviceHeaders);
        ResponseEntity<Void> messageResponse = restTemplate.postForEntity(
            "/api/v1/message/messages",
            messageEntity,
            Void.class
        );

        assertThat(messageResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
        System.out.println("Message added successfully");

        // 9. Получение сообщений (можно использовать как client, так и device авторизацию)
        System.out.println("Step 9: Retrieving messages using client token");
        HttpEntity<Void> getMessagesEntity = new HttpEntity<>(clientHeaders);
        ResponseEntity<Map> getMessagesResponse = restTemplate.exchange(
            "/api/v1/message/messages/?bufferUids=" + bufferUid + "&limit=10",
            HttpMethod.GET,
            getMessagesEntity,
            Map.class
        );
        
        assertThat(getMessagesResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(getMessagesResponse.getBody()).isNotNull();
        System.out.println("Messages retrieved successfully");

        // 10. Проверка health endpoints (не требуют авторизации)
        System.out.println("Step 10: Checking health endpoints");
        ResponseEntity<Map> healthResponse = restTemplate.getForEntity("/api/v1/auth/health", Map.class);
        assertThat(healthResponse.getStatusCode()).isEqualTo(HttpStatus.OK);

        healthResponse = restTemplate.getForEntity("/api/v1/device/health", Map.class);
        assertThat(healthResponse.getStatusCode()).isEqualTo(HttpStatus.OK);

        healthResponse = restTemplate.getForEntity("/api/v1/buffer/health", Map.class);
        assertThat(healthResponse.getStatusCode()).isEqualTo(HttpStatus.OK);

        healthResponse = restTemplate.getForEntity("/api/v1/scheme/health", Map.class);
        assertThat(healthResponse.getStatusCode()).isEqualTo(HttpStatus.OK);

        healthResponse = restTemplate.getForEntity("/api/v1/message/health", Map.class);
        assertThat(healthResponse.getStatusCode()).isEqualTo(HttpStatus.OK);

        healthResponse = restTemplate.getForEntity("/api/v1/device/auth/health", Map.class);
        assertThat(healthResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
        System.out.println("All health checks passed");

        // 11. Очистка данных (удаление созданных сущностей)
        System.out.println("Step 11: Cleaning up test data");
        
        // Удаление схемы подключения (требует ROLE_CLIENT)
        System.out.println("Deleting connection scheme: " + schemeUid);
        String deleteSchemesUrl = "/api/v1/scheme/schemes?schemeUids=" + schemeUid;
        HttpEntity<Void> deleteSchemeEntity = new HttpEntity<>(clientHeaders);
        ResponseEntity<Void> deleteSchemeResponse = restTemplate.exchange(
            deleteSchemesUrl,
            HttpMethod.DELETE,
            deleteSchemeEntity,
            Void.class
        );

        // Удаление буфера (требует ROLE_CLIENT)
        System.out.println("Deleting buffer: " + bufferUid);
        String deleteBuffersUrl = "/api/v1/buffer/buffers?bufferUids=" + bufferUid;
        HttpEntity<Void> deleteBufferEntity = new HttpEntity<>(clientHeaders);
        ResponseEntity<Void> deleteBufferResponse = restTemplate.exchange(
            deleteBuffersUrl,
            HttpMethod.DELETE,
            deleteBufferEntity,
            Void.class
        );
        

        // Удаление токена устройства (требует ROLE_CLIENT)
        System.out.println("Deleting device token for device: " + deviceUid);
        String deleteDeviceTokenUrl = "/api/v1/device/auth/device-token?deviceUids=" + deviceUid;
        HttpEntity<Void> deleteDeviceTokenEntity = new HttpEntity<>(clientHeaders);
        ResponseEntity<Void> deleteDeviceTokenResponse = restTemplate.exchange(
            deleteDeviceTokenUrl,
            HttpMethod.DELETE,
            deleteDeviceTokenEntity,
            Void.class
        );

        // Удаление устройства (требует авторизации)
        System.out.println("Deleting device: " + deviceUid);
        String deleteDeviceUrl = "/api/v1/device/devices/" + deviceUid;
        HttpEntity<Void> deleteDeviceEntity = new HttpEntity<>(clientHeaders);
        ResponseEntity<Void> deleteDeviceResponse = restTemplate.exchange(
            deleteDeviceUrl,
            HttpMethod.DELETE,
            deleteDeviceEntity,
            Void.class
        );

        System.out.println("=== E2E TEST COMPLETED SUCCESSFULLY ===");
    }
}