// SwaggerConfig.java
package com.connection.gateway.config.swagger;

import io.swagger.v3.oas.annotations.enums.SecuritySchemeIn;
import io.swagger.v3.oas.annotations.enums.SecuritySchemeType;
import io.swagger.v3.oas.annotations.security.SecurityScheme;
import io.swagger.v3.oas.annotations.security.SecuritySchemes;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import io.swagger.v3.oas.annotations.enums.SecuritySchemeType;
import io.swagger.v3.oas.annotations.security.SecurityScheme;
import io.swagger.v3.oas.annotations.security.SecuritySchemes;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@SecuritySchemes({
    @SecurityScheme(
        name = "clientAuth",
        type = SecuritySchemeType.HTTP,
        bearerFormat = "JWT",
        scheme = "bearer"

    ),
    @SecurityScheme(
        name = "deviceAuth", 
        type = SecuritySchemeType.HTTP,
        bearerFormat = "JWT",
        scheme = "bearer"
    )
})
public class SwaggerConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("Connection Project API")
                        .version("1.0")
                        .description("API with dual authentication support: Client and Device tokens"))
                .components(new Components()
                        .addSecuritySchemes("clientAuth", 
                            new io.swagger.v3.oas.models.security.SecurityScheme()
                                .type(io.swagger.v3.oas.models.security.SecurityScheme.Type.APIKEY)
                                .in(io.swagger.v3.oas.models.security.SecurityScheme.In.HEADER)
                                .name("Authorization")
                                .description("Client JWT Token. Format: Bearer {token}"))
                        .addSecuritySchemes("deviceAuth",
                            new io.swagger.v3.oas.models.security.SecurityScheme()
                                .type(io.swagger.v3.oas.models.security.SecurityScheme.Type.APIKEY)
                                .in(io.swagger.v3.oas.models.security.SecurityScheme.In.HEADER)
                                .name("X-Device-Authorization")
                                .description("Device JWT Token. Format: Bearer {token}")))
                .addSecurityItem(new SecurityRequirement().addList("clientAuth"))
                .addSecurityItem(new SecurityRequirement().addList("deviceAuth"));
    }
}package com.connection.gateway.config.spring;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ApplicationConfig {
    @Value("${spring.application.name:gateway-service}")
    private String appNameString;

    @Bean
    @Qualifier("appName")
    String appName(){
        return appNameString;
    }
}
package com.connection.gateway.config;

import java.util.UUID;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.jta.JtaTransactionManager;

import com.atomikos.icatch.jta.UserTransactionManager;

import jakarta.transaction.SystemException;

@Configuration
public class TransactionConfig {
    
    @Bean
    public UserTransactionManager userTransactionManager() throws SystemException {
        setPropertyIfNotExists("com.atomikos.icatch.log_base_name", "atomikos-tm-" + UUID.randomUUID().toString().substring(0, 8));
        setPropertyIfNotExists("com.atomikos.icatch.log_base_dir", "./logs");
        setPropertyIfNotExists("com.atomikos.icatch.tm_unique_name", "tm-" + UUID.randomUUID().toString().substring(0, 8));
        
        UserTransactionManager manager = new UserTransactionManager();
        manager.setTransactionTimeout(300);
        manager.setForceShutdown(true);
        return manager;
    }

    @Bean(name = "atomicosTransactionManager")
    public JtaTransactionManager jtaTransactionManager() throws SystemException {
        JtaTransactionManager jtaTransactionManager = new JtaTransactionManager();
        jtaTransactionManager.setTransactionManager(userTransactionManager());
        jtaTransactionManager.setUserTransaction(userTransactionManager());
        return jtaTransactionManager;
    }
    
    /**
     * Устанавливает системное свойство только если оно еще не было установлено
     * @param key ключ свойства
     * @param value значение свойства
     */
    private void setPropertyIfNotExists(String key, String value) {
        if (System.getProperty(key) == null) {
            System.setProperty(key, value);
            System.out.println("Set property: " + key + " = " + value);
        } else {
            System.out.println("Property already set: " + key + " = " + System.getProperty(key));
        }
    }
}package com.connection.gateway.config.security;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import com.connection.device.token.model.DeviceAccessTokenBLM;
import com.connection.device.token.model.DeviceTokenBLM;
import com.connection.service.auth.AuthService;
import com.connection.token.model.AccessTokenBLM;
import com.service.device.auth.DeviceAuthService;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Collections;

@Slf4j
@Component("gatewayAuthenticationFilter")
@RequiredArgsConstructor
public class AuthenticationFilter extends OncePerRequestFilter {

    private final AuthService authClient;
    private final DeviceAuthService deviceAuthClient;

    private static final String CLIENT_AUTH_HEADER = "Authorization";
    private static final String DEVICE_AUTH_HEADER = "X-Device-Authorization"; // Новый заголовок для device
    private static final String BEARER_PREFIX = "Bearer ";

    @Override
    protected void doFilterInternal(HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain) throws ServletException, IOException {
            log.info("=== FILTER STARTED ===");
        log.info("Request URI: {}", request.getRequestURI());
        log.info("Client Auth Header: {}", request.getHeader(CLIENT_AUTH_HEADER));
        log.info("Device Auth Header: {}", request.getHeader(DEVICE_AUTH_HEADER));


        String clientAuthHeader = request.getHeader(CLIENT_AUTH_HEADER);
        String deviceAuthHeader = request.getHeader(DEVICE_AUTH_HEADER);

        boolean clientAuthenticated = false;
        boolean deviceAuthenticated = false;

        // Сначала пробуем аутентифицировать клиента
        if (clientAuthHeader != null && clientAuthHeader.startsWith(BEARER_PREFIX)) {
            String jwtToken = clientAuthHeader.substring(BEARER_PREFIX.length());
            clientAuthenticated = authenticateClientWithToken(jwtToken, request);
        }

        // Если клиент не аутентифицирован, пробуем device
        if (!clientAuthenticated && deviceAuthHeader != null && deviceAuthHeader.startsWith(BEARER_PREFIX)) {
            String jwtToken = deviceAuthHeader.substring(BEARER_PREFIX.length());
            deviceAuthenticated = authenticateDeviceWithToken(jwtToken, request);
        }

        // Если ни один токен не прошел аутентификацию, но были предоставлены - возвращаем ошибку
        if ((clientAuthHeader != null && clientAuthHeader.startsWith(BEARER_PREFIX) && !clientAuthenticated) ||
            (deviceAuthHeader != null && deviceAuthHeader.startsWith(BEARER_PREFIX) && !deviceAuthenticated)) {
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            return;
        }

        filterChain.doFilter(request, response);
    }

    private boolean authenticateClientWithToken(String token, HttpServletRequest request) {
        try {
            String cleanToken = token.trim();
            log.info("Validating client token: {}...", cleanToken.substring(0, Math.min(cleanToken.length(), 20)));

            AccessTokenBLM accessTokenBLM = authClient.validateAccessToken(cleanToken);

            UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                    accessTokenBLM.getClientUID(),
                    null,
                    Collections.singletonList(new SimpleGrantedAuthority("ROLE_CLIENT")));

            authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
            SecurityContextHolder.getContext().setAuthentication(authentication);

            log.info("Successfully authenticated client: {}", accessTokenBLM.getClientUID());
            return true;
        } catch (Exception e) {
            log.warn("Client authentication failed: {}", e.getMessage());
            return false;
        }
    }

    private boolean authenticateDeviceWithToken(String token, HttpServletRequest request) {
        try {
            String cleanToken = token.trim();
            log.info("Validating device token: {}...", cleanToken.substring(0, Math.min(cleanToken.length(), 20)));

            DeviceAccessTokenBLM deviceAccessTokenBLM = deviceAuthClient.validateDeviceAccessToken(cleanToken);
            DeviceTokenBLM deviceTokenBLM = deviceAuthClient.getDeviceToken(deviceAccessTokenBLM.getDeviceTokenUid());

            UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                    deviceTokenBLM.getDeviceUid(),
                    null,
                    Collections.singletonList(new SimpleGrantedAuthority("ROLE_DEVICE")));

            authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
            SecurityContextHolder.getContext().setAuthentication(authentication);

            log.info("Successfully authenticated device: {}", deviceTokenBLM.getDeviceUid());
            return true;
        } catch (Exception e) {
            log.warn("Device authentication failed: {}", e.getMessage());
            return false;
        }
    }
}package com.connection.gateway.config.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;


import lombok.RequiredArgsConstructor;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
@RequiredArgsConstructor
public class SecurityConfig {

    private final AuthenticationFilter clientAuthenticationFilter;
    // Убираем deviceAuthenticationFilter, т.к. он теперь объединен

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                .csrf(csrf -> csrf.disable())
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/swagger-ui.html").permitAll()
                        .requestMatchers("/swagger-ui/**").permitAll()
                        .requestMatchers("/api-docs/**").permitAll()
                        .requestMatchers("/webjars/**").permitAll()
                        .requestMatchers("/v3/api-docs/**").permitAll()

                        .requestMatchers("/api/v1/auth/**").permitAll()

                        .requestMatchers("/api/v1/device/auth/device-token").hasAuthority("ROLE_CLIENT")
                        .requestMatchers("/api/v1/device/auth/device-token/**").hasAuthority("ROLE_CLIENT")
                        .requestMatchers("/api/v1/device/auth/**").permitAll()

                        .requestMatchers("/api/v1/message/health").permitAll()
                        .requestMatchers("/api/v1/message/messages").hasAnyAuthority("ROLE_CLIENT", "ROLE_DEVICE")
                        .requestMatchers("/api/v1/message/messages/**").hasAnyAuthority("ROLE_CLIENT", "ROLE_DEVICE")
                        
                        .requestMatchers("/api/v1/scheme/health").permitAll()
                        .requestMatchers("/api/v1/scheme/**").hasAuthority("ROLE_CLIENT")
                        
                        .requestMatchers("/api/v1/device/health").permitAll()
                        .requestMatchers("/api/v1/device/**").authenticated()//hasAuthority("ROLE_CLIENT")

                        .requestMatchers("/api/v1/buffer/health").permitAll()
                        .requestMatchers("/api/v1/buffer/**").hasAuthority("ROLE_CLIENT")
                        
                        .anyRequest().denyAll()
                )
                // Оставляем только один фильтр
                .addFilterBefore(clientAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)
                .build();
    }
}// GatewayServiceApplication.java
package com.connection.gateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.FilterType;


@SpringBootApplication
@ComponentScan(
    basePackages = {
        "com.connection.gateway",
        "com.connection.service.auth",
        "com.service.device.auth", 
        "com.connection.device",
        "com.connection.message",
        "com.service.buffer",
        "com.service.connectionscheme"
    },
    excludeFilters = {
        @ComponentScan.Filter(
            type = FilterType.ASSIGNABLE_TYPE,
            classes = {                
                com.connection.service.auth.AuthServiceApplication.class,
                com.connection.device.DeviceServiceApplication.class,
                com.service.buffer.BufferServiceApplication.class,
                com.service.connectionscheme.ConnectionSchemeServiceApplication.class,
                com.service.device.auth.DeviceAuthServiceApplication.class,
                com.connection.message.MessageServiceApplication.class,
            }
        ),
        @ComponentScan.Filter(
            type = FilterType.REGEX,
            pattern = {
                "com.connection.service.auth.config.kafka.*",
                "com.connection.device.config.kafka.*",
                "com.service.buffer.config.kafka.*",
                "com.service.connectionscheme.config.kafka.*",
                "com.service.device.auth.config.kafka.*",
                "com.connection.message.config.kafka.*",
            }
        ),
        @ComponentScan.Filter(
            type = FilterType.REGEX,
            pattern = {
                "com.connection.service.auth.config.security.*",
                "com.connection.device.config.security.*",
                "com.service.buffer.config.security.*",
                "com.service.connectionscheme.config.security.*",
                "com.service.device.auth.config.security.*",
                "com.connection.message.config.security.*",
            }
        ),
        @ComponentScan.Filter(
            type = FilterType.REGEX,
            pattern = {
                "com.connection.service.auth.config.spring.*",
                "com.connection.device.config.spring.*",
                "com.service.buffer.config.spring.*",
                "com.service.connectionscheme.config.spring.*",
                "com.service.device.auth.config.spring.*",
                "com.connection.message.config.spring.*",
            }
        ),
        @ComponentScan.Filter(
            type = FilterType.REGEX,
            pattern = {
                "com.connection.service.auth.config.swagger.*",
                "com.connection.device.config.swagger.*",
                "com.service.buffer.config.swagger.*",
                "com.service.connectionscheme.config.swagger.*",
                "com.service.device.auth.config.swagger.*",
                "com.connection.message.config.swagger.*",
            }
        ),
        @ComponentScan.Filter(
            type = FilterType.REGEX,
            pattern = {
                "com.connection.service.auth.config.transaction.*",
                "com.connection.device.config.transaction.*",
                "com.service.buffer.config.transaction.*",
                "com.service.connectionscheme.config.transaction.*",
                "com.service.device.auth.config.transaction.*",
                "com.connection.message.config.transaction.*",
            }
        ),
                @ComponentScan.Filter(
            type = FilterType.REGEX,
            pattern = {
                "com.connection.service.auth.*Filter.*",
                "com.connection.device.*Filter.*",
                "com.service.buffer.*Filter.*",
                "com.service.connectionscheme.*Filter.*",
                "com.service.device.auth.*Filter.*",
                "com.connection.message.*Filter.*",
            }
        ),
        
    }
)
public class GatewayServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(GatewayServiceApplication.class, args);
    }
}