// SwaggerConfig.java
package com.connection.gateway.config.swagger;

import io.swagger.v3.oas.annotations.enums.SecuritySchemeType;
import io.swagger.v3.oas.annotations.security.SecurityScheme;
import io.swagger.v3.oas.annotations.security.SecuritySchemes;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@SecuritySchemes({
    @SecurityScheme(
        name = "clientAuth",
        type = SecuritySchemeType.HTTP,
        bearerFormat = "JWT",
        scheme = "bearer"

    ),
    @SecurityScheme(
        name = "deviceAuth", 
        type = SecuritySchemeType.HTTP,
        bearerFormat = "JWT",
        scheme = "bearer"
    )
})
public class SwaggerConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("Connection Project API")
                        .version("1.0")
                        .description("API with dual authentication support: Client and Device tokens"))
                .components(new Components()
                        .addSecuritySchemes("clientAuth", 
                            new io.swagger.v3.oas.models.security.SecurityScheme()
                                .type(io.swagger.v3.oas.models.security.SecurityScheme.Type.APIKEY)
                                .in(io.swagger.v3.oas.models.security.SecurityScheme.In.HEADER)
                                .name("Authorization")
                                .description("Client JWT Token. Format: Bearer {token}"))
                        .addSecuritySchemes("deviceAuth",
                            new io.swagger.v3.oas.models.security.SecurityScheme()
                                .type(io.swagger.v3.oas.models.security.SecurityScheme.Type.APIKEY)
                                .in(io.swagger.v3.oas.models.security.SecurityScheme.In.HEADER)
                                .name("X-Device-Authorization")
                                .description("Device JWT Token. Format: Bearer {token}")))
                .addSecurityItem(new SecurityRequirement().addList("clientAuth"))
                .addSecurityItem(new SecurityRequirement().addList("deviceAuth"));
    }
}// package com.connection.gateway.config.spring;

// import java.sql.Connection;
// import java.sql.SQLException;
// import java.sql.Statement;
// import java.util.Map;
// import java.util.concurrent.ConcurrentHashMap;
// import java.util.concurrent.Executors;
// import java.util.concurrent.ScheduledExecutorService;
// import java.util.concurrent.TimeUnit;

// import javax.sql.DataSource;

// import org.springframework.beans.factory.annotation.Qualifier;
// import org.springframework.stereotype.Component;

// import lombok.extern.slf4j.Slf4j;

// @Slf4j
// @Component
// public class DatabaseHealthMonitor {

//     private final Map<String, DataSource> dataSources;
//     private final Map<String, Integer> failureCounts = new ConcurrentHashMap<>();
//     private final Map<String, Boolean> connectionStatus = new ConcurrentHashMap<>();
//     private final int MAX_FAILURES = 10;
//     private final long CHECK_INTERVAL = 1; // 30 секунд

//     public DatabaseHealthMonitor(@Qualifier("ClientDataSource") DataSource clientDataSource,
//             @Qualifier("RefreshTokenDataSource") DataSource refreshTokenDataSource,
//             @Qualifier("BufferDataSource") DataSource bufferDataSource,
//             @Qualifier("ConnectionSchemeDataSource") DataSource connectionSchemeDataSource,
//             @Qualifier("deviceTokenDataSource") DataSource deviceTokenDataSource,
//             @Qualifier("deviceAccessTokenDataSource") DataSource deviceAccessTokenDataSource,
//             @Qualifier("DeviceDataSource") DataSource deviceDataSource,
//             @Qualifier("MessageDataSource") DataSource messageDataSource) {
//         this.dataSources = Map.of(
//                 "RefreshTokenDataSource", refreshTokenDataSource,
//                 "BufferDataSource", bufferDataSource,
//                 "ConnectionSchemeDataSource", connectionSchemeDataSource,
//                 "deviceTokenDataSource", deviceTokenDataSource,
//                 "deviceAccessTokenDataSource", deviceAccessTokenDataSource,
//                 "DeviceDataSource", deviceDataSource,
//                 "MessageDataSource", messageDataSource);

//         initializeMonitoring();
//     }

//     private void checkAllConnections() {
//         for (Map.Entry<String, DataSource> entry : dataSources.entrySet()) {
//             String dataSourceName = entry.getKey();
//             DataSource dataSource = entry.getValue();

//             boolean isAvailable = testConnection(dataSource);

//             if (isAvailable) {
//                 // Сброс счетчика при успешном соединении
//                 failureCounts.put(dataSourceName, 0);
//                 connectionStatus.put(dataSourceName, true);
//                 log.info("Connection {} is available", dataSourceName);
//             } else {
//                 // Увеличение счетчика при неудаче
//                 int failures = failureCounts.getOrDefault(dataSourceName, 0) + 1;
//                 failureCounts.put(dataSourceName, failures);
//                 connectionStatus.put(dataSourceName, false);

//                 log.warn("Connection {} failed {}/{} times", dataSourceName, failures, MAX_FAILURES);

//                 // Остановка приложения при достижении лимита
//                 if (failures >= MAX_FAILURES) {
//                     handleCriticalFailure(dataSourceName);
//                 }
//             }
//         }
//     }

//     private void handleCriticalFailure(String dataSourceName) {
//         log.error("CRITICAL: DataSource {} has failed {} times consecutively. Shutting down application.",
//                 dataSourceName, MAX_FAILURES);
//         logCurrentStatus();
//         System.exit(1);
//     }

//     private void logCurrentStatus() {
//         log.info("=== Current Database Connection Status ===");
//         connectionStatus.forEach((name, status) -> log.info("{}: {} (failures: {})",
//                 name,
//                 status ? "AVAILABLE" : "UNAVAILABLE",
//                 failureCounts.getOrDefault(name, 0)));
//         log.info("==========================================");
//     }

//     private boolean testConnection(DataSource dataSource) {
//         try (Connection connection = dataSource.getConnection();
//                 Statement statement = connection.createStatement()) {

//             // Простой запрос для проверки соединения
//             statement.executeQuery("SELECT 1");
//             return true;

//         } catch (SQLException e) {
//             log.error("Database connection test failed: {}", e.getMessage());
//             return false;
//         }
//     }

//     private void initializeMonitoring() {
//         ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);
//         scheduler.scheduleAtFixedRate(this::checkAllConnections, 0, CHECK_INTERVAL, TimeUnit.MILLISECONDS);
//     }
// }package com.connection.gateway.config.spring;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ApplicationConfig {
    @Value("${spring.application.name:gateway-service}")
    private String appNameString;

    @Bean
    @Qualifier("appName")
    String appName(){
        return appNameString;
    }
}
package com.connection.gateway.config.transaction;

import java.util.UUID;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.jta.JtaTransactionManager;

import com.atomikos.icatch.jta.UserTransactionManager;

import jakarta.transaction.SystemException;

@Configuration
@ConditionalOnProperty(name = "app.transaction.mode", havingValue = "atomikos")
public class TransactionConfig {
    
    private static volatile boolean databaseChecked = false;
    private static final Object CHECK_LOCK = new Object();
    
    @Value("${transaction.database.host:localhost}")
    private String dbHost;
    @Value("${transaction.database.port:5432}")
    private int dbPort;

    @Bean
    public UserTransactionManager userTransactionManager() throws SystemException {
        setPropertyIfNotExists("com.atomikos.icatch.log_base_name", "atomikos-tm-" + UUID.randomUUID().toString().substring(0, 8));
        setPropertyIfNotExists("com.atomikos.icatch.log_base_dir", "./logs");
        setPropertyIfNotExists("com.atomikos.icatch.tm_unique_name", "tm-" + UUID.randomUUID().toString().substring(0, 8));
        
        // Настройки для минимальных попыток переподключения
        setPropertyIfNotExists("com.atomikos.icatch.oltp_max_retries", "10");
        setPropertyIfNotExists("com.atomikos.icatch.oltp_retry_interval", "1000");
        setPropertyIfNotExists("com.atomikos.icatch.default_jta_timeout", "5000");
        
        // Выполняем проверку БД только один раз при создании первого бина
        performOneTimeDatabaseCheck();
        
        UserTransactionManager manager = new UserTransactionManager();
        manager.setTransactionTimeout(30);
        manager.setForceShutdown(true);
        return manager;
    }

    @Bean(name = "atomicosTransactionManager")
    public JtaTransactionManager jtaTransactionManager() throws SystemException {
        // Проверка уже выполнена в userTransactionManager(), поэтому не повторяем
        
        JtaTransactionManager jtaTransactionManager = new JtaTransactionManager();
        jtaTransactionManager.setTransactionManager(userTransactionManager());
        jtaTransactionManager.setUserTransaction(userTransactionManager());
        jtaTransactionManager.setDefaultTimeout(5000);
        return jtaTransactionManager;
    }
    
    /**
     * Однократная проверка доступности БД
     */
    private void performOneTimeDatabaseCheck() {
        synchronized (CHECK_LOCK) {
            if (databaseChecked) {
                System.out.println("✓ Database check already performed - skipping");
                return;
            }
            
            System.out.println("=== PERFORMING ONE-TIME DATABASE AVAILABILITY CHECK ===");
            
            // Простая проверка доступности порта БД
            int timeout = 3000; // 3 секунды
            
            boolean isReachable = isPortReachable(dbHost, dbPort, timeout);
            
            if (!isReachable) {
                System.err.println("✗ CRITICAL: Database is not reachable at " + dbHost + ":" + dbPort);
                System.err.println("=== APPLICATION WILL NOW EXIT ===");
                System.exit(1);
            } else {
                System.out.println("✓ Database port is reachable at " + dbHost + ":" + dbPort);
            }
            
            databaseChecked = true;
            System.out.println("=== ONE-TIME DATABASE CHECK COMPLETED ===");
        }
    }
    
    /**
     * Проверяет доступность порта БД
     */
    private boolean isPortReachable(String host, int port, int timeout) {
        try (java.net.Socket socket = new java.net.Socket()) {
            socket.connect(new java.net.InetSocketAddress(host, port), timeout);
            return true;
        } catch (Exception e) {
            System.err.println("Database connection failed: " + e.getMessage());
            return false;
        }
    }
    
    /**
     * Устанавливает системное свойство только если оно еще не было установлено
     */
    private void setPropertyIfNotExists(String key, String value) {
        if (System.getProperty(key) == null) {
            System.setProperty(key, value);
            System.out.println("Set property: " + key + " = " + value);
        }
    }
}package com.connection.gateway.config.security;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import com.connection.device.token.model.DeviceAccessTokenBLM;
import com.connection.device.token.model.DeviceTokenBLM;
import com.connection.service.auth.AuthService;
import com.connection.token.model.AccessTokenBLM;
import com.service.device.auth.DeviceAuthService;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Collections;

@Slf4j
@Component("gatewayAuthenticationFilter")
@RequiredArgsConstructor
public class AuthenticationFilter extends OncePerRequestFilter {

    private final AuthService authClient;
    private final DeviceAuthService deviceAuthClient;

    private static final String CLIENT_AUTH_HEADER = "Authorization";
    private static final String DEVICE_AUTH_HEADER = "X-Device-Authorization"; // Новый заголовок для device
    private static final String BEARER_PREFIX = "Bearer ";

    @Override
    protected void doFilterInternal(HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain) throws ServletException, IOException {
            log.info("=== FILTER STARTED ===");
        log.info("Request URI: {}", request.getRequestURI());
        log.info("Client Auth Header: {}", request.getHeader(CLIENT_AUTH_HEADER));
        log.info("Device Auth Header: {}", request.getHeader(DEVICE_AUTH_HEADER));


        String clientAuthHeader = request.getHeader(CLIENT_AUTH_HEADER);
        String deviceAuthHeader = request.getHeader(DEVICE_AUTH_HEADER);

        boolean clientAuthenticated = false;
        boolean deviceAuthenticated = false;

        // Сначала пробуем аутентифицировать клиента
        if (clientAuthHeader != null && clientAuthHeader.startsWith(BEARER_PREFIX)) {
            String jwtToken = clientAuthHeader.substring(BEARER_PREFIX.length());
            clientAuthenticated = authenticateClientWithToken(jwtToken, request);
        }

        // Если клиент не аутентифицирован, пробуем device
        if (!clientAuthenticated && deviceAuthHeader != null && deviceAuthHeader.startsWith(BEARER_PREFIX)) {
            String jwtToken = deviceAuthHeader.substring(BEARER_PREFIX.length());
            deviceAuthenticated = authenticateDeviceWithToken(jwtToken, request);
        }

        // Если ни один токен не прошел аутентификацию, но были предоставлены - возвращаем ошибку
        if ((clientAuthHeader != null && clientAuthHeader.startsWith(BEARER_PREFIX) && !clientAuthenticated) ||
            (deviceAuthHeader != null && deviceAuthHeader.startsWith(BEARER_PREFIX) && !deviceAuthenticated)) {
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            return;
        }

        filterChain.doFilter(request, response);
    }

    private boolean authenticateClientWithToken(String token, HttpServletRequest request) {
        try {
            String cleanToken = token.trim();
            log.info("Validating client token: {}...", cleanToken.substring(0, Math.min(cleanToken.length(), 20)));

            AccessTokenBLM accessTokenBLM = authClient.validateAccessToken(cleanToken);

            UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                    accessTokenBLM.getClientUID(),
                    null,
                    Collections.singletonList(new SimpleGrantedAuthority("ROLE_CLIENT")));

            authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
            SecurityContextHolder.getContext().setAuthentication(authentication);

            log.info("Successfully authenticated client: {}", accessTokenBLM.getClientUID());
            return true;
        } catch (Exception e) {
            log.warn("Client authentication failed: {}", e.getMessage());
            return false;
        }
    }

    private boolean authenticateDeviceWithToken(String token, HttpServletRequest request) {
        try {
            String cleanToken = token.trim();
            log.info("Validating device token: {}...", cleanToken.substring(0, Math.min(cleanToken.length(), 20)));

            DeviceAccessTokenBLM deviceAccessTokenBLM = deviceAuthClient.validateDeviceAccessToken(cleanToken);
            DeviceTokenBLM deviceTokenBLM = deviceAuthClient.getDeviceToken(deviceAccessTokenBLM.getDeviceTokenUid());

            UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                    deviceTokenBLM.getDeviceUid(),
                    null,
                    Collections.singletonList(new SimpleGrantedAuthority("ROLE_DEVICE")));

            authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
            SecurityContextHolder.getContext().setAuthentication(authentication);

            log.info("Successfully authenticated device: {}", deviceTokenBLM.getDeviceUid());
            return true;
        } catch (Exception e) {
            log.warn("Device authentication failed: {}", e.getMessage());
            return false;
        }
    }
}package com.connection.gateway.config.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;


import lombok.RequiredArgsConstructor;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
@RequiredArgsConstructor
public class SecurityConfig {

    private final AuthenticationFilter clientAuthenticationFilter;
    // Убираем deviceAuthenticationFilter, т.к. он теперь объединен

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                .csrf(csrf -> csrf.disable())
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/swagger-ui.html").permitAll()
                        .requestMatchers("/swagger-ui/**").permitAll()
                        .requestMatchers("/api-docs/**").permitAll()
                        .requestMatchers("/webjars/**").permitAll()
                        .requestMatchers("/v3/api-docs/**").permitAll()

                        .requestMatchers("/api/v1/auth/**").permitAll()

                        .requestMatchers("/api/v1/device/auth/device-token").hasAuthority("ROLE_CLIENT")
                        .requestMatchers("/api/v1/device/auth/device-token/**").hasAuthority("ROLE_CLIENT")
                        .requestMatchers("/api/v1/device/auth/**").permitAll()

                        .requestMatchers("/api/v1/message/health").permitAll()
                        .requestMatchers("/api/v1/message/messages").hasAnyAuthority("ROLE_CLIENT", "ROLE_DEVICE")
                        .requestMatchers("/api/v1/message/messages/**").hasAnyAuthority("ROLE_CLIENT", "ROLE_DEVICE")
                        
                        .requestMatchers("/api/v1/scheme/health").permitAll()
                        .requestMatchers("/api/v1/scheme/**").hasAuthority("ROLE_CLIENT")
                        
                        .requestMatchers("/api/v1/device/health").permitAll()
                        .requestMatchers("/api/v1/device/**").authenticated()//hasAuthority("ROLE_CLIENT")

                        .requestMatchers("/api/v1/buffer/health").permitAll()
                        .requestMatchers("/api/v1/buffer/**").hasAuthority("ROLE_CLIENT")
                        
                        .anyRequest().denyAll()
                )
                // Оставляем только один фильтр
                .addFilterBefore(clientAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)
                .build();
    }
}// GatewayServiceApplication.java
package com.connection.gateway;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.FilterType;


@SpringBootApplication
@ComponentScan(
    basePackages = {
        "com.connection.gateway",
        "com.connection.service.auth",
        "com.service.device.auth", 
        "com.connection.device",
        "com.connection.message",
        "com.service.buffer",
        "com.service.connectionscheme"
    },
    excludeFilters = {
        @ComponentScan.Filter(
            type = FilterType.ASSIGNABLE_TYPE,
            classes = {                
                com.connection.service.auth.AuthServiceApplication.class,
                com.connection.device.DeviceServiceApplication.class,
                com.service.buffer.BufferServiceApplication.class,
                com.service.connectionscheme.ConnectionSchemeServiceApplication.class,
                com.service.device.auth.DeviceAuthServiceApplication.class,
                com.connection.message.MessageServiceApplication.class,
            }
        ),
        @ComponentScan.Filter(
            type = FilterType.REGEX,
            pattern = {
                "com.connection.service.auth.config.kafka.*",
                "com.connection.device.config.kafka.*",
                "com.service.buffer.config.kafka.*",
                "com.service.connectionscheme.config.kafka.*",
                "com.service.device.auth.config.kafka.*",
                "com.connection.message.config.kafka.*",
            }
        ),
        @ComponentScan.Filter(
            type = FilterType.REGEX,
            pattern = {
                "com.connection.service.auth.config.security.*",
                "com.connection.device.config.security.*",
                "com.service.buffer.config.security.*",
                "com.service.connectionscheme.config.security.*",
                "com.service.device.auth.config.security.*",
                "com.connection.message.config.security.*",
            }
        ),
        @ComponentScan.Filter(
            type = FilterType.REGEX,
            pattern = {
                "com.connection.service.auth.config.spring.*",
                "com.connection.device.config.spring.*",
                "com.service.buffer.config.spring.*",
                "com.service.connectionscheme.config.spring.*",
                "com.service.device.auth.config.spring.*",
                "com.connection.message.config.spring.*",
            }
        ),
        @ComponentScan.Filter(
            type = FilterType.REGEX,
            pattern = {
                "com.connection.service.auth.config.swagger.*",
                "com.connection.device.config.swagger.*",
                "com.service.buffer.config.swagger.*",
                "com.service.connectionscheme.config.swagger.*",
                "com.service.device.auth.config.swagger.*",
                "com.connection.message.config.swagger.*",
            }
        ),
        @ComponentScan.Filter(
            type = FilterType.REGEX,
            pattern = {
                "com.connection.service.auth.config.transaction.*",
                "com.connection.device.config.transaction.*",
                "com.service.buffer.config.transaction.*",
                "com.service.connectionscheme.config.transaction.*",
                "com.service.device.auth.config.transaction.*",
                "com.connection.message.config.transaction.*",
            }
        ),
                @ComponentScan.Filter(
            type = FilterType.REGEX,
            pattern = {
                "com.connection.service.auth.*Filter.*",
                "com.connection.device.*Filter.*",
                "com.service.buffer.*Filter.*",
                "com.service.connectionscheme.*Filter.*",
                "com.service.device.auth.*Filter.*",
                "com.connection.message.*Filter.*",
            }
        ),
        
    }
)
public class GatewayServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(GatewayServiceApplication.class, args);
    }
}