
package com.service.connectionscheme.controller;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.connection.scheme.converter.ConnectionSchemeConverter;
import com.connection.scheme.model.ConnectionSchemeBLM;
import com.connection.scheme.model.ConnectionSchemeDTO;
import com.connection.scheme.validator.ConnectionSchemeValidator;
import com.service.connectionscheme.ConnectionSchemeService;
import com.service.connectionscheme.config.SecurityUtils;


import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/v1/scheme")
public class ConnectionSchemeController {
    @Qualifier("ApiConnectionSchemeService")
    private final ConnectionSchemeService connectionSchemeService;
    private final ConnectionSchemeValidator schemeValidator;
    private final ConnectionSchemeConverter schemeConverter;

    // Константы для пагинации по умолчанию
    private static final int DEFAULT_OFFSET = 0;
    private static final int DEFAULT_LIMIT = 50;
    private static final int MAX_LIMIT = 1000;

    @PostMapping("/schemes")
    public ResponseEntity<ConnectionSchemeResponse> createScheme(@RequestBody ConnectionSchemeDTO schemeDTO) {
        schemeValidator.validate(schemeDTO);
        ConnectionSchemeBLM scheme = connectionSchemeService.createScheme(schemeConverter.toBLM(schemeDTO));

        return ResponseEntity.ok(new ConnectionSchemeResponse(scheme.getUid()));
    }


    @GetMapping("/schemes")
    public ResponseEntity<ConnectionSchemesListResponse> getSchemes(
            @RequestParam(required = false) List<UUID> schemeUids,
            @RequestParam(defaultValue = "" + DEFAULT_OFFSET) int offset,
            @RequestParam(defaultValue = "" + DEFAULT_LIMIT) int limit) {
        
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        List<ConnectionSchemeBLM> schemes = null;

        if (schemeUids != null && !schemeUids.isEmpty()) {
            log.info("Getting specific connection schemes: {} with offset: {}, limit: {}", schemeUids, offset, limit);
            schemes = connectionSchemeService.getSchemeByUid(schemeUids);
        } else {
            // Получение всех схем клиента
            log.info("Getting all connection schemes for client with offset: {}, limit: {}", offset, limit);
            schemes = connectionSchemeService.getSchemesByClient(clientUid);
        }
        
        // Применяем пагинацию
        List<ConnectionSchemeBLM> paginatedSchemes = applyPagination(schemes, offset, limit);
        List<ConnectionSchemeDTO> schemeDTOs = paginatedSchemes.stream()
                .map(schemeConverter::toDTO)
                .collect(Collectors.toList());

        // Создаем информацию о пагинации
        ConnectionSchemesListResponse.PaginationInfo paginationInfo = 
            new ConnectionSchemesListResponse.PaginationInfo(
                offset, 
                limit, 
                schemes.size(), 
                (offset + limit) < schemes.size()
            );

        return ResponseEntity.ok(new ConnectionSchemesListResponse(schemeDTOs, paginationInfo));
    }

    @PutMapping("/schemes/{schemeUid}")
    public ResponseEntity<ConnectionSchemeResponse> updateScheme(
            @PathVariable UUID schemeUid,
            @RequestBody ConnectionSchemeDTO schemeDTO) {
        
        schemeValidator.validate(schemeDTO);
        ConnectionSchemeBLM scheme = connectionSchemeService.updateScheme(schemeUid, schemeConverter.toBLM(schemeDTO));

        return ResponseEntity.ok(new ConnectionSchemeResponse(scheme.getUid()));
    }

    @DeleteMapping("/schemes")
    public ResponseEntity<Void> deleteSchemes(
            @RequestParam(required = false) List<UUID> schemeUids) {
        
        if (schemeUids != null && !schemeUids.isEmpty()) {
            log.info("Deleting multiple connection schemes: {}", schemeUids);
            for (UUID uid : schemeUids) {
                connectionSchemeService.deleteScheme(uid);
            }
        } else {
            log.warn("No valid delete parameters provided");
            return ResponseEntity.badRequest().build();
        }

        return ResponseEntity.noContent().build();
    }

    @GetMapping("/health")
    public ResponseEntity<HealthResponse> healthCheck() {
        log.info("Health check: status: OK, service: connection-scheme-service, timestamp: {}", 
                System.currentTimeMillis());
                
        return ResponseEntity.ok().body(new HealthResponse(connectionSchemeService.getHealthStatus().toString()));
    }

    /**
     * Применяет пагинацию к списку схем подключения
     * 
     * @param schemes полный список схем подключения
     * @param offset смещение (начальная позиция)
     * @param limit максимальное количество элементов
     * @return пагинированный список схем подключения
     */
    private List<ConnectionSchemeBLM> applyPagination(List<ConnectionSchemeBLM> schemes, int offset, int limit) {
        // Валидация параметров пагинации
        if (offset < 0) {
            offset = DEFAULT_OFFSET;
        }
        
        if (limit <= 0 || limit > MAX_LIMIT) {
            limit = DEFAULT_LIMIT;
        }
        
        // Применяем пагинацию
        return schemes.stream()
                .skip(offset)
                .limit(limit)
                .collect(Collectors.toList());
    }
}package com.connection.service.auth.controller;

import org.springframework.data.util.Pair;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.connection.client.converter.ClientConverter;
import com.connection.client.model.ClientBLM;
import com.connection.client.model.ClientDTO;
import com.connection.client.validator.ClientValidator;
import com.connection.service.auth.AuthService;
import com.connection.token.converter.AccessTokenConverter;
import com.connection.token.converter.RefreshTokenConverter;
import com.connection.token.exception.BaseTokenException;
import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.AccessTokenDTO;
import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDTO;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/v1/auth")
@Tag(name = "Auth Service", description = "Authentication and Authorization APIs")
public class AuthServiceController {

    private final AccessTokenConverter accessTokenConverter;
    private final RefreshTokenConverter refreshTokenConverter;
    private final ClientConverter clientConverter;
    private final ClientValidator clientValidator;
    private final AuthService authService;

    @Operation(summary = "Register new client", description = "Register a new client in the system")
    @ApiResponse(responseCode = "200", description = "Client registered successfully", content = @Content(schema = @Schema(implementation = RegistrationResponse.class)))
    @PostMapping("/register")
    public ResponseEntity<RegistrationResponse> register(
            @Parameter(description = "Client data", required = true) @RequestBody ClientDTO clientDTO) {

        log.info("Registration attempt for email: {}", clientDTO.getEmail());

        clientValidator.validate(clientDTO);

        ClientBLM clientBLM = clientConverter.toBLM(clientDTO);
        authService.register(clientBLM);

        log.info("Client registered successfully: {}", clientDTO.getUid());
        return ResponseEntity.ok(new RegistrationResponse(
                "User registered successfully",
                clientDTO.getEmail()));
    }

    @Operation(summary = "Login by email", description = "Authenticate client using email and password")
    @ApiResponse(responseCode = "201", description = "Login successful", content = @Content(schema = @Schema(implementation = LoginResponse.class)))
    @PostMapping("/login")
    public ResponseEntity<LoginResponse> loginByEmail(
            @io.swagger.v3.oas.annotations.parameters.RequestBody(description = "Login credentials", required = true, content = @Content(schema = @Schema(implementation = LoginRequest.class))) @RequestBody LoginRequest loginRequest) {

        log.info("Login attempt by email: {}", loginRequest.getEmail());

        Pair<AccessTokenBLM, RefreshTokenBLM> tokens = authService.authorizeByEmail(
                loginRequest.getEmail(), loginRequest.getPassword());

        log.info("Login successful for email: {}", loginRequest.getEmail());

        return ResponseEntity.ok(new LoginResponse(
                tokens.getFirst().getToken(),
                tokens.getSecond().getToken(),
                tokens.getFirst().getExpiresAt(),
                tokens.getSecond().getExpiresAt(),
                tokens.getFirst().getClientUID()));
    }

    @Operation(summary = "Refresh tokens", description = "Get new access and refresh tokens using refresh token")
    @ApiResponse(responseCode = "201", description = "Tokens refreshed successfully", content = @Content(schema = @Schema(implementation = LoginResponse.class)))
    @PostMapping("/refresh")
    public ResponseEntity<LoginResponse> refreshToken(
            @Parameter(description = "Refresh token request", required = true) @RequestBody RefreshTokenRequest refreshRequest) {
        try {
            log.info("Token refresh attempt");
            log.info(refreshRequest.getRefreshToken());
            RefreshTokenDTO refreshTokenDTO = new RefreshTokenDTO(refreshRequest.getRefreshToken());
            RefreshTokenBLM refreshTokenBLM = refreshTokenConverter.toBLM(refreshTokenDTO);

            log.info(refreshTokenBLM.getToken());
            log.info(refreshTokenBLM.getClientUID().toString());

            Pair<AccessTokenBLM, RefreshTokenBLM> newTokens = authService.refresh(refreshTokenBLM);

            log.info("Token refresh successful");
            return ResponseEntity.ok(new LoginResponse(
                    newTokens.getFirst().getToken(),
                    newTokens.getSecond().getToken(),
                    newTokens.getFirst().getExpiresAt(),
                    newTokens.getSecond().getExpiresAt(),
                    newTokens.getFirst().getClientUID()));
        } catch (BaseTokenException e) {
            return ResponseEntity.badRequest().build();
        }
    }

    @Operation(summary = "Health check", description = "Check service health")
    @ApiResponse(responseCode = "200", description = "Service is healthy", content = @Content(schema = @Schema(implementation = HealthResponse.class)))
    @GetMapping("/health")
    public ResponseEntity<HealthResponse> healthCheck() {
        log.info("Health check: status: OK, service: auth-service, timestamp: {}",
                System.currentTimeMillis());

        return ResponseEntity.ok(new HealthResponse(
                "OK",
                "auth-service",
                System.currentTimeMillis()));
    }

    @Operation(summary = "Validate access token", description = "Check if access token is valid")
    @ApiResponse(responseCode = "200", description = "Token is valid", content = @Content(schema = @Schema(implementation = ValidationResponse.class)))
    @PostMapping("/validate/access")
    public ResponseEntity<ValidationResponse> validateAccessToken(
            @Parameter(description = "Access token to validate", required = true) @RequestParam String accessToken) {
        try {
            log.info("Validating access token");
            AccessTokenDTO accessTokenDTO = new AccessTokenDTO(accessToken);

            AccessTokenBLM accessTokenBLM = accessTokenConverter.toBLM(accessTokenDTO);
            authService.validateAccessToken(accessTokenBLM);

            return ResponseEntity.ok(new ValidationResponse("OK"));
        } catch (BaseTokenException e) {
            return ResponseEntity.badRequest().build();
        }

    }

    @Operation(summary = "Validate refresh token", description = "Check if refresh token is valid")
    @ApiResponse(responseCode = "200", description = "Token is valid", content = @Content(schema = @Schema(implementation = ValidationResponse.class)))
    @PostMapping("/validate/refresh")
    public ResponseEntity<ValidationResponse> validateRefreshToken(
            @Parameter(description = "Refresh token to validate", required = true) @RequestParam String refreshToken) {

        log.info("Validating refresh token");
        RefreshTokenDTO refreshTokenDTO = new RefreshTokenDTO(refreshToken);

        RefreshTokenBLM refreshTokenBLM = refreshTokenConverter.toBLM(refreshTokenDTO);
        authService.validateRefreshToken(refreshTokenBLM);

        return ResponseEntity.ok(new ValidationResponse("OK"));
    }
}package com.service.buffer.controller;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.connection.processing.buffer.converter.BufferConverter;
import com.connection.processing.buffer.model.BufferBLM;
import com.connection.processing.buffer.model.BufferDTO;
import com.connection.processing.buffer.validator.BufferValidator;
import com.service.buffer.BufferService;
import com.service.buffer.config.SecurityUtils;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/v1/buffer")
public class BufferController {

    @Qualifier("ApiBufferService")
    private final BufferService bufferService;
    private final BufferValidator bufferValidator;
    private final BufferConverter bufferConverter;

    // Константы для пагинации по умолчанию
    private static final int DEFAULT_OFFSET = 0;
    private static final int DEFAULT_LIMIT = 50;
    private static final int MAX_LIMIT = 1000;

    @PostMapping("/buffers")
    public ResponseEntity<BufferResponse> createBuffer(@RequestBody BufferDTO bufferDTO) {
        bufferValidator.validate(bufferDTO);
        BufferBLM bufferBLM = bufferConverter.toBLM(bufferDTO);
        BufferBLM buffer = bufferService.createBuffer(bufferBLM);

        return ResponseEntity.ok(new BufferResponse(buffer.getUid()));
    }

    @GetMapping("/buffers")
    public ResponseEntity<BuffersListResponse> getBuffers(
            @RequestParam(required = false) List<UUID> bufferUids,
            @RequestParam(required = false) UUID deviceUid,
            @RequestParam(required = false) UUID connectionSchemeUid,
            @RequestParam(defaultValue = "" + DEFAULT_OFFSET) int offset,
            @RequestParam(defaultValue = "" + DEFAULT_LIMIT) int limit) {
        
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        List<BufferBLM> buffers;

        if (deviceUid != null) {
            log.info("Getting buffers for device: {} with offset: {}, limit: {}", deviceUid, offset, limit);
            buffers = bufferService.getBuffersByDevice(deviceUid);
        } else if (connectionSchemeUid != null) {
            log.info("Getting buffers for connection scheme: {} with offset: {}, limit: {}", 
                    connectionSchemeUid, offset, limit);
            buffers = bufferService.getBuffersByConnectionScheme(connectionSchemeUid);
        } else {
            log.info("Getting all buffers for client with offset: {}, limit: {}", offset, limit);
            buffers = bufferService.getBuffersByClient(clientUid);
        }
        BuffersListResponse.PaginationInfo paginationInfo = 
            new BuffersListResponse.PaginationInfo(
                offset, 
                limit, 
                buffers.size(), 
                (offset + limit) < buffers.size()
            );
        // Применяем пагинацию
        List<BufferDTO> bufferDTOs = applyPagination(buffers, offset, limit)
                .stream()
                .map(bufferConverter::toDTO)
                .collect(Collectors.toList());

        return ResponseEntity.ok(new BuffersListResponse(bufferDTOs, paginationInfo));
    }
    @PatchMapping("/buffers/{bufferUid}")
    public ResponseEntity<BufferResponse> partialUpdateBuffer(
            @PathVariable UUID bufferUid,
            @RequestBody PartialBufferUpdateRequest updateRequest) {
        
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        log.info("Partial update buffer: {} for client: {}", bufferUid, clientUid);
        
        // Временная реализация - получаем текущий буфер и возвращаем его
        BufferBLM buffer = bufferService.getBufferByUid(bufferUid);
        buffer.setMaxMessageSize(updateRequest.maxSize);
        buffer.setMaxMessagesNumber(updateRequest.maxMessages);
        
        bufferValidator.validate(buffer);

        bufferService.updateBuffer(bufferUid, buffer);
        
        return ResponseEntity.ok(new BufferResponse(buffer.getUid()));
    }


    @PutMapping("/buffers/{bufferUid}")
    public ResponseEntity<BufferResponse> updateBuffer(
            @PathVariable UUID bufferUid,
            @RequestBody BufferDTO bufferDTO) {

        UUID clientUid = SecurityUtils.getCurrentClientUid();
        log.info("Updating buffer: {} for client: {}", bufferUid, clientUid);

        bufferValidator.validate(bufferDTO);

        BufferBLM bufferBLM = bufferConverter.toBLM(bufferDTO);

        BufferBLM buffer = bufferService.updateBuffer(bufferUid, bufferBLM);

        return ResponseEntity.ok(new BufferResponse(buffer.getUid()));
    }

    @DeleteMapping("/buffers")
    public ResponseEntity<Void> deleteBuffers(
            @RequestParam List<UUID> bufferUids) {
        
        for (UUID b : bufferUids){
            bufferService.deleteBuffer(b);
        }
        return ResponseEntity.noContent().build();
    }


    @GetMapping("/health")
    public ResponseEntity<HealthResponse> healthCheck() {
        log.info("Health check: status: OK, service: buffer-service, timestamp: {}",
                System.currentTimeMillis());

        return ResponseEntity.ok().body(new HealthResponse(bufferService.getHealthStatus().toString()));
    }

    /**
     * Применяет пагинацию к списку буферов
     * 
     * @param buffers полный список буферов
     * @param offset смещение (начальная позиция)
     * @param limit максимальное количество элементов
     * @return пагинированный список буферов
     */
    private List<BufferBLM> applyPagination(List<BufferBLM> buffers, int offset, int limit) {
        // Валидация параметров пагинации
        if (offset < 0) {
            offset = DEFAULT_OFFSET;
        }
        
        if (limit <= 0 || limit > MAX_LIMIT) {
            limit = DEFAULT_LIMIT;
        }
        
        // Применяем пагинацию
        return buffers.stream()
                .skip(offset)
                .limit(limit)
                .collect(Collectors.toList());
    }
        public static class PartialBufferUpdateRequest {
        private Integer maxMessages;
        private Integer maxSize;

        // Getters and Setters
        public Integer getMaxMessages() {
            return maxMessages;
        }

        public void setMaxMessages(Integer maxMessages) {
            this.maxMessages = maxMessages;
        }

        public Integer getMaxSize() {
            return maxSize;
        }

        public void setMaxSize(Integer maxSize) {
            this.maxSize = maxSize;
        }

    }
}package com.connection.message.controller;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.UUID;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.connection.message.MessageService;
import com.connection.message.converter.MessageConverter;
import com.connection.message.model.MessageBLM;
import com.connection.message.model.MessageDTO;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/v1/message")
@Tag(name = "Message Service", description = "API для управления сообщениями устройств")
public class MessageController {

    // Константы для пагинации по умолчанию
    private static final int DEFAULT_OFFSET = 0;
    private static final int DEFAULT_LIMIT = 1;
    private static final int MAX_LIMIT = 1000;

    protected final MessageConverter messageConverter;
    protected final MessageService messageService;

    @Operation(security = {
            @SecurityRequirement(name = "clientAuth"),
            @SecurityRequirement(name = "deviceAuth")
    })
    @PostMapping("/messages")
    public ResponseEntity<Void> addMessage(
            @Parameter(description = "DTO сообщения для добавления") @RequestBody MessageDTO messageDTO) {

        try {
            // Конвертируем DTO в BLM
            MessageBLM messageBLM = messageConverter.toBLM(messageDTO);

            // Вызываем сервис
            messageService.addMessage(messageBLM);

            return ResponseEntity.ok().build();

        } catch (Exception e) {
            log.error("Error adding message: {}", e);
            return ResponseEntity.badRequest().build();
        }
    }

    @Operation(security = {
            @SecurityRequirement(name = "clientAuth"),
            @SecurityRequirement(name = "deviceAuth")
    }, parameters = {
            @Parameter(name = "schemeUids", description = "Список UID схем соединения", in = ParameterIn.QUERY),
            @Parameter(name = "bufferUids", description = "Список UID буферов", in = ParameterIn.QUERY),
            @Parameter(name = "deviceUids", description = "Список UID устройств", in = ParameterIn.QUERY),
            @Parameter(name = "deleteOnGet", description = "Удалять сообщения после получения", in = ParameterIn.QUERY),
            @Parameter(name = "offset", description = "Смещение для пагинации", in = ParameterIn.QUERY),
            @Parameter(name = "limit", description = "Лимит для пагинации (макс. 1000)", in = ParameterIn.QUERY)
    })
    @GetMapping("/messages/")
    public ResponseEntity<MessageResponse> getMessage(
            @RequestParam(required = false) List<UUID> schemeUids,
            @RequestParam(required = false) List<UUID> bufferUids,
            @RequestParam(required = false) List<UUID> deviceUids,
            @RequestParam(defaultValue = "false") Boolean deleteOnGet,
            @RequestParam(defaultValue = "" + DEFAULT_OFFSET) int offset,
            @RequestParam(defaultValue = "" + DEFAULT_LIMIT) int limit) {

        Set<MessageBLM> messageBLMs = new HashSet<>();
        log.info("Getting messages");

        if (schemeUids != null) {
            for (UUID schemeUid : schemeUids) {
                log.info("Getting messages for schemeUid: {}", schemeUid);
                messageBLMs.addAll(messageService.getMessagesByScheme(schemeUid, deleteOnGet, offset, limit));
            }
        }

        if (bufferUids != null) {
            for (UUID bufferUid : bufferUids) {
                log.info("Getting messages for bufferUid: {}", bufferUid);
                messageBLMs.addAll(messageService.getMessagesByBuffer(bufferUid, deleteOnGet, offset, limit));
            }
        }

        if (deviceUids != null) {
            for (UUID deviceUid : deviceUids) {
                log.info("Getting messages for deviceUid: {}", deviceUid);
                messageBLMs.addAll(messageService.getMessagesByDevice(deviceUid, deleteOnGet, offset, limit));
            }
        }
        log.info("Got messages: {}", messageBLMs.size());

        List<MessageBLM> resultBLM = new ArrayList<>(messageBLMs);
        List<MessageDTO> resultDTO = resultBLM.stream().map(messageConverter::toDTO).toList();
        return ResponseEntity.ok().body(new MessageResponse(resultDTO));
    }

    @Operation(summary = "Health Check", description = "Проверка статуса сервиса и зависимостей. Не требует аутентификации.")
    @GetMapping("/health")
    public ResponseEntity<HealthResponse> healthCheck() {
        log.info("Health check: service: message-service, timestamp: {}",
                System.currentTimeMillis());

        return ResponseEntity.ok().body(new HealthResponse(messageService.health().toString()));
    }
}package com.connection.device.controller;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.connection.device.DeviceService;
import com.connection.device.config.SecurityUtils;
import com.connection.device.converter.DeviceConverter;
import com.connection.device.model.DeviceBLM;
import com.connection.device.model.DeviceDTO;
import com.connection.device.validator.DeviceValidator;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@RestController
@RequestMapping("/api/v1/device")
public class DeviceController {
    
    @Qualifier("DeviceServiceApiImpl")
    private final DeviceService deviceService;
    
    private final DeviceValidator deviceValidator;
    private final DeviceConverter deviceConverter;

    // Константы для пагинации по умолчанию
    private static final int DEFAULT_OFFSET = 0;
    private static final int DEFAULT_LIMIT = 50;
    private static final int MAX_LIMIT = 1000;

    public DeviceController(
            @Qualifier("DeviceServiceApiImpl") DeviceService deviceService,
            DeviceValidator deviceValidator,
            DeviceConverter deviceConverter) {
        this.deviceService = deviceService;
        this.deviceValidator = deviceValidator;
        this.deviceConverter = deviceConverter;
    }

    @PostMapping("/devices")
    public ResponseEntity<DeviceResponse> createDevice(@RequestBody DeviceDTO deviceDTO) {
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        log.info("Creating device for client {}", clientUid);

        deviceValidator.validate(deviceDTO);
        DeviceBLM deviceBLM = deviceConverter.toBLM(deviceDTO);
        DeviceBLM device = deviceService.createDevice(deviceBLM);

        return ResponseEntity.ok(new DeviceResponse(device.getUid()));
    }

    @GetMapping("/devices")
    public ResponseEntity<DevicesListResponse> getDevicesByClient(
            @RequestParam(required = false) List<UUID> deviceUids,
            @RequestParam(defaultValue = "" + DEFAULT_OFFSET) int offset,
            @RequestParam(defaultValue = "" + DEFAULT_LIMIT) int limit) {
        
        log.info("Getting devices for client with offset: {}, limit: {}", offset, limit);
        
        List<DeviceBLM> allDevices = new ArrayList<>();
        if (deviceUids != null && !deviceUids.isEmpty()){
            for (UUID devUuid : deviceUids){
                allDevices.add(deviceService.getDevice(devUuid));
            }
        }
        else{
            UUID clientUid = SecurityUtils.getCurrentClientUid();
            allDevices.addAll(deviceService.getDevicesByClient(clientUid));
        }
        
        List<DeviceBLM> paginatedDevices = applyPagination(allDevices, offset, limit);
        List<DeviceDTO> deviceDTOs = paginatedDevices.stream()
                .map(deviceConverter::toDTO)
                .collect(Collectors.toList());

        DevicesListResponse.PaginationInfo paginationInfo = 
            new DevicesListResponse.PaginationInfo(
                offset, 
                limit, 
                allDevices.size(), 
                (offset + limit) < allDevices.size()
            );

        return ResponseEntity.ok(new DevicesListResponse(deviceDTOs, paginationInfo));
    }

    @PutMapping("/devices/{deviceUid}")
    public ResponseEntity<DeviceResponse> updateDevice(
            @PathVariable UUID deviceUid,
            @RequestBody DeviceDTO deviceDTO) {
        
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        log.info("Updating device: {} for client: {}", deviceUid, clientUid);

        deviceValidator.validate(deviceDTO);
        DeviceBLM deviceBLM = deviceConverter.toBLM(deviceDTO);
        DeviceBLM device = deviceService.updateDevice(deviceBLM);

        return ResponseEntity.ok(new DeviceResponse(device.getUid()));
    }

    @DeleteMapping("/devices/{deviceUid}")
    public ResponseEntity<Void> deleteDevice(@PathVariable UUID deviceUid) {
        log.info("Deleting device: {}", deviceUid);

        deviceService.deleteDevice(deviceUid);

        return ResponseEntity.noContent().build();
    }

    @GetMapping("/health")
    public ResponseEntity<HealthResponse> healthCheck() {
        log.info("Health check: status: OK, service: device-service, timestamp: {}", 
                System.currentTimeMillis());

        return ResponseEntity.ok().body(new HealthResponse(deviceService.getHealthStatus().toString()));
    }

    /**
     * Применяет пагинацию к списку устройств
     * 
     * @param devices полный список устройств
     * @param offset смещение (начальная позиция)
     * @param limit максимальное количество элементов
     * @return пагинированный список устройств
     */
    private List<DeviceBLM> applyPagination(List<DeviceBLM> devices, int offset, int limit) {
        // Валидация параметров пагинации
        if (offset < 0) {
            offset = DEFAULT_OFFSET;
        }
        
        if (limit <= 0 || limit > MAX_LIMIT) {
            limit = DEFAULT_LIMIT;
        }
        
        // Применяем пагинацию
        return devices.stream()
                .skip(offset)
                .limit(limit)
                .collect(Collectors.toList());
    }
}package com.service.device.auth.controller;

import java.util.List;
import java.util.UUID;

import org.springframework.data.util.Pair;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.connection.device.token.converter.DeviceAccessTokenConverter;
import com.connection.device.token.converter.DeviceTokenConverter;
import com.connection.device.token.model.DeviceAccessTokenBLM;
import com.connection.device.token.model.DeviceAccessTokenDTO;
import com.connection.device.token.model.DeviceTokenBLM;
import com.connection.device.token.model.DeviceTokenDTO;
import com.connection.device.token.util.TokenUtils;
import com.service.device.auth.DeviceAuthService;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/v1/device/auth")
public class DeviceAuthController {

    private final DeviceAuthService deviceAuthService;
    private final DeviceTokenConverter deviceTokenConverter;
    private final DeviceAccessTokenConverter deviceAccessTokenConverter;

    @PostMapping("/device-token")
    public ResponseEntity<DeviceTokenResponse> createDeviceToken(@RequestBody CreateDeviceTokenRequest request) {
        log.info("Creating device token for device: {}", request.deviceUid());

        DeviceTokenBLM deviceToken = deviceAuthService.createDeviceToken(request.deviceUid());

        return ResponseEntity.ok(new DeviceTokenResponse(
                deviceToken.getToken(),
                deviceToken.getExpiresAt(),
                deviceToken.getDeviceUid()));
    }

    @GetMapping("/device-token")
    public ResponseEntity<DeviceTokenResponse> getDeviceToken(
            @RequestParam(required = false) UUID deviceUid) {

        DeviceTokenBLM deviceToken;

        if (deviceUid != null) {
            log.info("Getting device token for device: {}", deviceUid);
            deviceToken = deviceAuthService.getDeviceToken(deviceUid);
        } else {
            log.warn("No valid parameters provided for getting device token");
            return ResponseEntity.badRequest().build();
        }

        return ResponseEntity.ok(new DeviceTokenResponse(
                deviceToken.getToken(),
                deviceToken.getExpiresAt(),
                deviceToken.getDeviceUid()));
    }

    @DeleteMapping("/device-token")
    public ResponseEntity<Void> revokeDeviceToken(
            @RequestParam(required = false) List<UUID> deviceUids) {

        if (deviceUids != null && !deviceUids.isEmpty()) {
            // Массовое удаление токенов по deviceUids
            log.info("Revoking device tokens for devices: {}", deviceUids);
            for (UUID uid : deviceUids) {
                deviceAuthService.revokeDeviceToken(uid);
            }
        } else {
            log.warn("No valid parameters provided for revoking device token");
            return ResponseEntity.badRequest().build();
        }

        return ResponseEntity.ok().build();
    }

    @PostMapping("/access-token")
    public ResponseEntity<DeviceAccessTokenResponse> createDeviceAccessToken(
            @RequestBody DeviceTokenDTO deviceTokenDTO) {
        log.info("Creating device access token");

        DeviceTokenBLM deviceToken = deviceTokenConverter.toBLM(deviceTokenDTO);

        log.info(deviceToken.getToken() + " \n" +
                deviceToken.getCreatedAt() + " \n" +
                deviceToken.getDeviceUid() + " \n" +
                deviceToken.getExpiresAt() + " \n" +
                deviceToken.getUid());

        Pair<DeviceAccessTokenBLM, DeviceTokenBLM> result = deviceAuthService.createDeviceAccessToken(deviceToken);

        return ResponseEntity.ok(new DeviceAccessTokenResponse(
                result.getFirst().getToken(),
                result.getFirst().getExpiresAt(),
                result.getSecond().getDeviceUid()));
    }

    @PostMapping("/access-token/refresh")
    public ResponseEntity<DeviceAccessTokenResponse> refreshDeviceAccessToken(
            @RequestBody DeviceAccessTokenDTO deviceAccessTokenDTO) {
        log.info("Refreshing device access token");

        DeviceAccessTokenBLM deviceAccessToken = deviceAccessTokenConverter.toBLM(deviceAccessTokenDTO);
        DeviceAccessTokenBLM newAccessToken = deviceAuthService.refreshDeviceAccessToken(deviceAccessToken);

        return ResponseEntity.ok(new DeviceAccessTokenResponse(
                newAccessToken.getToken(),
                newAccessToken.getExpiresAt(),
                TokenUtils.extractDeviceUidFromDeviceToken(newAccessToken.getToken())));
    }

    @PostMapping("/validate")
    public ResponseEntity<ValidationResponse> validateToken(
            @RequestParam(required = false) String deviceToken,
            @RequestParam(required = false) String accessToken) {

        if (deviceToken != null) {
            log.info("Validating device token");
            DeviceTokenDTO deviceTokenDTO = new DeviceTokenDTO(deviceToken);
            DeviceTokenBLM deviceTokenBLM = deviceTokenConverter.toBLM(deviceTokenDTO);
            deviceAuthService.validateDeviceToken(deviceTokenBLM);
            return ResponseEntity.ok(new ValidationResponse("DEVICE_TOKEN_VALID"));
        } else if (accessToken != null) {
            log.info("Validating device access token");
            log.info(accessToken);
            DeviceAccessTokenDTO accessTokenDTO = new DeviceAccessTokenDTO(accessToken);
            log.info(accessTokenDTO.getToken());

            DeviceAccessTokenBLM accessTokenBLM = deviceAccessTokenConverter.toBLM(accessTokenDTO);
            log.info(accessTokenBLM.getToken().toString() + " " +
                    accessTokenBLM.getCreatedAt().toString() + " " +
                    accessTokenBLM.getExpiresAt().toString() + " " +
                    accessTokenBLM.getDeviceTokenUid().toString() + " " +
                    accessTokenBLM.getUid());

            deviceAuthService.validateDeviceAccessToken(accessTokenBLM);

            return ResponseEntity.ok(new ValidationResponse("ACCESS_TOKEN_VALID"));
        } else {
            log.warn("No valid parameters provided for token validation");
            return ResponseEntity.badRequest().build();
        }
    }

    @GetMapping("/health")
    public ResponseEntity<HealthResponse> healthCheck() {
        log.info("Health check: status: OK, service: device-service, timestamp: {}",
                System.currentTimeMillis());

        return ResponseEntity.ok().body(new HealthResponse(deviceAuthService.getHealthStatus().toString()));
    }

    // DTO классы
    public record CreateDeviceTokenRequest(UUID deviceUid) {
    }

    public record DeviceTokenResponse(String token, Object expiresAt, UUID deviceUid) {
    }

    public record DeviceAccessTokenResponse(String token, Object expiresAt, UUID deviceUid) {
    }

    public record ValidationResponse(String status) {
    }

    public record HealthResponse(String message) {
    }
}