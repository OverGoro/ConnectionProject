package com.service.auth.config;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.connection.token.repository.RefreshTokenRepository;
import com.connection.token.repository.RefreshTokenRepositorySQLImpl;

@Configuration
public class RefreshTokenRepositoryConfig {
    @Bean("RefreshTokenRepository")
    RefreshTokenRepository refreshTokenRepository(@Qualifier("RefreshTokenJdbcTemplate")NamedParameterJdbcTemplate template){
        return new RefreshTokenRepositorySQLImpl(template);
    }
}
package com.service.auth.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.connection.client.converter.ClientConverter;
import com.connection.client.validator.ClientValidator;


@Configuration
public class ClientUtilsConfig {
    @Bean("ClientConverter")
    ClientConverter clientConverter(){
        return new ClientConverter();
    }

    @Bean("ClientValidator")
    ClientValidator clientValidator(){
        return new ClientValidator();
    }
}
package com.service.auth.config;

import java.util.Properties;

import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.atomikos.jdbc.AtomikosDataSourceBean;

@Configuration
public class RefreshTokenJDBCConfig {
    
    @Value("${app.datasource.refresh-token.xa-data-source-class-name:org.postgresql.xa.PGXADataSource}")
    private String xaDataSourceClassName;

    @Value("${app.datasource.refresh-token.xa-properties.url}")
    private String jdbcUrl;

    @Value("${app.datasource.refresh-token.xa-properties.user}")
    private String username;

    @Value("${app.datasource.refresh-token.xa-properties.password}")
    private String password;

    @Value("${app.datasource.refresh-token.pool-size:5}")
    private int poolSize;

    @Value("${app.datasource.refresh-token.max-pool-size:10}")
    private int maxPoolSize;

    @Value("${app.datasource.refresh-token.min-pool-size:2}")
    private int minPoolSize;

    @Value("${app.datasource.refresh-token.borrow-connection-timeout:30000}")
    private int borrowConnectionTimeout;

    @Value("${app.datasource.refresh-token.max-idle-time:60}")
    private int maxIdleTime;

    @Value("${app.datasource.refresh-token.max-lifetime:120}")
    private int maxLifetime;

    @Value("${app.datasource.refresh-token.test-query:SELECT 1}")
    private String testQuery;

    @Value("${app.datasource.refresh-token.maintenance-interval:60}")
    private int maintenanceInterval;

    @Value("${app.datasource.refresh-token.unique-resource-name:refreshTokenXADataSource}")
    private String uniqueResourceName;

    @Bean("RefreshTokenDataSource")
    DataSource refreshTokenDataSource() {
        AtomikosDataSourceBean dataSource = new AtomikosDataSourceBean();

        dataSource.setUniqueResourceName(uniqueResourceName);
        dataSource.setXaDataSourceClassName(xaDataSourceClassName);

        Properties xaProperties = new Properties();
        xaProperties.setProperty("url", jdbcUrl);
        xaProperties.setProperty("user", username);
        xaProperties.setProperty("password", password);

        dataSource.setXaProperties(xaProperties);

        dataSource.setPoolSize(poolSize);
        dataSource.setMaxPoolSize(maxPoolSize);
        dataSource.setMinPoolSize(minPoolSize);
        dataSource.setBorrowConnectionTimeout(borrowConnectionTimeout);
        dataSource.setMaxIdleTime(maxIdleTime);
        dataSource.setMaxLifetime(maxLifetime);

        dataSource.setTestQuery(testQuery);
        dataSource.setMaintenanceInterval(maintenanceInterval);

        return dataSource;
    }

    @Bean("RefreshTokenJdbcTemplate")
    NamedParameterJdbcTemplate refreshTokenNamedParameterJdbcTemplate(
            @Qualifier("RefreshTokenDataSource") DataSource refreshTokenDataSource) {
        return new NamedParameterJdbcTemplate(refreshTokenDataSource);
    }
}package com.service.auth.config;

import java.util.Properties;

import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.atomikos.jdbc.AtomikosDataSourceBean;

@Configuration
public class ClientJDBCConfig {
    
    @Value("${app.datasource.client.xa-data-source-class-name:org.postgresql.xa.PGXADataSource}")
    private String xaDataSourceClassName;

    @Value("${app.datasource.client.xa-properties.url}")
    private String jdbcUrl;

    @Value("${app.datasource.client.xa-properties.user}")
    private String username;

    @Value("${app.datasource.client.xa-properties.password}")
    private String password;

    @Value("${app.datasource.client.pool-size:5}")
    private int poolSize;

    @Value("${app.datasource.client.max-pool-size:10}")
    private int maxPoolSize;

    @Value("${app.datasource.client.min-pool-size:2}")
    private int minPoolSize;

    @Value("${app.datasource.client.borrow-connection-timeout:30000}")
    private int borrowConnectionTimeout;

    @Value("${app.datasource.client.max-idle-time:60}")
    private int maxIdleTime;

    @Value("${app.datasource.client.max-lifetime:120}")
    private int maxLifetime;

    @Value("${app.datasource.client.test-query:SELECT 1}")
    private String testQuery;

    @Value("${app.datasource.client.maintenance-interval:60}")
    private int maintenanceInterval;

    @Value("${app.datasource.client.unique-resource-name:clientXADataSource}")
    private String uniqueResourceName;

    @Bean("ClientDataSource")
    DataSource clientDataSource() {
        AtomikosDataSourceBean dataSource = new AtomikosDataSourceBean();

        dataSource.setUniqueResourceName(uniqueResourceName);
        dataSource.setXaDataSourceClassName(xaDataSourceClassName);
        
        Properties xaProperties = new Properties();
        xaProperties.setProperty("url", jdbcUrl);
        xaProperties.setProperty("user", username);
        xaProperties.setProperty("password", password);

        dataSource.setXaProperties(xaProperties);

        dataSource.setPoolSize(poolSize);
        dataSource.setMaxPoolSize(maxPoolSize);
        dataSource.setMinPoolSize(minPoolSize);
        dataSource.setBorrowConnectionTimeout(borrowConnectionTimeout);
        dataSource.setMaxIdleTime(maxIdleTime);
        dataSource.setMaxLifetime(maxLifetime);

        dataSource.setTestQuery(testQuery);
        dataSource.setMaintenanceInterval(maintenanceInterval);

        return dataSource;
    }

    @Bean("ClientJdbcTemplate")
    NamedParameterJdbcTemplate clientNamedParameterJdbcTemplate(
            @Qualifier("ClientDataSource") DataSource clientDataSource) {
        return new NamedParameterJdbcTemplate(clientDataSource);
    }
}package com.service.auth.config;

import java.nio.charset.StandardCharsets;
import java.time.Duration;

import javax.crypto.SecretKey;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import io.jsonwebtoken.security.MacAlgorithm;

@Configuration
public class JwtConfig {
    @Value("${JWT_KEY:${app.jwt.key:zbhcWhLNkuwmbgJBdLKQU5tEArWPrWyMHrenwYT7e9c}}")
    private String jwtSecretString;

    @Value("AuthToken")
    private String jwtSubjectString;

    @Value("${ACCESS_TOKEN_EXPIRATION:${app.jwt.access-token.expiration:600}}")
    private long accessTokenExpiration;
    
    @Value("${REFRESH_TOKEN_EXPIRATION:${app.jwt.refresh-token.expiration:86400}}")
    private long refreshTokenExpiration;

    private final MacAlgorithm jwtAlgorithmMacAlgorithm = Jwts.SIG.HS256;

    @Bean("jwtSecretKey")
    SecretKey jwtSecretKey() {
        return createSecretKeyFromString(jwtSecretString, jwtAlgorithmMacAlgorithm);
    }

    @Bean("jwtSubject")
    String jwtSubject(){
        return jwtSecretString;
    }

    @Bean("jwtAccessTokenExpiration")
    Duration jwtAccessTokenDuration(){
        return Duration.ofSeconds(accessTokenExpiration);
    }

    @Bean("jwtRefreshTokenExpiration")
    Duration jwtRefreshTokenDuration(){
        return Duration.ofSeconds(refreshTokenExpiration);
    }
    
    @Bean("jwtAlghorithm")
    MacAlgorithm jwtAlgorithmMacAlgorithm(){
        return jwtAlgorithmMacAlgorithm;
    }

    private SecretKey createSecretKeyFromString(String secretString, MacAlgorithm algorithm) {
        byte[] keyBytes = secretString.getBytes(StandardCharsets.UTF_8);
        return Keys.hmacShaKeyFor(keyBytes);
    }


}
package com.service.auth.config;

import javax.crypto.SecretKey;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.connection.token.converter.RefreshTokenConverter;
import com.connection.token.generator.RefreshTokenGenerator;
import com.connection.token.validator.RefreshTokenValidator;

@Configuration
public class RefreshTokenUtilsConfig {

    @Bean("RefreshTokenValidator")
    RefreshTokenValidator refreshTokenValidator(){
        return new RefreshTokenValidator();
    }

    @Bean("RefreshTokenGenerator")
    RefreshTokenGenerator refreshTokenGenerator(
            @Qualifier("jwtSecretKey") SecretKey secretKey,
            @Qualifier("appName") String appNameString,
            @Qualifier("jwtSubject") String subjecString) {
        return new RefreshTokenGenerator(secretKey, appNameString, subjecString);
    }

    @Bean("RefreshTokenConverter")
    RefreshTokenConverter refreshTokenConverter(
            @Qualifier("RefreshTokenGenerator") RefreshTokenGenerator refreshTokenGenerator) {
        return new RefreshTokenConverter(refreshTokenGenerator);
    }
}
package com.service.auth.config;

import java.util.HashMap;
import java.util.Map;

import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.clients.producer.ProducerConfig;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.core.ConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaProducerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.core.ProducerFactory;
import org.springframework.kafka.listener.DefaultErrorHandler;
import org.springframework.kafka.support.serializer.ErrorHandlingDeserializer;
import org.springframework.kafka.support.serializer.JsonDeserializer;
import org.springframework.kafka.support.serializer.JsonSerializer;
import org.springframework.util.backoff.FixedBackOff;

@Configuration
public class KafkaConfig {

    @Value("${spring.kafka.bootstrap-servers:localhost:29092}")
    private String bootstrapServers;

    // Конфигурация для Consumer с обработкой ошибок десериализации
    @Bean
    public ConsumerFactory<String, Object> consumerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        configProps.put(ConsumerConfig.GROUP_ID_CONFIG, "auth-service-group"); // Изменено на auth-service-group
        configProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");
        configProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer.class);
        configProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer.class);

        // Конфигурация для JsonDeserializer
        configProps.put(JsonDeserializer.TRUSTED_PACKAGES,
                "com.connection.auth.events.commands," +
                        "com.connection.auth.events.responses," +
                        "com.connection.common.events");

        // Конфигурация для ErrorHandlingDeserializer (как в BufferKafkaConfig)
        configProps.put(ErrorHandlingDeserializer.KEY_DESERIALIZER_CLASS,
                org.apache.kafka.common.serialization.StringDeserializer.class);
        configProps.put(ErrorHandlingDeserializer.VALUE_DESERIALIZER_CLASS, JsonDeserializer.class);

        configProps.put(JsonDeserializer.USE_TYPE_INFO_HEADERS, true);
        configProps.put(JsonDeserializer.REMOVE_TYPE_INFO_HEADERS, false);
        configProps.put(JsonDeserializer.VALUE_DEFAULT_TYPE, "com.connection.common.events.Command");

        return new DefaultKafkaConsumerFactory<>(configProps);
    }

    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, Object> kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory<String, Object> factory = new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory());

        // Обработка ошибок десериализации - пропускаем некорректные сообщения (как в
        // BufferKafkaConfig)
        DefaultErrorHandler errorHandler = new DefaultErrorHandler(
                (record, exception) -> {
                    org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger("KafkaErrorHandler");
                    logger.error(
                            "Skipping invalid message - Topic: {}, Partition: {}, Offset: {}, Key: {}, Error: {}, {}",
                            record.topic(),
                            record.partition(),
                            record.offset(),
                            record.key(),
                            exception.getMessage(),
                            exception.toString());
                },
                new FixedBackOff(0L, 0L));

        factory.setCommonErrorHandler(errorHandler);

        return factory;
    }

    // Конфигурация для Producer (как в BufferKafkaConfig)
    @Bean
    public ProducerFactory<String, Object> producerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,
                org.apache.kafka.common.serialization.StringSerializer.class);
        configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
        configProps.put(JsonSerializer.ADD_TYPE_INFO_HEADERS, true);
        return new DefaultKafkaProducerFactory<>(configProps);
    }

    @Bean
    public KafkaTemplate<String, Object> kafkaTemplate() {
        return new KafkaTemplate<>(producerFactory());
    }
}package com.service.auth.config;

import java.util.UUID;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.jta.JtaTransactionManager;

import com.atomikos.icatch.jta.UserTransactionManager;

import jakarta.transaction.SystemException;

@Configuration
public class TransactionConfig {
    
    @Bean
    public UserTransactionManager userTransactionManager() throws SystemException {
        // Устанавливаем уникальное имя через системные свойства только если они еще не установлены
        setPropertyIfNotExists("com.atomikos.icatch.log_base_name", "atomikos-tm-" + UUID.randomUUID().toString().substring(0, 8));
        setPropertyIfNotExists("com.atomikos.icatch.log_base_dir", "./logs");
        setPropertyIfNotExists("com.atomikos.icatch.tm_unique_name", "tm-" + UUID.randomUUID().toString().substring(0, 8));
        
        UserTransactionManager manager = new UserTransactionManager();
        manager.setTransactionTimeout(300);
        manager.setForceShutdown(true);
        return manager;
    }

    @Bean(name = "atomicosTransactionManager")
    public JtaTransactionManager jtaTransactionManager() throws SystemException {
        JtaTransactionManager jtaTransactionManager = new JtaTransactionManager();
        jtaTransactionManager.setTransactionManager(userTransactionManager());
        jtaTransactionManager.setUserTransaction(userTransactionManager());
        return jtaTransactionManager;
    }
    
    /**
     * Устанавливает системное свойство только если оно еще не было установлено
     * @param key ключ свойства
     * @param value значение свойства
     */
    private void setPropertyIfNotExists(String key, String value) {
        if (System.getProperty(key) == null) {
            System.setProperty(key, value);
            System.out.println("Set property: " + key + " = " + value);
        } else {
            System.out.println("Property already set: " + key + " = " + System.getProperty(key));
        }
    }
}package com.service.auth.config;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.connection.client.repository.ClientRepository;
import com.connection.client.repository.ClientRepositorySQLImpl;

@Configuration
public class ClientRepositoryConfig {
    @Bean("ClientRepository")
    ClientRepository clientRepository(@Qualifier("ClientJdbcTemplate")NamedParameterJdbcTemplate template){
        return new ClientRepositorySQLImpl(template);
    }
}
package com.service.auth.config;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ApplicationConfig {
    @Value("${spring.application.name:auth-service}")
    private String appNameString;

    @Bean
    @Qualifier("appName")
    String appName(){
        return appNameString;
    }
}
package com.service.auth.config;

import javax.crypto.SecretKey;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.connection.token.converter.AccessTokenConverter;
import com.connection.token.generator.AccessTokenGenerator;
import com.connection.token.validator.AccessTokenValidator;
@Configuration
public class AccessTokenUtilsConfig {
    @Bean("AccessTokenValidator")
    AccessTokenValidator accessTokenValidator() {
        return new AccessTokenValidator();
    }

    @Bean("AccessTokenGenerator")
    AccessTokenGenerator accessTokenGenerator(
            @Qualifier("jwtSecretKey") SecretKey secretKey,
            @Qualifier("appName") String appNameString,
            @Qualifier("jwtSubject") String subjecString) {
        return new AccessTokenGenerator(secretKey, appNameString, subjecString);
    }

    @Bean("AccessTokenConverter")
    AccessTokenConverter accessTokenConverter(
            @Qualifier("AccessTokenGenerator") AccessTokenGenerator accessTokenGenerator) {
        return new AccessTokenConverter(accessTokenGenerator);
    }

}
package com.service.auth.controller;

import org.springframework.data.util.Pair;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.connection.auth.events.exceptions.TokenValidationException;
import com.connection.client.converter.ClientConverter;
import com.connection.client.model.ClientBLM;
import com.connection.client.model.ClientDTO;
import com.connection.client.validator.ClientValidator;
import com.connection.token.converter.AccessTokenConverter;
import com.connection.token.converter.RefreshTokenConverter;
import com.connection.token.exception.AccessTokenValidateException;
import com.connection.token.exception.BaseTokenException;
import com.connection.token.exception.RefreshTokenAlreadyExisistsException;
import com.connection.token.exception.RefreshTokenExpiredException;
import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.AccessTokenDTO;
import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDTO;
import com.service.auth.AuthService;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/v1")
@Tag(name = "Auth Service", description = "Authentication and Authorization APIs")
public class AuthServiceController {

    private final AccessTokenConverter accessTokenConverter;
    private final RefreshTokenConverter refreshTokenConverter;
    private final ClientConverter clientConverter;
    private final ClientValidator clientValidator;
    private final AuthService authService;

    @Operation(summary = "Register new client", description = "Register a new client in the system")
    @ApiResponse(responseCode = "200", description = "Client registered successfully", content = @Content(schema = @Schema(implementation = RegistrationResponse.class)))
    @PostMapping("/register")
    public ResponseEntity<RegistrationResponse> register(
            @Parameter(description = "Client data", required = true) @RequestBody ClientDTO clientDTO) {

        log.info("Registration attempt for email: {}", clientDTO.getEmail());

        clientValidator.validate(clientDTO);

        ClientBLM clientBLM = clientConverter.toBLM(clientDTO);
        authService.register(clientBLM);

        log.info("Client registered successfully: {}", clientDTO.getUid());
        return ResponseEntity.ok(new RegistrationResponse(
                "User registered successfully",
                clientDTO.getEmail()));
    }

    @Operation(summary = "Login by email", description = "Authenticate client using email and password")
    @ApiResponse(responseCode = "201", description = "Login successful", content = @Content(schema = @Schema(implementation = LoginResponse.class)))
    @PostMapping("/login")
    public ResponseEntity<LoginResponse> loginByEmail(
            @io.swagger.v3.oas.annotations.parameters.RequestBody(description = "Login credentials", required = true, content = @Content(schema = @Schema(implementation = LoginRequest.class))) @RequestBody LoginRequest loginRequest) {

        log.info("Login attempt by email: {}", loginRequest.getEmail());

        Pair<AccessTokenBLM, RefreshTokenBLM> tokens = authService.authorizeByEmail(
                loginRequest.getEmail(), loginRequest.getPassword());

        log.info("Login successful for email: {}", loginRequest.getEmail());

        return ResponseEntity.ok(new LoginResponse(
                tokens.getFirst().getToken(),
                tokens.getSecond().getToken(),
                tokens.getFirst().getExpiresAt(),
                tokens.getSecond().getExpiresAt(),
                tokens.getFirst().getClientUID()));
    }

    @Operation(summary = "Refresh tokens", description = "Get new access and refresh tokens using refresh token")
    @ApiResponse(responseCode = "201", description = "Tokens refreshed successfully", content = @Content(schema = @Schema(implementation = LoginResponse.class)))
    @PostMapping("/refresh")
    public ResponseEntity<LoginResponse> refreshToken(
            @Parameter(description = "Refresh token request", required = true) @RequestBody RefreshTokenRequest refreshRequest) {
        try {
            log.info("Token refresh attempt");
            log.info(refreshRequest.getRefreshToken());
            RefreshTokenDTO refreshTokenDTO = new RefreshTokenDTO(refreshRequest.getRefreshToken());
            RefreshTokenBLM refreshTokenBLM = refreshTokenConverter.toBLM(refreshTokenDTO);

            log.info(refreshTokenBLM.getToken());
            log.info(refreshTokenBLM.getClientUID().toString());

            Pair<AccessTokenBLM, RefreshTokenBLM> newTokens = authService.refresh(refreshTokenBLM);

            log.info("Token refresh successful");
            return ResponseEntity.ok(new LoginResponse(
                    newTokens.getFirst().getToken(),
                    newTokens.getSecond().getToken(),
                    newTokens.getFirst().getExpiresAt(),
                    newTokens.getSecond().getExpiresAt(),
                    newTokens.getFirst().getClientUID()));
        } catch (BaseTokenException e) {
            return ResponseEntity.badRequest().build();
        }
    }

    @Operation(summary = "Health check", description = "Check service health")
    @ApiResponse(responseCode = "200", description = "Service is healthy", content = @Content(schema = @Schema(implementation = HealthResponse.class)))
    @GetMapping("/health")
    public ResponseEntity<HealthResponse> healthCheck() {
        log.info("Health check: status: OK, service: auth-service, timestamp: {}",
                System.currentTimeMillis());

        return ResponseEntity.ok(new HealthResponse(
                "OK",
                "auth-service",
                System.currentTimeMillis()));
    }

    @Operation(summary = "Validate access token", description = "Check if access token is valid")
    @ApiResponse(responseCode = "200", description = "Token is valid", content = @Content(schema = @Schema(implementation = ValidationResponse.class)))
    @PostMapping("/validate/access")
    public ResponseEntity<ValidationResponse> validateAccessToken(
            @Parameter(description = "Access token to validate", required = true) @RequestParam String accessToken) {
        try {
            log.info("Validating access token");
            AccessTokenDTO accessTokenDTO = new AccessTokenDTO(accessToken);

            AccessTokenBLM accessTokenBLM = accessTokenConverter.toBLM(accessTokenDTO);
            authService.validateAccessToken(accessTokenBLM);

            return ResponseEntity.ok(new ValidationResponse("OK"));
        } catch (BaseTokenException e) {
            return ResponseEntity.badRequest().build();
        }

    }

    @Operation(summary = "Validate refresh token", description = "Check if refresh token is valid")
    @ApiResponse(responseCode = "200", description = "Token is valid", content = @Content(schema = @Schema(implementation = ValidationResponse.class)))
    @PostMapping("/validate/refresh")
    public ResponseEntity<ValidationResponse> validateRefreshToken(
            @Parameter(description = "Refresh token to validate", required = true) @RequestParam String refreshToken) {

        log.info("Validating refresh token");
        RefreshTokenDTO refreshTokenDTO = new RefreshTokenDTO(refreshToken);

        RefreshTokenBLM refreshTokenBLM = refreshTokenConverter.toBLM(refreshTokenDTO);
        authService.validateRefreshToken(refreshTokenBLM);

        return ResponseEntity.ok(new ValidationResponse("OK"));
    }
}package com.service.auth.controller;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
@Schema
public class ValidationResponse {
    private final String status;
}
package com.service.auth.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;


import java.util.Map;

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(com.connection.client.exception.ClientAlreadyExisistsException.class)
    public ResponseEntity<?> handleClientAlreadyExistsException(
            com.connection.client.exception.ClientAlreadyExisistsException e) {
        log.warn("Client registration failed: {}", e);
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(new ErrorResponse(
                "client_already_exist",
                "An account with such email or uid already exists"));
    }

    @ExceptionHandler(com.connection.client.exception.ClientNotFoundException.class)
    public ResponseEntity<?> handleClientNotFoundException(com.connection.client.exception.ClientNotFoundException e) {
        log.warn("Client not found: {}", e);
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ErrorResponse(
                "client_not_found",
                "User not found"));
    }

    @ExceptionHandler(com.connection.client.exception.ClientValidateException.class)
    public ResponseEntity<?> handleClientValidateException(com.connection.client.exception.ClientValidateException e) {
        log.warn("Client validation failed: {}\n {}", e, e.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(new ErrorResponse(
                "validation_failed",
                e.getMessage() != null ? e.getMessage() : "Invalid user data"));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<?> handleGenericException(Exception e) {
        log.error("Unexpected error occurred: {}", e);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of(
                "error", "Internal server error",
                "message", "An unexpected error occurred"));
    }
}package com.service.auth.controller;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
@Schema
public class ErrorResponse {
    private final String error;
    private final String message;
}

package com.service.auth.controller;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
@Schema
public class HealthResponse {
    private final String status;
    private final String service;
    private final long timestamp;
}

package com.service.auth.controller;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
@Getter
@Setter
@Schema
public class RegistrationResponse {
    private final String message;
    private final String email;
}package com.service.auth.controller;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Schema(description = "Login request with email and password")
public class LoginRequest {
    
    @Schema(description = "User email", required = true)
    private String email;
    
    @Schema(description = "User password", required = true)
    private String password;
}package com.service.auth.controller;

import java.util.Date;
import java.util.UUID;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Getter;
import lombok.Setter;

@Data
@AllArgsConstructor
@Getter
@Setter
@Schema(description = "Login response with tokens")
public class LoginResponse {
    
    private String accessToken;
    
    private String refreshToken;

    private Date accessTokenExpiresAt;  // Используйте конкретный тип
    
    private Date refreshTokenExpiresAt;  // Используйте конкретный тип
    
    private UUID clientUid;
}package com.service.auth.controller;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
@Getter
@Setter
@Schema
public class RefreshTokenRequest {
    private String refreshToken;
}

package com.service.auth.kafka;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

import com.connection.auth.events.commands.HealthCheckCommand;
import com.connection.auth.events.commands.ValidateTokenCommand;
import com.connection.auth.events.responses.HealthCheckResponse;
import com.connection.auth.events.responses.TokenValidationResponse;
import com.connection.common.events.Command;
import com.connection.token.converter.AccessTokenConverter;
import com.connection.token.model.AccessTokenBLM;
import com.service.auth.AuthService;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class AuthCommandConsumer {

    private final AuthService authService;
    private final AccessTokenConverter accessTokenConverter;
    private final KafkaTemplate<String, Object> kafkaTemplate;

    @KafkaListener(
        topics = "${app.kafka.topics.auth-commands:auth.commands}",
        containerFactory = "kafkaListenerContainerFactory" // Указываем конкретную фабрику
    )
    public void handleAuthCommand(ConsumerRecord<String, Object> record) { // Изменен тип на Object
        try {
            log.debug("Received command from Kafka: key={}, topic={}, partition={}", 
                     record.key(), record.topic(), record.partition());

            Object command = record.value();

            if (command instanceof ValidateTokenCommand) {
                ValidateTokenCommand validateCommand = (ValidateTokenCommand) command;
                handleValidateTokenCommand(validateCommand, record.key());
            } else if (command instanceof HealthCheckCommand) {
                HealthCheckCommand healthCommand = (HealthCheckCommand) command;
                handleHealthCheckCommand(healthCommand, record.key());
            } else {
                log.warn("Unknown command type: {}", command != null ? command.getClass().getCanonicalName() : "null");
            }

        } catch (Exception e) {
            log.error("Error processing auth command from Kafka: key={}", record.key(), e);
        }
    }

    private void handleValidateTokenCommand(ValidateTokenCommand command, String key) {
        try {
            log.info("Processing token validation: correlationId={}", command.getCorrelationId());

            AccessTokenBLM tokenBLM = accessTokenConverter.toBLM(
                    new com.connection.token.model.AccessTokenDTO(command.getToken()));
            authService.validateAccessToken(tokenBLM);

            TokenValidationResponse response = TokenValidationResponse.valid(
                    command.getCorrelationId(),
                    tokenBLM.getClientUID(),
                    command.getTokenType().name());

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
            log.info("Token validation response sent to {}: correlationId={}",
                    command.getReplyTopic(), command.getCorrelationId());

        } catch (Exception e) {
            TokenValidationResponse response = TokenValidationResponse.error(
                    command.getCorrelationId(),
                    e.getMessage());

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
            log.error("Token validation failed: correlationId={}, error={}",
                    command.getCorrelationId(), e.getMessage());
        }
    }

    private void handleHealthCheckCommand(HealthCheckCommand command, String key) {
        try {
            java.util.Map<String, Object> healthStatus = java.util.Map.of(
                    "status", "OK",
                    "service", "auth-service",
                    "timestamp", System.currentTimeMillis());

            HealthCheckResponse response = HealthCheckResponse.success(
                    command.getCorrelationId(),
                    healthStatus);

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
            log.info("Health check response sent to {}: correlationId={}",
                    command.getReplyTopic(), command.getCorrelationId());

        } catch (Exception e) {
            HealthCheckResponse response = HealthCheckResponse.error(
                    command.getCorrelationId(),
                    e.getMessage());

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
            log.error("Health check failed: correlationId={}, error={}",
                    command.getCorrelationId(), e.getMessage());
        }
    }
}package com.service.auth;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class AuthServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(AuthServiceApplication.class, args);
	}
	
}
package com.service.auth;

import org.springframework.data.util.Pair;

import com.connection.client.model.ClientBLM;
import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.RefreshTokenBLM;



public interface AuthService {
    public Pair<AccessTokenBLM, RefreshTokenBLM> authorizeByEmail(String email, String password);
    public void register(ClientBLM clientBLM);
    public Pair<AccessTokenBLM, RefreshTokenBLM> refresh(RefreshTokenBLM refreshTokenBLM);
    public void validateAccessToken(AccessTokenBLM accessTokenBLM);
    public void validateRefreshToken(RefreshTokenBLM refreshTokenBLM);

}
package com.service.auth;

import java.time.Duration;
import java.util.Date;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration;
import org.springframework.data.util.Pair;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.EnableTransactionManagement;
import org.springframework.transaction.annotation.Transactional;

import com.connection.client.model.ClientBLM;
import com.connection.client.repository.ClientRepository;
import com.connection.client.validator.ClientValidator;
import com.connection.token.converter.RefreshTokenConverter;
import com.connection.token.generator.AccessTokenGenerator;
import com.connection.token.generator.RefreshTokenGenerator;
import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDALM;
import com.connection.token.repository.RefreshTokenRepository;
import com.connection.token.validator.AccessTokenValidator;
import com.connection.token.validator.RefreshTokenValidator;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RequiredArgsConstructor
@Service
@EnableAutoConfiguration(exclude = {
        JpaRepositoriesAutoConfiguration.class
})
@EnableTransactionManagement
public class AuthServiceImpl implements AuthService {
    private final RefreshTokenConverter refreshTokenConverter;

    private final ClientValidator clientValidator;
    private final RefreshTokenValidator refreshTokenValidator;
    private final AccessTokenValidator accessTokenValidator;

    private final RefreshTokenGenerator refreshTokenGenerator;
    private final AccessTokenGenerator accessTokenGenerator;

    private final ClientRepository clientRepository;
    private final RefreshTokenRepository refreshTokenRepository;

    @Qualifier("jwtAccessTokenExpiration")
    private final Duration jwtAccessTokenDuration;

    @Qualifier("jwtRefreshTokenExpiration")
    private final Duration jwtRefreshTokenDuration;

    @Override
    @Transactional("atomicosTransactionManager")
    public Pair<AccessTokenBLM, RefreshTokenBLM> authorizeByEmail(String email, String password) {
        clientValidator.validateEmail(email);

        ClientBLM clientBLM = clientRepository.findByEmail(email);

        if (!clientBLM.getPassword().equals(password)) {
            throw new SecurityException("Invalid email or password");
        }

        // Инициалаизация общих полей
        UUID newClientUuid = clientBLM.getUid();
        Date newCreatedAt = new Date();

        // Инициализация нового refreshToken
        UUID newRefreshUID = UUID.randomUUID();

        Date newRefreshExpiresAt = Date.from(newCreatedAt.toInstant().plus(jwtRefreshTokenDuration));
        String newRefreshTokenString = refreshTokenGenerator.generateRefreshToken(newRefreshUID, newClientUuid,
                newCreatedAt, newRefreshExpiresAt);

        RefreshTokenBLM newRefreshTokenBLM = new RefreshTokenBLM(newRefreshTokenString, newRefreshUID, newClientUuid,
                newCreatedAt, newRefreshExpiresAt);

        refreshTokenValidator.validate(newRefreshTokenBLM);

        // Инициалищация нового accessToken
        Date newAccessExpiresAt = Date.from(newCreatedAt.toInstant().plus(jwtAccessTokenDuration));
        String newAcessTokenString = accessTokenGenerator.generateAccessToken(newClientUuid, newCreatedAt,
                newAccessExpiresAt);
        AccessTokenBLM newAccessTokenBLM = new AccessTokenBLM(newAcessTokenString, newClientUuid, newCreatedAt,
                newAccessExpiresAt);
        accessTokenValidator.validate(newAccessTokenBLM);

        // Добавление нового refreshToken в БД
        RefreshTokenDALM newRefreshTokenDALM = refreshTokenConverter.toDALM(newRefreshTokenBLM);
        refreshTokenRepository.add(newRefreshTokenDALM);

        // Возварты пары токенов
        return Pair.of(newAccessTokenBLM, newRefreshTokenBLM);

    }

    @Override
    @Transactional("atomicosTransactionManager")
    public void register(ClientBLM clientBLM) {
        clientValidator.validate(clientBLM);
        clientRepository.add(clientBLM);
    }

    @Override
    @Transactional("atomicosTransactionManager")
    public Pair<AccessTokenBLM, RefreshTokenBLM> refresh(
            RefreshTokenBLM refreshTokenBLM) {

        log.info("Validating refresh token");
        refreshTokenValidator.validate(refreshTokenBLM);
        log.info("Validated refresh token");

        // Инициалаизация общих полей
        UUID newClientUuid = refreshTokenBLM.getClientUID();
        Date newCreatedAt = new Date();

        // Инициализация нового refreshToken
        UUID newRefreshUID = refreshTokenBLM.getUid();
        Date newRefreshExpiresAt = Date.from(newCreatedAt.toInstant().plus(jwtRefreshTokenDuration));
        String newRefreshTokenString = refreshTokenGenerator.generateRefreshToken(newRefreshUID, newClientUuid,
                newCreatedAt, newRefreshExpiresAt);

        RefreshTokenBLM newRefreshTokenBLM = new RefreshTokenBLM(newRefreshTokenString, newRefreshUID, newClientUuid,
                newCreatedAt, newRefreshExpiresAt);
        log.info("Validating new refresh token");
        refreshTokenValidator.validate(newRefreshTokenBLM);
        log.info("Validated new refresh token");

        // Инициалищация нового accessToken
        Date newAccessExpiresAt = Date.from(newCreatedAt.toInstant().plus(jwtAccessTokenDuration));
        String newAcessTokenString = accessTokenGenerator.generateAccessToken(newClientUuid, newCreatedAt,
                newAccessExpiresAt);
        log.info("Generated new access token");
        AccessTokenBLM newAccessTokenBLM = new AccessTokenBLM(newAcessTokenString, newClientUuid, newCreatedAt,
                newAccessExpiresAt);
        accessTokenValidator.validate(newAccessTokenBLM);
        log.info("Validated new access token");

        // Обновление RefreshToken в репозитории
        RefreshTokenDALM refreshTokenDALM = refreshTokenConverter.toDALM(refreshTokenBLM);
        log.info("Converted refresh token");
        RefreshTokenDALM newRefreshTokenDALM = refreshTokenConverter.toDALM(newRefreshTokenBLM);
        log.info("Converted new refresh token");
        refreshTokenRepository.updateToken(refreshTokenDALM, newRefreshTokenDALM);
        log.info("Updated by repo refresh token");
        // Возвращат новых токенов
        return Pair.of(newAccessTokenBLM, newRefreshTokenBLM);
    }

    @Override
    public void validateAccessToken(AccessTokenBLM accessTokenBLM) {
        accessTokenValidator.validate(accessTokenBLM);
    }

    @Override
    public void validateRefreshToken(RefreshTokenBLM refreshTokenBLM) {
        refreshTokenValidator.validate(refreshTokenBLM);
    }
}
package com.service.auth;

import static com.service.auth.mother.AuthObjectMother.*;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.time.Duration;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.data.util.Pair;

import com.connection.client.converter.ClientConverter;
import com.connection.client.model.ClientBLM;
import com.connection.client.validator.ClientValidator;
import com.connection.token.converter.RefreshTokenConverter;
import com.connection.token.generator.AccessTokenGenerator;
import com.connection.token.generator.RefreshTokenGenerator;
import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDALM;
import com.connection.token.repository.RefreshTokenRepository;
import com.connection.token.validator.AccessTokenValidator;
import com.connection.token.validator.RefreshTokenValidator;

@ExtendWith(MockitoExtension.class)
@DisplayName("Auth Service Implementation Tests - London Style")
class AuthServiceImplLondonTest {

    @Mock
    private RefreshTokenConverter refreshTokenConverter;

    @Mock
    private ClientConverter clientConverter;

    @Mock
    private ClientValidator clientValidator;

    @Mock
    private RefreshTokenValidator refreshTokenValidator;

    @Mock
    private AccessTokenValidator accessTokenValidator;

    @Mock
    private RefreshTokenGenerator refreshTokenGenerator;

    @Mock
    private AccessTokenGenerator accessTokenGenerator;

    @Mock
    private RefreshTokenRepository refreshTokenRepository;

    @Mock
    private com.connection.client.repository.ClientRepository clientRepository;

    // Используем реальные Duration вместо моков
    private Duration jwtAccessTokenDuration = Duration.ofSeconds(600); // 10 minutes
    private Duration jwtRefreshTokenDuration = Duration.ofSeconds(86400); // 24 hours

    @InjectMocks
    private AuthServiceImpl authService;

    @BeforeEach
    void setUp() {
        // Устанавливаем реальные Duration через рефлексию, так как они final в
        // AuthServiceImpl
        try {
            var accessTokenField = AuthServiceImpl.class.getDeclaredField("jwtAccessTokenDuration");
            var refreshTokenField = AuthServiceImpl.class.getDeclaredField("jwtRefreshTokenDuration");

            accessTokenField.setAccessible(true);
            refreshTokenField.setAccessible(true);

            accessTokenField.set(authService, jwtAccessTokenDuration);
            refreshTokenField.set(authService, jwtRefreshTokenDuration);
        } catch (Exception e) {
            throw new RuntimeException("Failed to set Duration fields", e);
        }
    }

    @Test
    @DisplayName("Authorize by email - Positive")
    void shouldAuthorizeByEmailWhenValidCredentials() {
        // Arrange
        ClientBLM clientBLM = createValidClientBLM();
        AccessTokenBLM accessTokenBLM = createValidAccessTokenBLM();
        RefreshTokenBLM refreshTokenBLM = createValidRefreshTokenBLM();
        RefreshTokenDALM refreshTokenDALM = new RefreshTokenDALM();

        when(clientRepository.findByEmail(VALID_EMAIL)).thenReturn(clientBLM);
        when(refreshTokenGenerator.generateRefreshToken(any(), any(), any(), any()))
                .thenReturn(refreshTokenBLM.getToken());
        when(accessTokenGenerator.generateAccessToken(any(), any(), any()))
                .thenReturn(accessTokenBLM.getToken());
        when(refreshTokenConverter.toDALM(any(RefreshTokenBLM.class))).thenReturn(refreshTokenDALM);

        // Act
        Pair<AccessTokenBLM, RefreshTokenBLM> result = authService.authorizeByEmail(VALID_EMAIL, VALID_PASSWORD);

        // Assert
        assertThat(result).isNotNull();
        assertThat(result.getFirst()).isNotNull();
        assertThat(result.getSecond()).isNotNull();
        verify(clientValidator).validateEmail(VALID_EMAIL);
        verify(refreshTokenValidator).validate(any(RefreshTokenBLM.class));
        verify(accessTokenValidator).validate(any(AccessTokenBLM.class));
        verify(refreshTokenRepository).add(refreshTokenDALM);
    }

    @Test
    @DisplayName("Authorize by email - Negative: Email validation fails")
    void shouldThrowExceptionWhenEmailValidationFails() {
        // Arrange
        doThrow(new IllegalArgumentException("Invalid email"))
                .when(clientValidator).validateEmail("invalid-email");

        // Act & Assert
        assertThatThrownBy(() -> authService.authorizeByEmail("invalid-email", VALID_PASSWORD))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessageContaining("Invalid email");

        verify(clientRepository, never()).findByEmail(any());
        verify(refreshTokenRepository, never()).add(any());
    }

    @Test
    @DisplayName("Register client - Positive")
    void shouldRegisterClientWhenValidData() {
        // Arrange
        ClientBLM clientBLM = createValidClientBLM();


        // Act
        authService.register(clientBLM);

        // Assert
        verify(clientValidator).validate(clientBLM);
        verify(clientRepository).add(clientBLM);
    }

    @Test
    @DisplayName("Register client - Negative: Client validation fails")
    void shouldThrowExceptionWhenClientValidationFails() {
        // Arrange
        ClientBLM invalidClient = createValidClientBLM();

        doThrow(new IllegalArgumentException("Invalid client data"))
                .when(clientValidator).validate(invalidClient);

        // Act & Assert
        assertThatThrownBy(() -> authService.register(invalidClient))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessageContaining("Invalid client data");

        verify(clientRepository, never()).add(any());
    }

    @Test
    @DisplayName("Refresh tokens - Positive")
    void shouldRefreshTokensWhenValidRefreshToken() {
        // Arrange
        RefreshTokenBLM oldRefreshToken = createValidRefreshTokenBLM();
        RefreshTokenBLM newRefreshToken = createValidRefreshTokenBLM();
        AccessTokenBLM newAccessToken = createValidAccessTokenBLM();
        RefreshTokenDALM oldRefreshTokenDALM = new RefreshTokenDALM();
        RefreshTokenDALM newRefreshTokenDALM = new RefreshTokenDALM();

        when(refreshTokenGenerator.generateRefreshToken(any(), any(), any(), any()))
                .thenReturn(newRefreshToken.getToken());
        when(accessTokenGenerator.generateAccessToken(any(), any(), any()))
                .thenReturn(newAccessToken.getToken());
        when(refreshTokenConverter.toDALM(any(RefreshTokenBLM.class)))
                .thenReturn(oldRefreshTokenDALM) // для первого вызова
                .thenReturn(newRefreshTokenDALM); // для второго вызова
        // Act
        Pair<AccessTokenBLM, RefreshTokenBLM> result = authService.refresh(oldRefreshToken);

        // Assert
        assertThat(result).isNotNull();
        assertThat(result.getFirst()).isNotNull();
        assertThat(result.getSecond()).isNotNull();
    }

    @Test
    @DisplayName("Refresh tokens - Negative: Invalid refresh token")
    void shouldThrowExceptionWhenRefreshTokenInvalid() {
        // Arrange
        RefreshTokenBLM invalidRefreshToken = createExpiredRefreshTokenBLM();

        doThrow(new IllegalArgumentException("Expired refresh token"))
                .when(refreshTokenValidator).validate(invalidRefreshToken);

        // Act & Assert
        assertThatThrownBy(() -> authService.refresh(invalidRefreshToken))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessageContaining("Expired refresh token");

        verify(refreshTokenRepository, never()).updateToken(any(), any());
    }

    @Test
    @DisplayName("Validate access token - Positive")
    void shouldValidateAccessTokenWhenValid() {
        // Arrange
        AccessTokenBLM accessToken = createValidAccessTokenBLM();

        // Act
        authService.validateAccessToken(accessToken);

        // Assert
        verify(accessTokenValidator).validate(accessToken);
    }

    @Test
    @DisplayName("Validate access token - Negative: Invalid token")
    void shouldThrowExceptionWhenAccessTokenInvalid() {
        // Arrange
        AccessTokenBLM invalidAccessToken = createValidAccessTokenBLM();

        doThrow(new IllegalArgumentException("Expired access token"))
                .when(accessTokenValidator).validate(invalidAccessToken);

        // Act & Assert
        assertThatThrownBy(() -> authService.validateAccessToken(invalidAccessToken))
                .isInstanceOf(IllegalArgumentException.class)
                .hasMessageContaining("Expired access token");
    }

    @Test
    @DisplayName("Validate refresh token - Positive")
    void shouldValidateRefreshTokenWhenValid() {
        // Arrange
        RefreshTokenBLM refreshToken = createValidRefreshTokenBLM();

        // Act
        authService.validateRefreshToken(refreshToken);

        // Assert
        verify(refreshTokenValidator).validate(refreshToken);
    }
}package com.service.auth.e2e;

import static org.assertj.core.api.Assertions.assertThat;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.TimeUnit;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import com.service.auth.mother.AuthObjectMother;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@DisplayName("Auth Service API E2E Tests")
public class AuthApiE2ETest extends BaseE2ETest {

    private TestRestTemplate restTemplate = new TestRestTemplate();
    private String testEmail;

    @BeforeEach
    void setup() {
        String uniqueId = UUID.randomUUID().toString().substring(0, 8);
        System.setProperty("com.atomikos.icatch.log_base_name", "test-tm-" + uniqueId);
        System.setProperty("com.atomikos.icatch.log_base_dir", "./test-logs");
        System.setProperty("com.atomikos.icatch.tm_unique_name", "test-tm-" + uniqueId);

        log.info("Base URL for tests: {}", baseUrl);

        // Генерируем уникальный email для каждого теста
        testEmail = "test_" + System.currentTimeMillis() + "_" + Thread.currentThread().getId() + "@example.com";
    }

    @AfterEach
    void cleanup() {
        // Очищаем данные после каждого теста
        if (testEmail != null) {
            cleanupClientData(testEmail);
            log.info("Cleaned up test data for email: {}", testEmail);
        }
        else{
            log.error("cleanup: testEmail is null");
        }
    }

    @Test
    @DisplayName("Should register client via API")
    void shouldRegisterClientViaApi() {
        // Given
        var clientDTO = AuthObjectMother.randomValidClientDTO();
        // Используем уникальный email для этого теста
        testEmail = clientDTO.getEmail();
        log.info("Registering client with email: {}", clientDTO.getEmail());

        // When
        ResponseEntity<Map> response = restTemplate.postForEntity(
                baseUrl + "/register",
                createHttpEntity(clientDTO),
                Map.class);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(response.getBody()).isNotNull();

        Map<String, Object> body = response.getBody();
        assertThat(body.get("message")).isEqualTo("User registered successfully");
        assertThat(body.get("email")).isEqualTo(clientDTO.getEmail());

        log.info("Client registered successfully: {}", clientDTO.getEmail());
    }

    @Test
    @DisplayName("Should login via API and return tokens")
    void shouldLoginViaApiAndReturnTokens() {
        // Given
        var clientDTO = AuthObjectMother.randomValidClientDTO();
        testEmail = clientDTO.getEmail();
        // First register the client
        ResponseEntity<Map> registerResponse = restTemplate.postForEntity(
                baseUrl + "/register",
                createHttpEntity(clientDTO),
                Map.class);
        assertThat(registerResponse.getStatusCode()).isEqualTo(HttpStatus.OK);

        // Prepare login request
        var loginRequest = new LoginRequest(clientDTO.getEmail(),
                clientDTO.getPassword());

        // When
        ResponseEntity<LoginResponse> loginResponse = restTemplate.postForEntity(
                baseUrl + "/login",
                createHttpEntity(loginRequest),
                LoginResponse.class);

        // Then
        assertThat(loginResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(loginResponse.getBody()).isNotNull();

        LoginResponse body = loginResponse.getBody();
        assertThat(body.getAccessToken()).isNotNull();
        assertThat(body.getRefreshToken()).isNotNull();
        assertThat(body.getAccessTokenExpiresAt()).isNotNull();
        assertThat(body.getRefreshTokenExpiresAt()).isNotNull();
        assertThat(body.getClientUid()).isNotNull();

        log.info("Login successful for: {}", clientDTO.getEmail());
    }

    @Test
    @DisplayName("Should refresh tokens via API")
    void shouldRefreshTokensViaApi() {
        // Given
        var clientDTO = AuthObjectMother.randomValidClientDTO();
        testEmail = clientDTO.getEmail();
        // First register the client
        ResponseEntity<Map> registerResponse = restTemplate.postForEntity(
                baseUrl + "/register",
                createHttpEntity(clientDTO),
                Map.class);
        assertThat(registerResponse.getStatusCode()).isEqualTo(HttpStatus.OK);

        // Login to get tokens
        var loginRequest = new LoginRequest(clientDTO.getEmail(), clientDTO.getPassword());

        ResponseEntity<LoginResponse> loginResponse = restTemplate.postForEntity(
                baseUrl + "/login",
                createHttpEntity(loginRequest),
                LoginResponse.class);

        String refreshToken = loginResponse.getBody().getRefreshToken();
        sleep(1000);

        // Prepare refresh request
        var refreshRequest = new RefreshTokenRequest(refreshToken);

        // When
        ResponseEntity<LoginResponse> refreshResponse = restTemplate.postForEntity(
                baseUrl + "/refresh",
                createHttpEntity(refreshRequest),
                LoginResponse.class);

        // Then
        assertThat(refreshResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(refreshResponse.getBody()).isNotNull();

        LoginResponse body = refreshResponse.getBody();
        assertThat(body.getAccessToken()).isNotNull();
        assertThat(body.getRefreshToken()).isNotNull();
        assertThat(body.getAccessToken()).isNotEqualTo(loginResponse.getBody().getAccessToken());
        assertThat(body.getRefreshToken()).isNotEqualTo(refreshToken);

        log.info("Token refresh successful for: {}", clientDTO.getEmail());
    }

    @Test
    @DisplayName("Should validate access token via API")
    void shouldValidateAccessTokenViaApi() {
        // Given
        var clientDTO = AuthObjectMother.randomValidClientDTO();
        testEmail = clientDTO.getEmail(); // Используем уникальный email

        // Register and login
        restTemplate.postForEntity(
                baseUrl + "/register",
                createHttpEntity(clientDTO),
                Map.class);

        var loginRequest = new LoginRequest(clientDTO.getEmail(),
                clientDTO.getPassword());

        ResponseEntity<LoginResponse> loginResponse = restTemplate.postForEntity(
                baseUrl + "/login",
                createHttpEntity(loginRequest),
                LoginResponse.class);

        String accessToken = loginResponse.getBody().getAccessToken();

        // When
        ResponseEntity<ValidationResponse> validationResponse = restTemplate.postForEntity(
                baseUrl + "/validate/access?accessToken=" + accessToken,
                null,
                ValidationResponse.class);

        // Then
        assertThat(validationResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(validationResponse.getBody()).isNotNull();
        assertThat(validationResponse.getBody().getStatus()).isEqualTo("OK");

        log.info("Access token validation successful");
    }

    @Test
    @DisplayName("Should validate refresh token via API")
    void shouldValidateRefreshTokenViaApi() {
        // Given
        var clientDTO = AuthObjectMother.randomValidClientDTO();
        testEmail = clientDTO.getEmail(); // Используем уникальный email

        // Register and login
        restTemplate.postForEntity(
                baseUrl + "/register",
                createHttpEntity(clientDTO),
                Map.class);

        var loginRequest = new LoginRequest(clientDTO.getEmail(),
                clientDTO.getPassword());

        ResponseEntity<LoginResponse> loginResponse = restTemplate.postForEntity(
                baseUrl + "/login",
                createHttpEntity(loginRequest),
                LoginResponse.class);

        String refreshToken = loginResponse.getBody().getRefreshToken();

        // When
        ResponseEntity<ValidationResponse> validationResponse = restTemplate.postForEntity(
                baseUrl + "/validate/refresh?refreshToken=" + refreshToken,
                null,
                ValidationResponse.class);

        // Then
        assertThat(validationResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(validationResponse.getBody()).isNotNull();
        assertThat(validationResponse.getBody().getStatus()).isEqualTo("OK");

        log.info("Refresh token validation successful");
    }

    @Test
    @DisplayName("Should return error for duplicate registration")
    void shouldReturnErrorForDuplicateRegistration() {
        // Given
        var clientDTO = AuthObjectMother.randomValidClientDTO();
        testEmail = clientDTO.getEmail(); // Используем уникальный email

        // First registration
        restTemplate.postForEntity(
                baseUrl + "/register",
                createHttpEntity(clientDTO),
                Map.class);

        // When - Try to register same client again
        ResponseEntity<ErrorResponse> response = restTemplate.postForEntity(
                baseUrl + "/register",
                createHttpEntity(clientDTO),
                ErrorResponse.class);

        // Then
        assertThat(response.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
        assertThat(response.getBody()).isNotNull();

        ErrorResponse body = response.getBody();
        assertThat(body.getError()).isEqualTo("client_already_exist");
        assertThat(body.getMessage()).isEqualTo("An account with such email or uid already exists");

        log.info("Duplicate registration handled correctly");
    }

    @Test
    @DisplayName("Full flow: register -> login -> validate -> refresh -> validate")
    void shouldCompleteFullAuthenticationFlow() {
        // Given
        var clientDTO = AuthObjectMother.randomValidClientDTO();
        testEmail = clientDTO.getEmail(); // Используем уникальный email
        log.info("Starting full flow for: {}", clientDTO.getEmail());

        // Step 1: Register
        ResponseEntity<Map> registerResponse = restTemplate.postForEntity(
                baseUrl + "/register",
                createHttpEntity(clientDTO),
                Map.class);
        assertThat(registerResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
        log.info("Step 1: Registration completed");

        // Step 2: Login
        var loginRequest = new LoginRequest(clientDTO.getEmail(),
                clientDTO.getPassword());
        ResponseEntity<LoginResponse> loginResponse = restTemplate.postForEntity(
                baseUrl + "/login",
                createHttpEntity(loginRequest),
                LoginResponse.class);
        assertThat(loginResponse.getStatusCode()).isEqualTo(HttpStatus.OK);

        String accessToken1 = loginResponse.getBody().getAccessToken();
        String refreshToken1 = loginResponse.getBody().getRefreshToken();
        log.info("Step 2: Login completed");

        // Step 3: Validate access token
        ResponseEntity<ValidationResponse> validateResponse1 = restTemplate.postForEntity(
                baseUrl + "/validate/access?accessToken=" + accessToken1,
                null,
                ValidationResponse.class);
        assertThat(validateResponse1.getStatusCode()).isEqualTo(HttpStatus.OK);
        log.info("Step 3: Access token validation completed");

        sleep(1000);

        // Step 4: Refresh tokens
        var refreshRequest = new RefreshTokenRequest(refreshToken1);
        ResponseEntity<LoginResponse> refreshResponse = restTemplate.postForEntity(
                baseUrl + "/refresh",
                createHttpEntity(refreshRequest),
                LoginResponse.class);
        assertThat(refreshResponse.getStatusCode()).isEqualTo(HttpStatus.OK);

        String accessToken2 = refreshResponse.getBody().getAccessToken();
        String refreshToken2 = refreshResponse.getBody().getRefreshToken();
        log.info("Step 4: Token refresh completed");

        // Step 5: Validate new access token
        ResponseEntity<ValidationResponse> validateResponse2 = restTemplate.postForEntity(
                baseUrl + "/validate/access?accessToken=" + accessToken2,
                null,
                ValidationResponse.class);
        assertThat(validateResponse2.getStatusCode()).isEqualTo(HttpStatus.OK);
        log.info("Step 5: New access token validation completed");

        // Verify tokens are different
        assertThat(accessToken2).isNotEqualTo(accessToken1);
        assertThat(refreshToken2).isNotEqualTo(refreshToken1);

        log.info("Full authentication flow completed successfully for: {}",
                clientDTO.getEmail());
    }

    // Вспомогательные DTO классы для тестов (остаются без изменений)
    public static class LoginRequest {
        private String email;
        private String password;

        public LoginRequest() {
        }

        public LoginRequest(String email, String password) {
            this.email = email;
            this.password = password;
        }

        public String getEmail() {
            return email;
        }

        public void setEmail(String email) {
            this.email = email;
        }

        public String getPassword() {
            return password;
        }

        public void setPassword(String password) {
            this.password = password;
        }
    }

    public static class RefreshTokenRequest {
        private String refreshToken;

        public RefreshTokenRequest() {
        }

        public RefreshTokenRequest(String refreshToken) {
            this.refreshToken = refreshToken;
        }

        public String getRefreshToken() {
            return refreshToken;
        }

        public void setRefreshToken(String refreshToken) {
            this.refreshToken = refreshToken;
        }
    }

    public static class LoginResponse {
        private String accessToken;
        private String refreshToken;
        private java.util.Date accessTokenExpiresAt;
        private java.util.Date refreshTokenExpiresAt;
        private java.util.UUID clientUid;

        // геттеры и сеттеры
        public String getAccessToken() {
            return accessToken;
        }

        public void setAccessToken(String accessToken) {
            this.accessToken = accessToken;
        }

        public String getRefreshToken() {
            return refreshToken;
        }

        public void setRefreshToken(String refreshToken) {
            this.refreshToken = refreshToken;
        }

        public java.util.Date getAccessTokenExpiresAt() {
            return accessTokenExpiresAt;
        }

        public void setAccessTokenExpiresAt(java.util.Date accessTokenExpiresAt) {
            this.accessTokenExpiresAt = accessTokenExpiresAt;
        }

        public java.util.Date getRefreshTokenExpiresAt() {
            return refreshTokenExpiresAt;
        }

        public void setRefreshTokenExpiresAt(java.util.Date refreshTokenExpiresAt) {
            this.refreshTokenExpiresAt = refreshTokenExpiresAt;
        }

        public java.util.UUID getClientUid() {
            return clientUid;
        }

        public void setClientUid(java.util.UUID clientUid) {
            this.clientUid = clientUid;
        }
    }

    public static class ValidationResponse {
        private String status;

        public ValidationResponse() {
        }

        public ValidationResponse(String status) {
            this.status = status;
        }

        public String getStatus() {
            return status;
        }

        public void setStatus(String status) {
            this.status = status;
        }
    }

    public static class HealthResponse {
        private String status;
        private String service;
        private long timestamp;

        public HealthResponse() {
        }

        public HealthResponse(String status, String service, long timestamp) {
            this.status = status;
            this.service = service;
            this.timestamp = timestamp;
        }

        public String getStatus() {
            return status;
        }

        public void setStatus(String status) {
            this.status = status;
        }

        public String getService() {
            return service;
        }

        public void setService(String service) {
            this.service = service;
        }

        public long getTimestamp() {
            return timestamp;
        }

        public void setTimestamp(long timestamp) {
            this.timestamp = timestamp;
        }
    }

    public static class ErrorResponse {
        private String error;
        private String message;

        public ErrorResponse() {
        }

        public ErrorResponse(String error, String message) {
            this.error = error;
            this.message = message;
        }

        public String getError() {
            return error;
        }

        public void setError(String error) {
            this.error = error;
        }

        public String getMessage() {
            return message;
        }

        public void setMessage(String message) {
            this.message = message;
        }
    }
}package com.service.auth.e2e;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.server.LocalServerPort;
import org.springframework.core.env.Environment;
import org.springframework.http.*;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.TestPropertySource;

import com.connection.client.model.ClientDTO;

import lombok.extern.slf4j.Slf4j;

import org.springframework.boot.test.web.client.TestRestTemplate;

import java.util.Arrays;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

import static org.springframework.boot.test.context.SpringBootTest.WebEnvironment.RANDOM_PORT;

@SpringBootTest(webEnvironment = RANDOM_PORT)
@ActiveProfiles("integrationtest")
@TestPropertySource(locations = "classpath:application-integrationtest.properties", properties = {
        "spring.config.location=classpath:application-integrationtest.properties",
        "spring.config.name=application-integrationtest"
})
@Slf4j
public abstract class BaseE2ETest {
    @Autowired
    private Environment environment;

    @LocalServerPort
    protected int port;

    protected TestRestTemplate restTemplate = new TestRestTemplate();

    @Autowired
    protected KafkaTemplate<String, Object> kafkaTemplate;

    @Autowired
    @Qualifier("ClientJdbcTemplate")
    protected NamedParameterJdbcTemplate clientJdbcTemplate;

    @Autowired
    @Qualifier("RefreshTokenJdbcTemplate")
    protected NamedParameterJdbcTemplate refreshTokenJdbcTemplate;

    protected String baseUrl;
    protected final Map<String, String> testData = new ConcurrentHashMap<>();

    @BeforeEach
    void checkConfig() {
        log.info("Kafka servers: {}", environment.getProperty("spring.kafka.bootstrap-servers"));
        log.info("Active profiles: {}", Arrays.toString(environment.getActiveProfiles()));
    }

    @BeforeEach
    void setUp() {
        baseUrl = "http://localhost:" + port + "/api/v1";
    }

    @AfterEach
    void tearDown() {
    }

    protected void cleanupClientData(String email) {
        try {
            log.info("Cleaning up data for email: {}", email);

            // Сначала удаляем refresh tokens из схемы access
            String deleteTokensSql = "DELETE FROM \"access\".refresh_token WHERE client_uid IN (SELECT uid FROM core.client WHERE email = :email)";
            int tokensDeleted = refreshTokenJdbcTemplate.update(deleteTokensSql, Map.of("email", email));
            if (tokensDeleted > 0) {
                log.info("Deleted {} refresh tokens for email: {}", tokensDeleted, email);
            }

            // Затем удаляем клиента из схемы core
            String deleteClientSql = "DELETE FROM core.client WHERE email = :email";
            int clientsDeleted = clientJdbcTemplate.update(deleteClientSql, Map.of("email", email));
            if (clientsDeleted > 0) {
                log.info("Deleted {} clients for email: {}", clientsDeleted, email);
            }

            // Дополнительная очистка связанных данных на всякий случай
            try {
                // Очистка device tokens
                String deleteDeviceTokensSql = "DELETE FROM \"access\".device_token WHERE device_uid IN (SELECT uid FROM core.device WHERE client_uid IN (SELECT uid FROM core.client WHERE email = :email))";
                refreshTokenJdbcTemplate.update(deleteDeviceTokensSql, Map.of("email", email));

                // Очистка devices
                String deleteDevicesSql = "DELETE FROM core.device WHERE client_uid IN (SELECT uid FROM core.client WHERE email = :email)";
                clientJdbcTemplate.update(deleteDevicesSql, Map.of("email", email));

                // Очистка connection schemes
                String deleteSchemesSql = "DELETE FROM processing.connection_scheme WHERE client_uid IN (SELECT uid FROM core.client WHERE email = :email)";
                clientJdbcTemplate.update(deleteSchemesSql, Map.of("email", email));

            } catch (Exception e) {
                log.debug("Optional cleanup failed (tables might not exist): {}", e.getMessage());
            }

        } catch (Exception e) {
            log.warn("Cleanup warning for email {}: {}", email, e.getMessage());
        }
    }

    protected void sleep(long milliseconds) {
        try {
            log.debug("Sleeping for {} ms", milliseconds);
            TimeUnit.MILLISECONDS.sleep(milliseconds);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.warn("Sleep interrupted", e);
        }
    }

    protected HttpEntity<Object> createHttpEntity(Object body) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        return new HttpEntity<>(body, headers);
    }
}package com.service.auth.integration;

import org.apache.kafka.clients.admin.AdminClient;
import org.apache.kafka.clients.admin.CreateTopicsResult;
import org.apache.kafka.clients.admin.NewTopic;
import org.apache.kafka.clients.consumer.Consumer;
import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.consumer.ConsumerRecords;
import org.apache.kafka.common.serialization.StringDeserializer;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.kafka.core.DefaultKafkaConsumerFactory;
import org.springframework.kafka.support.serializer.ErrorHandlingDeserializer;
import org.springframework.kafka.support.serializer.JsonDeserializer;
import org.springframework.test.annotation.DirtiesContext;
import org.springframework.test.context.ActiveProfiles;

import com.connection.auth.events.commands.HealthCheckCommand;
import com.connection.auth.events.responses.HealthCheckResponse;
import com.service.auth.AuthService;

import lombok.extern.slf4j.Slf4j;

import static org.assertj.core.api.Assertions.assertThat;
import static org.awaitility.Awaitility.await;

import java.time.Duration;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

@SpringBootTest
@ActiveProfiles("integrationtest")
@DisplayName("Kafka Integration Tests")
@DirtiesContext(classMode = DirtiesContext.ClassMode.AFTER_EACH_TEST_METHOD)
@Slf4j
public class KafkaIntegrationTest extends BaseIntegrationTest {

    @Autowired
    private AuthService authService;

    private Consumer<String, Object> responseConsumer;
    private String replyTopic;

    private String testEmail;

    @BeforeEach
    void setUpKafkaConsumer() {
        // Создаем уникальный топик для ответов для каждого теста
        String testId = UUID.randomUUID().toString().substring(0, 8);
        replyTopic = "auth.responses.test-" + testId;
        log.info("Using unique reply topic: {}", replyTopic);

        // Создаем топик заранее с нужным количеством партиций
        createTopic(replyTopic, 1);

        // Настройка consumer для получения ответов
        Map<String, Object> consumerProps = new HashMap<>();
        consumerProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:29093");
        // Уникальный group.id для каждого теста
        consumerProps.put(ConsumerConfig.GROUP_ID_CONFIG, "test-consumer-" + testId);
        consumerProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");
        consumerProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer.class);
        consumerProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer.class);

        // Конфигурация для JsonDeserializer
        consumerProps.put(JsonDeserializer.TRUSTED_PACKAGES,
                "com.connection.auth.events.commands," +
                        "com.connection.auth.events.responses," +
                        "com.connection.common.events," +
                        "com.connection.buffer.events.commands," +
                        "com.connection.buffer.events.responses," +
                        "com.connection.device.events.commands," +
                        "com.connection.device.events.responses," +
                        "com.connection.scheme.events.commands," +
                        "com.connection.scheme.events.responses");

        // Конфигурация для ErrorHandlingDeserializer
        consumerProps.put(ErrorHandlingDeserializer.KEY_DESERIALIZER_CLASS,
                org.apache.kafka.common.serialization.StringDeserializer.class);
        consumerProps.put(ErrorHandlingDeserializer.VALUE_DESERIALIZER_CLASS, JsonDeserializer.class);

        consumerProps.put(JsonDeserializer.USE_TYPE_INFO_HEADERS, true);
        consumerProps.put(JsonDeserializer.REMOVE_TYPE_INFO_HEADERS, false);
        consumerProps.put(JsonDeserializer.VALUE_DEFAULT_TYPE, "com.connection.common.events.Command");

        // Критически важные настройки для тестов
        consumerProps.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, 10000);
        consumerProps.put(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG, 3000);
        consumerProps.put(ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG, 30000);
        consumerProps.put(ConsumerConfig.REQUEST_TIMEOUT_MS_CONFIG, 15000);
        consumerProps.put(ConsumerConfig.FETCH_MAX_WAIT_MS_CONFIG, 500);
        consumerProps.put(ConsumerConfig.FETCH_MIN_BYTES_CONFIG, 1);
        consumerProps.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, false);

        DefaultKafkaConsumerFactory<String, Object> consumerFactory = new DefaultKafkaConsumerFactory<>(consumerProps);

        responseConsumer = consumerFactory.createConsumer();

        // Подписываемся ДО отправки сообщений
        responseConsumer.subscribe(Collections.singletonList(replyTopic));

        // Ждем инициализации consumer'а - более надежный способ
        await().atMost(Duration.ofSeconds(15))
                .pollInterval(Duration.ofMillis(500))
                .until(() -> {
                    responseConsumer.poll(Duration.ofMillis(100));
                    return !responseConsumer.assignment().isEmpty();
                });

        log.info("Kafka consumer setup completed for topic: {}, assigned partitions: {}",
                replyTopic, responseConsumer.assignment());
    }

    private void createTopic(String topicName, int partitions) {
        try {
            // Используем AdminClient для создания топика
            Map<String, Object> config = new HashMap<>();
            config.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:29093");

            try (AdminClient adminClient = AdminClient.create(config)) {
                NewTopic newTopic = new NewTopic(topicName, partitions, (short) 1);
                CreateTopicsResult result = adminClient.createTopics(Collections.singleton(newTopic));
                result.all().get(30, TimeUnit.SECONDS);
                log.info("Created topic: {}", topicName);
            }
        } catch (Exception e) {
            log.warn("Topic creation failed (might already exist): {}", e.getMessage());
        }
    }

    @AfterEach
    void tearDownKafkaConsumer() {
        // Очищаем данные после каждого теста
        if (testEmail != null) {
            cleanupClientData(testEmail);
            log.info("Cleaned up test data for email: {}", testEmail);
        }

        if (responseConsumer != null) {
            try {
                responseConsumer.unsubscribe();
                responseConsumer.close(Duration.ofSeconds(5));
                log.info("Kafka consumer closed for topic: {}", replyTopic);
            } catch (Exception e) {
                log.warn("Error closing Kafka consumer: {}", e.getMessage());
            }
        }
    }

    @Test
    @DisplayName("Should process HealthCheckCommand and return response")
    void shouldProcessHealthCheckCommand() {
    // Given
    String correlationId = UUID.randomUUID().toString();
    HealthCheckCommand command = HealthCheckCommand.builder()
    .correlationId(correlationId)
    .sourceService("test-service")
    .replyTopic(replyTopic)
    .build();

    log.info("Sending HealthCheckCommand with correlationId: {} to replyTopic:{}",
    correlationId, replyTopic);

    // When
    kafkaTemplate.send("auth.commands", correlationId, command);
    kafkaTemplate.flush();

    // Then
    await().atMost(Duration.ofSeconds(30))
    .pollInterval(Duration.ofMillis(500))
    .untilAsserted(() -> {
    ConsumerRecords<String, Object> records =
    responseConsumer.poll(Duration.ofMillis(2000));
    log.info("Polled {} records from topic: {}", records.count(), replyTopic);

    assertThat(records).isNotEmpty();

    // Ищем запись с нашим correlationId
    boolean found = false;
    for (ConsumerRecord<String, Object> record : records) {
    log.info("Checking record - key: {}, value type: {}",
    record.key(), record.value() != null ?
    record.value().getClass().getSimpleName() : "null");

    if (record.key().equals(correlationId) && record.value() instanceof
    HealthCheckResponse) {
    HealthCheckResponse response = (HealthCheckResponse) record.value();
    log.info("Found matching response: correlationId={}, success={}",
    response.getCorrelationId(), response.isSuccess());

    assertThat(response.getCorrelationId()).isEqualTo(correlationId);
    assertThat(response.isSuccess()).isTrue();
    assertThat(response.getHealthStatus()).isNotNull();
    assertThat(response.getHealthStatus().get("status")).isEqualTo("OK");
    assertThat(response.getHealthStatus().get("service")).isEqualTo("auth-service");
    found = true;
    break;
    }
    }

    assertThat(found).withFailMessage("Response with correlationId %s not found",
    correlationId).isTrue();
    });

    log.info("Successfully processed HealthCheckCommand with correlationId: {}",
    correlationId);
    }

    @Test
    @DisplayName("Should handle multiple HealthCheckCommands")
    void shouldHandleMultipleHealthCheckCommands() {
        // Given
        String correlationId1 = UUID.randomUUID().toString();
        String correlationId2 = UUID.randomUUID().toString();

        HealthCheckCommand command1 = HealthCheckCommand.builder()
                .correlationId(correlationId1)
                .sourceService("test-service")
                .replyTopic(replyTopic)
                .build();

        HealthCheckCommand command2 = HealthCheckCommand.builder()
                .correlationId(correlationId2)
                .sourceService("test-service")
                .replyTopic(replyTopic)
                .build();

        log.info("Sending multiple commands with correlationIds: {}, {} to replyTopic: {}",
                correlationId1, correlationId2, replyTopic);

        // When
        kafkaTemplate.send("auth.commands", correlationId1, command1);
        kafkaTemplate.send("auth.commands", correlationId2, command2);
        kafkaTemplate.flush();

        // Then - используем аккумулятивную проверку
        Map<String, HealthCheckResponse> receivedResponses = new ConcurrentHashMap<>();

        await().atMost(Duration.ofSeconds(30))
                .pollInterval(Duration.ofMillis(500))
                .untilAsserted(() -> {
                    ConsumerRecords<String, Object> records = responseConsumer.poll(Duration.ofMillis(2000));
                    log.info("Polled {} records from topic: {}", records.count(), replyTopic);

                    for (ConsumerRecord<String, Object> record : records) {
                        if (record.value() instanceof HealthCheckResponse) {
                            HealthCheckResponse response = (HealthCheckResponse) record.value();
                            receivedResponses.put(record.key(), response);
                            log.info("Received response for correlationId: {}, total received: {}",
                                    record.key(), receivedResponses.size());
                        }
                    }

                    // Коммитим оффсеты
                    if (!records.isEmpty()) {
                        responseConsumer.commitSync();
                    }

                    // Проверяем аккумулятивно - получили ли мы ВСЕ ожидаемые сообщения
                    assertThat(receivedResponses).hasSize(2);
                    assertThat(receivedResponses).containsKeys(correlationId1, correlationId2);

                    // Проверяем каждый ответ
                    HealthCheckResponse response1 = receivedResponses.get(correlationId1);
                    HealthCheckResponse response2 = receivedResponses.get(correlationId2);

                    assertThat(response1).isNotNull();
                    assertThat(response1.isSuccess()).isTrue();
                    assertThat(response1.getCorrelationId()).isEqualTo(correlationId1);

                    assertThat(response2).isNotNull();
                    assertThat(response2.isSuccess()).isTrue();
                    assertThat(response2.getCorrelationId()).isEqualTo(correlationId2);
                });

        log.info("Successfully handled multiple HealthCheckCommands. Total responses received: {}",
                receivedResponses.size());
    }

    @Test
    @DisplayName("Should handle commands sequentially")
    void shouldHandleCommandsSequentially() {
        // First command
        String correlationId1 = UUID.randomUUID().toString();
        HealthCheckCommand command1 = HealthCheckCommand.builder()
                .correlationId(correlationId1)
                .sourceService("sequential-test-1")
                .replyTopic(replyTopic)
                .build();

        log.info("Sending first command with correlationId: {}", correlationId1);

        kafkaTemplate.send("auth.commands", correlationId1, command1);
        kafkaTemplate.flush();

        // Wait for first response
        await().atMost(Duration.ofSeconds(15))
                .pollInterval(Duration.ofMillis(500))
                .untilAsserted(() -> {
                    ConsumerRecords<String, Object> records = responseConsumer.poll(Duration.ofMillis(2000));
                    boolean found = false;
                    for (ConsumerRecord<String, Object> record : records) {
                        if (record.key().equals(correlationId1) && record.value() instanceof HealthCheckResponse) {
                            HealthCheckResponse response = (HealthCheckResponse) record.value();
                            assertThat(response.isSuccess()).isTrue();
                            found = true;
                            break;
                        }
                    }
                    assertThat(found).isTrue();
                });

        log.info("First command processed successfully");

        // Second command
        String correlationId2 = UUID.randomUUID().toString();
        HealthCheckCommand command2 = HealthCheckCommand.builder()
                .correlationId(correlationId2)
                .sourceService("sequential-test-2")
                .replyTopic(replyTopic)
                .build();

        log.info("Sending second command with correlationId: {}", correlationId2);

        kafkaTemplate.send("auth.commands", correlationId2, command2);
        kafkaTemplate.flush();

        // Wait for second response
        await().atMost(Duration.ofSeconds(15))
                .pollInterval(Duration.ofMillis(500))
                .untilAsserted(() -> {
                    ConsumerRecords<String, Object> records = responseConsumer.poll(Duration.ofMillis(2000));
                    boolean found = false;
                    for (ConsumerRecord<String, Object> record : records) {
                        if (record.key().equals(correlationId2) && record.value() instanceof HealthCheckResponse) {
                            HealthCheckResponse response = (HealthCheckResponse) record.value();
                            assertThat(response.isSuccess()).isTrue();
                            found = true;
                            break;
                        }
                    }
                    assertThat(found).isTrue();
                });

        log.info("Second command processed successfully");
    }
}package com.service.auth.integration;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

import java.util.Date;
import java.util.UUID;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.util.Pair;
import org.springframework.test.context.ActiveProfiles;

import com.connection.client.model.ClientBLM;
import com.connection.client.repository.ClientRepository;
import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.RefreshTokenBLM;
import com.service.auth.AuthService;
import com.service.auth.mother.AuthObjectMother;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@SpringBootTest
@ActiveProfiles("integrationtest")
@DisplayName("Auth Service Integration Tests")
public class AuthServiceIntegrationTest extends BaseIntegrationTest {

    @Autowired
    private AuthService authService;

    @Autowired
    private ClientRepository clientRepository;

    private ClientBLM testClient;
    private String uniqueEmail;

    @BeforeEach
    void setUp() {
        String timestamp = String.valueOf(System.currentTimeMillis()) + UUID.randomUUID().toString().substring(0, 8);
        uniqueEmail = "integration_test_" + timestamp + "@example.com";
        
        testClient = new ClientBLM(
            UUID.randomUUID(),
            new Date(System.currentTimeMillis() - 25L * 365 * 24 * 60 * 60 * 1000),
            uniqueEmail,
            "SecurePassword123!" + timestamp,
            "integration_user_" + timestamp
        );
        
        log.info("Created test client with email: {}", uniqueEmail);
    }

    @AfterEach
    void cleanup() {
        // Очищаем данные после каждого теста
        if (uniqueEmail != null) {
            cleanupClientData(uniqueEmail);
            log.info("Cleaned up test data for email: {}", uniqueEmail);
        }
    }

    @Test
    @DisplayName("Should register client successfully")
    void shouldRegisterClientSuccessfully() {
        // When
        authService.register(testClient);

        // Then
        ClientBLM foundClient = clientRepository.findByEmail(uniqueEmail);
        assertThat(foundClient).isNotNull();
        assertThat(foundClient.getEmail()).isEqualTo(uniqueEmail);
        assertThat(foundClient.getUsername()).isEqualTo(testClient.getUsername());
        
        log.info("Successfully registered and found client: {}", uniqueEmail);
    }

    @Test
    @DisplayName("Should authorize by email and generate tokens")
    void shouldAuthorizeByEmailAndGenerateTokens() {
        // Given
        authService.register(testClient);

        // When
        Pair<AccessTokenBLM, RefreshTokenBLM> tokens = authService.authorizeByEmail(
            testClient.getEmail(), testClient.getPassword());

        // Then
        assertThat(tokens).isNotNull();
        assertThat(tokens.getFirst()).isNotNull();
        assertThat(tokens.getSecond()).isNotNull();
        
        AccessTokenBLM accessToken = tokens.getFirst();
        RefreshTokenBLM refreshToken = tokens.getSecond();
        
        assertThat(accessToken.getToken()).isNotBlank();
        assertThat(accessToken.getClientUID()).isEqualTo(testClient.getUid());
        assertThat(accessToken.getExpiresAt()).isAfter(new Date());
        
        assertThat(refreshToken.getToken()).isNotBlank();
        assertThat(refreshToken.getClientUID()).isEqualTo(testClient.getUid());
        assertThat(refreshToken.getExpiresAt()).isAfter(new Date());
        
        log.info("Successfully authorized and generated tokens for: {}", uniqueEmail);
    }

    @Test
    @DisplayName("Should refresh tokens successfully")
    void shouldRefreshTokensSuccessfully() {
        // Given
        authService.register(testClient);
        Pair<AccessTokenBLM, RefreshTokenBLM> originalTokens = authService.authorizeByEmail(
            uniqueEmail, testClient.getPassword());
        
        RefreshTokenBLM originalRefreshToken = originalTokens.getSecond();

        sleep(1000);
        // When
        Pair<AccessTokenBLM, RefreshTokenBLM> newTokens = authService.refresh(originalRefreshToken);

        // Then
        assertThat(newTokens).isNotNull();
        assertThat(newTokens.getFirst()).isNotNull();
        assertThat(newTokens.getSecond()).isNotNull();
        
        // Verify new tokens are different from original ones
        assertThat(newTokens.getFirst().getToken()).isNotEqualTo(originalTokens.getFirst().getToken());
        assertThat(newTokens.getSecond().getToken()).isNotEqualTo(originalTokens.getSecond().getToken());
        
        log.info("Successfully refreshed tokens for: {}", uniqueEmail);
    }

    @Test
    @DisplayName("Should validate access token successfully")
    void shouldValidateAccessTokenSuccessfully() {
        // Given
        authService.register(testClient);
        Pair<AccessTokenBLM, RefreshTokenBLM> tokens = authService.authorizeByEmail(
            uniqueEmail, testClient.getPassword());
        
        AccessTokenBLM accessToken = tokens.getFirst();

        // When & Then - Should not throw exception
        authService.validateAccessToken(accessToken);
        
        log.info("Successfully validated access token for: {}", uniqueEmail);
    }

    @Test
    @DisplayName("Should validate refresh token successfully")
    void shouldValidateRefreshTokenSuccessfully() {
        // Given
        authService.register(testClient);
        Pair<AccessTokenBLM, RefreshTokenBLM> tokens = authService.authorizeByEmail(
            uniqueEmail, testClient.getPassword());
        
        RefreshTokenBLM refreshToken = tokens.getSecond();

        // When & Then - Should not throw exception
        authService.validateRefreshToken(refreshToken);
        
        log.info("Successfully validated refresh token for: {}", uniqueEmail);
    }

    @Test
    @DisplayName("Should throw exception when authorizing with invalid credentials")
    void shouldThrowExceptionWhenAuthorizingWithInvalidCredentials() {
        // Given
        authService.register(testClient);

        // When & Then
        assertThatThrownBy(() -> authService.authorizeByEmail(uniqueEmail, "wrong_password"))
            .isInstanceOf(RuntimeException.class);
            
        log.info("Correctly rejected invalid credentials for: {}", uniqueEmail);
    }

    @Test
    @DisplayName("Should throw exception when refreshing with invalid token")
    void shouldThrowExceptionWhenRefreshingWithInvalidToken() {
        // Given
        RefreshTokenBLM invalidRefreshToken = AuthObjectMother.createExpiredRefreshTokenBLM();

        // When & Then
        assertThatThrownBy(() -> authService.refresh(invalidRefreshToken))
            .isInstanceOf(RuntimeException.class);
            
        log.info("Correctly rejected invalid refresh token");
    }
}package com.service.auth.integration;

import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.TestInstance;
import org.junit.jupiter.api.TestMethodOrder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.core.env.Environment;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.TestPropertySource;

import lombok.extern.slf4j.Slf4j;


@ActiveProfiles("integrationtest")
@TestPropertySource(locations = "classpath:application-integrationtest.properties", properties = {
        "spring.config.location=classpath:application-integrationtest.properties",
        "spring.config.name=application-integrationtest"
})
@TestMethodOrder(MethodOrderer.Random.class)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@Slf4j
public abstract class BaseIntegrationTest {

    @Autowired
    protected Environment environment;

    protected TestRestTemplate restTemplate = new TestRestTemplate();

    @Autowired
    protected KafkaTemplate<String, Object> kafkaTemplate;

    @Autowired
    @Qualifier("ClientJdbcTemplate")
    protected NamedParameterJdbcTemplate clientJdbcTemplate;

    @Autowired
    @Qualifier("RefreshTokenJdbcTemplate")
    protected NamedParameterJdbcTemplate refreshTokenJdbcTemplate;

    protected String baseUrl;
    protected final Map<String, String> testData = new ConcurrentHashMap<>();

    @BeforeEach
    void checkConfig() {
        log.info("Active profiles: {}", Arrays.toString(environment.getActiveProfiles()));
        log.info("Kafka servers: {}", environment.getProperty("spring.kafka.bootstrap-servers"));
        log.info("Database URLs: client={}, refresh-token={}", 
            environment.getProperty("app.datasource.client.xa-properties.url"),
            environment.getProperty("app.datasource.refresh-token.xa-properties.url"));
    }

    @AfterEach
    void tearDown() {
        // Базовая очистка, может быть переопределена в наследниках
        testData.clear();
    }

    protected void cleanupClientData(String email) {
        try {
            log.info("Cleaning up data for email: {}", email);

            // Сначала удаляем refresh tokens из схемы access
            String deleteTokensSql = "DELETE FROM \"access\".refresh_token WHERE client_id IN (SELECT uid FROM core.client WHERE email = :email)";
            int tokensDeleted = refreshTokenJdbcTemplate.update(deleteTokensSql, Map.of("email", email));
            if (tokensDeleted > 0) {
                log.info("Deleted {} refresh tokens for email: {}", tokensDeleted, email);
            }

            // Затем удаляем клиента из схемы core
            String deleteClientSql = "DELETE FROM core.client WHERE email = :email";
            int clientsDeleted = clientJdbcTemplate.update(deleteClientSql, Map.of("email", email));
            if (clientsDeleted > 0) {
                log.info("Deleted {} clients for email: {}", clientsDeleted, email);
            }

            // Дополнительная очистка связанных данных на всякий случай
            try {
                // Очистка device tokens
                String deleteDeviceTokensSql = "DELETE FROM \"access\".device_token WHERE device_uid IN (SELECT uid FROM core.device WHERE client_uuid IN (SELECT uid FROM core.client WHERE email = :email))";
                refreshTokenJdbcTemplate.update(deleteDeviceTokensSql, Map.of("email", email));

                // Очистка devices
                String deleteDevicesSql = "DELETE FROM core.device WHERE client_uuid IN (SELECT uid FROM core.client WHERE email = :email)";
                clientJdbcTemplate.update(deleteDevicesSql, Map.of("email", email));

                // Очистка connection schemes
                String deleteSchemesSql = "DELETE FROM processing.connection_scheme WHERE client_uid IN (SELECT uid FROM core.client WHERE email = :email)";
                clientJdbcTemplate.update(deleteSchemesSql, Map.of("email", email));

            } catch (Exception e) {
                log.debug("Optional cleanup failed (tables might not exist): {}", e.getMessage());
            }

        } catch (Exception e) {
            log.warn("Cleanup warning for email {}: {}", email, e);
        }
    }

    protected void sleep(long milliseconds) {
        try {
            log.debug("Sleeping for {} ms", milliseconds);
            TimeUnit.MILLISECONDS.sleep(milliseconds);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.warn("Sleep interrupted", e);
        }
    }

    protected HttpEntity<Object> createHttpEntity(Object body) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        return new HttpEntity<>(body, headers);
    }
}package com.service.auth.mother;

import java.util.Date;
import java.util.UUID;

import com.connection.client.model.ClientBLM;
import com.connection.client.model.ClientDALM;
import com.connection.client.model.ClientDTO;
import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.RefreshTokenBLM;

public class AuthObjectMother {

    public static final UUID CLIENT_UUID = UUID.fromString("123e4567-e89b-12d3-a456-426614174000");
    public static final UUID REFRESH_TOKEN_UUID = UUID.fromString("323e4567-e89b-12d3-a456-426614174002");
    public static final String VALID_EMAIL = "test@example.com";
    public static final String VALID_PASSWORD = "securePassword123";
    public static final String VALID_USERNAME = "testuser";
    public static final Date BIRTH_DATE = new Date(System.currentTimeMillis() - 25L * 365 * 24 * 60 * 60 * 1000); // 25 years ago

    public static ClientDTO randomValidClientDTO() {
        String timestamp = String.valueOf(System.currentTimeMillis());
        String threadId = String.valueOf(Thread.currentThread().getId());
        String uniqueSuffix = timestamp + "_" + threadId;

        return new ClientDTO(
            UUID.randomUUID(),
            new Date(System.currentTimeMillis() - 25L * 365 * 24 * 60 * 60 * 1000),
            "test_" + uniqueSuffix + "@example.com",
            "Password123!" + uniqueSuffix,
            "user_" + uniqueSuffix
        );
    }

    public static ClientBLM randomValidClientBLM() {
        String timestamp = String.valueOf(System.currentTimeMillis());
        String threadId = String.valueOf(Thread.currentThread().getId());
        String uniqueSuffix = timestamp + "_" + threadId;

        return new ClientBLM(
            UUID.randomUUID(),
            new Date(System.currentTimeMillis() - 25L * 365 * 24 * 60 * 60 * 1000),
            "test_" + uniqueSuffix + "@example.com",
            "Password123!" + uniqueSuffix,
            "user_" + uniqueSuffix
        );
    }

    public static ClientBLM createValidClientBLM() {
        return new ClientBLM(
            CLIENT_UUID,
            BIRTH_DATE,
            VALID_EMAIL,
            VALID_PASSWORD,
            VALID_USERNAME
        );
    }

    public static ClientDALM createValidClientDALM() {
        return new ClientDALM(
            CLIENT_UUID,
            BIRTH_DATE,
            VALID_EMAIL,
            VALID_PASSWORD,
            VALID_USERNAME
        );
    }

    public static AccessTokenBLM createValidAccessTokenBLM() {
        Date createdAt = new Date();
        Date expiresAt = new Date(createdAt.getTime() + 600000); // 10 minutes
        String tokenString = "valid.access.token.string";
        
        return new AccessTokenBLM(
            tokenString,
            CLIENT_UUID,
            createdAt,
            expiresAt
        );
    }

    public static RefreshTokenBLM createValidRefreshTokenBLM() {
        Date createdAt = new Date();
        Date expiresAt = new Date(createdAt.getTime() + 86400000); // 24 hours
        String tokenString = "valid.refresh.token.string";
        
        return new RefreshTokenBLM(
            tokenString,
            REFRESH_TOKEN_UUID,
            CLIENT_UUID,
            createdAt,
            expiresAt
        );
    }

    public static RefreshTokenBLM createExpiredRefreshTokenBLM() {
        Date createdAt = new Date(System.currentTimeMillis() - 86400000); // 24 hours ago
        Date expiresAt = new Date(createdAt.getTime() + 3600000); // 1 hour, already expired
        String tokenString = "expired.refresh.token.string";
        
        return new RefreshTokenBLM(
            tokenString,
            REFRESH_TOKEN_UUID,
            CLIENT_UUID,
            createdAt,
            expiresAt
        );
    }
}