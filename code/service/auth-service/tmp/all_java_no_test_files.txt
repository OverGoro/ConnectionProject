package com.connection.service.auth.config;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;


import com.connection.token.repository.RefreshTokenReactiveRepositoryImpl;
import com.connection.token.repository.RefreshTokenRepository;
import com.connection.token.repository.RefreshTokenRepositorySQLImpl;

import io.r2dbc.spi.ConnectionFactory;

@Configuration
@ConditionalOnProperty(name = "app.controller.mode", havingValue = "mvc", matchIfMissing = true)
public class RefreshTokenRepositoryConfig {
    @Bean("RefreshTokenRepository")
    RefreshTokenRepository refreshTokenRepository(@Qualifier("RefreshTokenJdbcTemplate")NamedParameterJdbcTemplate template){
        return new RefreshTokenRepositorySQLImpl(template);
    }

}
package com.connection.service.auth.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.connection.client.converter.ClientConverter;
import com.connection.client.validator.ClientValidator;


@Configuration
public class ClientUtilsConfig {
    @Bean("ClientConverter")
    ClientConverter clientConverter(){
        return new ClientConverter();
    }

    @Bean("ClientValidator")
    ClientValidator clientValidator(){
        return new ClientValidator();
    }
}
package com.connection.service.auth.config.kafka;

import java.util.HashMap;
import java.util.Map;

import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.clients.producer.ProducerConfig;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.core.ConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaProducerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.core.ProducerFactory;
import org.springframework.kafka.listener.DefaultErrorHandler;
import org.springframework.kafka.support.serializer.ErrorHandlingDeserializer;
import org.springframework.kafka.support.serializer.JsonDeserializer;
import org.springframework.kafka.support.serializer.JsonSerializer;
import org.springframework.util.backoff.FixedBackOff;

@Configuration
public class KafkaConfig {

    @Value("${spring.kafka.bootstrap-servers:localhost:29092}")
    private String bootstrapServers;

    // Конфигурация для Consumer с обработкой ошибок десериализации
    @Bean
    public ConsumerFactory<String, Object> consumerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        configProps.put(ConsumerConfig.GROUP_ID_CONFIG, "auth-service-group"); // Изменено на auth-service-group
        configProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");
        configProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer.class);
        configProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer.class);

        // Конфигурация для JsonDeserializer
        configProps.put(JsonDeserializer.TRUSTED_PACKAGES,
                "com.connection.auth.events.commands," +
                        "com.connection.auth.events.responses," +
                        "com.connection.common.events");

        // Конфигурация для ErrorHandlingDeserializer (как в BufferKafkaConfig)
        configProps.put(ErrorHandlingDeserializer.KEY_DESERIALIZER_CLASS,
                org.apache.kafka.common.serialization.StringDeserializer.class);
        configProps.put(ErrorHandlingDeserializer.VALUE_DESERIALIZER_CLASS, JsonDeserializer.class);

        configProps.put(JsonDeserializer.USE_TYPE_INFO_HEADERS, true);
        configProps.put(JsonDeserializer.REMOVE_TYPE_INFO_HEADERS, false);
        configProps.put(JsonDeserializer.VALUE_DEFAULT_TYPE, "com.connection.common.events.Command");

        return new DefaultKafkaConsumerFactory<>(configProps);
    }

    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, Object> kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory<String, Object> factory = new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory());

        // Обработка ошибок десериализации - пропускаем некорректные сообщения (как в
        // BufferKafkaConfig)
        DefaultErrorHandler errorHandler = new DefaultErrorHandler(
                (record, exception) -> {
                    org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger("KafkaErrorHandler");
                    logger.error(
                            "Skipping invalid message - Topic: {}, Partition: {}, Offset: {}, Key: {}, Error: {}, {}",
                            record.topic(),
                            record.partition(),
                            record.offset(),
                            record.key(),
                            exception.getMessage(),
                            exception.toString());
                },
                new FixedBackOff(0L, 0L));

        factory.setCommonErrorHandler(errorHandler);

        return factory;
    }

    // Конфигурация для Producer (как в BufferKafkaConfig)
    @Bean
    public ProducerFactory<String, Object> producerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,
                org.apache.kafka.common.serialization.StringSerializer.class);
        configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
        configProps.put(JsonSerializer.ADD_TYPE_INFO_HEADERS, true);
        return new DefaultKafkaProducerFactory<>(configProps);
    }

    @Bean
    public KafkaTemplate<String, Object> kafkaTemplate() {
        return new KafkaTemplate<>(producerFactory());
    }
}package com.connection.service.auth.config.spring;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ApplicationConfig {
    @Value("${spring.application.name:auth-service}")
    private String appNameString;

    @Bean
    @Qualifier("appName")
    String appName(){
        return appNameString;
    }
}
package com.connection.service.auth.config;

import java.util.Properties;

import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.zaxxer.hikari.HikariDataSource;

@Configuration
@ConditionalOnProperty(name = "app.controller.mode", havingValue = "mvc", matchIfMissing = true)
public class RefreshTokenJDBCConfig {
    
    @Value("${app.datasource.refresh-token.driver-class-name:org.postgresql.Driver}")
    private String driverClassName;

    @Value("${app.datasource.refresh-token.jdbc-url}")
    private String jdbcUrl;

    @Value("${app.datasource.refresh-token.username}")
    private String username;

    @Value("${app.datasource.refresh-token.password}")
    private String password;

    @Value("${app.datasource.refresh-token.maximum-pool-size:10}")
    private int maximumPoolSize;

    @Value("${app.datasource.refresh-token.minimum-idle:2}")
    private int minimumIdle;

    @Value("${app.datasource.refresh-token.connection-timeout:30000}")
    private int connectionTimeout;

    @Value("${app.datasource.refresh-token.idle-timeout:60000}")
    private int idleTimeout;

    @Value("${app.datasource.refresh-token.max-lifetime:120000}")
    private int maxLifetime;

    @Value("${app.datasource.refresh-token.connection-test-query:SELECT 1}")
    private String connectionTestQuery;

    @Value("${app.datasource.refresh-token.pool-name:refresh-token-ds}")
    private String poolName;

    @Value("${app.datasource.refresh-token.leak-detection-threshold:60000}")
    private long leakDetectionThreshold;

    @Bean("RefreshTokenDataSource")
    DataSource refreshTokenDataSource() {
        HikariDataSource dataSource = new HikariDataSource();

        // Базовые настройки подключения
        dataSource.setDriverClassName(driverClassName);
        dataSource.setJdbcUrl(jdbcUrl);
        dataSource.setUsername(username);
        dataSource.setPassword(password);

        // Настройки пула
        dataSource.setPoolName(poolName);
        dataSource.setMaximumPoolSize(maximumPoolSize);
        dataSource.setMinimumIdle(minimumIdle);
        dataSource.setConnectionTimeout(connectionTimeout);
        dataSource.setIdleTimeout(idleTimeout);
        dataSource.setMaxLifetime(maxLifetime);
        
        // Настройки валидации
        dataSource.setConnectionTestQuery(connectionTestQuery);
        dataSource.setValidationTimeout(5000);

        // Дополнительные настройки
        dataSource.setLeakDetectionThreshold(leakDetectionThreshold);
        dataSource.setInitializationFailTimeout(1);

        return dataSource;
    }

    @Bean("RefreshTokenJdbcTemplate")
    NamedParameterJdbcTemplate refreshTokenNamedParameterJdbcTemplate(
            @Qualifier("RefreshTokenDataSource") DataSource refreshTokenDataSource) {
        return new NamedParameterJdbcTemplate(refreshTokenDataSource);
    }
}package com.connection.service.auth.config;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;

import io.r2dbc.pool.ConnectionPool;
import io.r2dbc.pool.ConnectionPoolConfiguration;
import io.r2dbc.postgresql.PostgresqlConnectionConfiguration;
import io.r2dbc.postgresql.PostgresqlConnectionFactory;
import io.r2dbc.spi.ConnectionFactory;

import java.time.Duration;

@Configuration
public class R2DBCConfig {

    @Value("${app.datasource.client.jdbc-url}")
    private String clientJdbcUrl;
    
    @Value("${app.datasource.client.username}")
    private String clientUsername;
    
    @Value("${app.datasource.client.password}")
    private String clientPassword;
    
    @Value("${app.datasource.refresh-token.jdbc-url}")
    private String refreshTokenJdbcUrl;
    
    @Value("${app.datasource.refresh-token.username}")
    private String refreshTokenUsername;
    
    @Value("${app.datasource.refresh-token.password}")
    private String refreshTokenPassword;

    @Bean
    @Primary
    public ConnectionFactory clientConnectionFactory() {
        PostgresqlConnectionConfiguration config = PostgresqlConnectionConfiguration.builder()
                .host(extractHost(clientJdbcUrl))
                .port(extractPort(clientJdbcUrl))
                .database(extractDatabase(clientJdbcUrl))
                .username(clientUsername)
                .password(clientPassword)
                .build();
                
        return new PostgresqlConnectionFactory(config);
    }

    private String extractHost(String jdbcUrl) {
        // jdbc:postgresql://localhost:5432/database
        String[] parts = jdbcUrl.split("://")[1].split(":")[0].split("/");
        return parts[0];
    }

    private int extractPort(String jdbcUrl) {
        String[] parts = jdbcUrl.split("://")[1].split(":")[1].split("/");
        return Integer.parseInt(parts[0]);
    }

    private String extractDatabase(String jdbcUrl) {
        String[] parts = jdbcUrl.split("://")[1].split("/");
        return parts[1];
    }

    @Bean("clientConnectionPool")
    public ConnectionPool clientConnectionPool(
            ConnectionFactory connectionFactory) {
        
        ConnectionPoolConfiguration poolConfig = ConnectionPoolConfiguration.builder(connectionFactory)
                .maxIdleTime(Duration.ofMinutes(30))
                .maxSize(50) // Увеличьте максимальный размер пула
                .maxAcquireTime(Duration.ofSeconds(30)) // Увеличьте время ожидания соединения
                .maxCreateConnectionTime(Duration.ofSeconds(10))
                .initialSize(10) // Увеличьте начальный размер
                .acquireRetry(3) // Добавьте повторные попытки
                .build();
                
        return new ConnectionPool(poolConfig);
    }

    @Bean("refreshTokenConnectionPool")
    public ConnectionPool refreshTokenConnectionPool(
            ConnectionFactory connectionFactory) {
        
        ConnectionPoolConfiguration poolConfig = ConnectionPoolConfiguration.builder(connectionFactory)
                .maxIdleTime(Duration.ofMinutes(30))
                .maxSize(50) // Увеличьте максимальный размер пула
                .maxAcquireTime(Duration.ofSeconds(30))
                .maxCreateConnectionTime(Duration.ofSeconds(10))
                .initialSize(10)
                .acquireRetry(3)
                .build();
                
        return new ConnectionPool(poolConfig);
    }
}package com.connection.service.auth.config;

import java.util.Properties;

import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.zaxxer.hikari.HikariDataSource;

@Configuration
@ConditionalOnProperty(name = "app.controller.mode", havingValue = "mvc", matchIfMissing = true)
public class ClientJDBCConfig {
    
    @Value("${app.datasource.client.driver-class-name:org.postgresql.Driver}")
    private String driverClassName;

    @Value("${app.datasource.client.jdbc-url}")
    private String jdbcUrl;

    @Value("${app.datasource.client.username}")
    private String username;

    @Value("${app.datasource.client.password}")
    private String password;

    @Value("${app.datasource.client.maximum-pool-size:10}")
    private int maximumPoolSize;

    @Value("${app.datasource.client.minimum-idle:2}")
    private int minimumIdle;

    @Value("${app.datasource.client.connection-timeout:30000}")
    private int connectionTimeout;

    @Value("${app.datasource.client.idle-timeout:600000}")
    private int idleTimeout;

    @Value("${app.datasource.client.max-lifetime:1200000}")
    private int maxLifetime;

    @Value("${app.datasource.client.connection-test-query:SELECT 1}")
    private String connectionTestQuery;

    @Value("${app.datasource.client.pool-name:client-ds}")
    private String poolName;

    @Bean("ClientDataSource")
    DataSource clientDataSource() {
        HikariDataSource dataSource = new HikariDataSource();

        // Базовые настройки подключения
        dataSource.setDriverClassName(driverClassName);
        dataSource.setJdbcUrl(jdbcUrl);
        dataSource.setUsername(username);
        dataSource.setPassword(password);

        // Настройки пула
        dataSource.setPoolName(poolName);
        dataSource.setMaximumPoolSize(maximumPoolSize);
        dataSource.setMinimumIdle(minimumIdle);
        dataSource.setConnectionTimeout(connectionTimeout);
        dataSource.setIdleTimeout(idleTimeout);
        dataSource.setMaxLifetime(maxLifetime);
        
        // Настройки валидации
        dataSource.setConnectionTestQuery(connectionTestQuery);
        dataSource.setValidationTimeout(5000);

        // Дополнительные настройки
        dataSource.setLeakDetectionThreshold(60000);
        dataSource.setInitializationFailTimeout(1);

        return dataSource;
    }

    @Bean("ClientJdbcTemplate")
    NamedParameterJdbcTemplate clientNamedParameterJdbcTemplate(
            @Qualifier("ClientDataSource") DataSource clientDataSource) {
        return new NamedParameterJdbcTemplate(clientDataSource);
    }
}package com.connection.service.auth.config;

import java.nio.charset.StandardCharsets;
import java.time.Duration;

import javax.crypto.SecretKey;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import io.jsonwebtoken.security.MacAlgorithm;

@Configuration
public class AuthJwtConfig {
    @Value("${JWT_KEY:${app.jwt.key:zbhcWhLNkuwmbgJBdLKQU5tEArWPrWyMHrenwYT7e9c}}")
    private String jwtSecretString;

    @Value("AuthToken")
    private String jwtSubjectString;

    @Value("${ACCESS_TOKEN_EXPIRATION:${app.jwt.access-token.expiration:600}}")
    private long accessTokenExpiration;
    
    @Value("${REFRESH_TOKEN_EXPIRATION:${app.jwt.refresh-token.expiration:86400}}")
    private long refreshTokenExpiration;

    private final MacAlgorithm jwtAlgorithmMacAlgorithm = Jwts.SIG.HS256;

    @Bean("jwtSecretKey")
    SecretKey jwtSecretKey() {
        return createSecretKeyFromString(jwtSecretString, jwtAlgorithmMacAlgorithm);
    }

    @Bean("jwtSubject")
    String jwtSubject(){
        return jwtSecretString;
    }

    @Bean("jwtAccessTokenExpiration")
    Duration jwtAccessTokenDuration(){
        return Duration.ofSeconds(accessTokenExpiration);
    }

    @Bean("jwtRefreshTokenExpiration")
    Duration jwtRefreshTokenDuration(){
        return Duration.ofSeconds(refreshTokenExpiration);
    }
    
    @Bean("jwtAlghorithm")
    MacAlgorithm jwtAlgorithmMacAlgorithm(){
        return jwtAlgorithmMacAlgorithm;
    }

    private SecretKey createSecretKeyFromString(String secretString, MacAlgorithm algorithm) {
        byte[] keyBytes = secretString.getBytes(StandardCharsets.UTF_8);
        return Keys.hmacShaKeyFor(keyBytes);
    }


}
// package com.connection.service.auth.config.transaction;

// import java.util.UUID;

// import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
// import org.springframework.context.annotation.Bean;
// import org.springframework.context.annotation.Configuration;
// import org.springframework.transaction.jta.JtaTransactionManager;

// import com.atomikos.icatch.jta.UserTransactionManager;

// import jakarta.transaction.SystemException;

// @Configuration
// @ConditionalOnProperty(name = "app.transaction.mode", havingValue = "atomikos")
// public class TransactionConfig {

//     @Bean
//     public UserTransactionManager userTransactionManager() throws SystemException {
//         setPropertyIfNotExists("com.atomikos.icatch.log_base_name",
//                 "atomikos-tm-" + UUID.randomUUID().toString().substring(0, 8));
//         setPropertyIfNotExists("com.atomikos.icatch.log_base_dir", "./logs");
//         setPropertyIfNotExists("com.atomikos.icatch.tm_unique_name",
//                 "tm-" + UUID.randomUUID().toString().substring(0, 8));

//         setPropertyIfNotExists("com.atomikos.icatch.oltp_max_retries", "3"); // Максимум 3 попытки
//         setPropertyIfNotExists("com.atomikos.icatch.oltp_retry_interval", "250"); // 5 секунд между попытками
//         setPropertyIfNotExists("com.atomikos.icatch.max_timeout", "1000"); // 30 секунд общий таймаут
//         setPropertyIfNotExists("com.atomikos.icatch.default_jta_timeout", "300"); // 10 секунд на транзакцию
    

//         UserTransactionManager manager = new UserTransactionManager();

//         manager.setForceShutdown(true);
//         manager.setTransactionTimeout(1);

//         return manager;
//     }

//     @Bean(name = "atomicosTransactionManager")
//     public JtaTransactionManager jtaTransactiojnManager() throws SystemException {
//         JtaTransactionManager jtaTransactionManager = new JtaTransactionManager();
//         jtaTransactionManager.setTransactionManager(userTransactionManager());
//         jtaTransactionManager.setDefaultTimeout(1);
//         return jtaTransactionManager;
//     }

//     /**
//      * Устанавливает системное свойство только если оно еще не было установлено
//      * 
//      * @param key   ключ свойства
//      * @param value значение свойства
//      */
//     private void setPropertyIfNotExists(String key, String value) {
//         if (System.getProperty(key) == null) {
//             System.setProperty(key, value);
//             System.out.println("Set property: " + key + " = " + value);
//         } else {
//             System.out.println("Property already set: " + key + " = " + System.getProperty(key));
//         }
//     }
// }package com.connection.service.auth.config;

import javax.crypto.SecretKey;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.connection.token.converter.RefreshTokenConverter;
import com.connection.token.generator.RefreshTokenGenerator;
import com.connection.token.validator.RefreshTokenValidator;

@Configuration
public class RefreshTokenUtilsConfig {

    @Bean("RefreshTokenValidator")
    RefreshTokenValidator refreshTokenValidator(){
        return new RefreshTokenValidator();
    }

    @Bean("RefreshTokenGenerator")
    RefreshTokenGenerator refreshTokenGenerator(
            @Qualifier("jwtSecretKey") SecretKey secretKey,
            @Qualifier("appName") String appNameString,
            @Qualifier("jwtSubject") String subjecString) {
        return new RefreshTokenGenerator(secretKey, appNameString, subjecString);
    }

    @Bean("RefreshTokenConverter")
    RefreshTokenConverter refreshTokenConverter(
            @Qualifier("RefreshTokenGenerator") RefreshTokenGenerator refreshTokenGenerator) {
        return new RefreshTokenConverter(refreshTokenGenerator);
    }
}
package com.connection.service.auth.config;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.connection.client.converter.ClientConverter;
import com.connection.client.repository.ClientReactiveRepositoryImpl;
import com.connection.client.repository.ClientRepository;
import com.connection.client.repository.ClientRepositorySQLImpl;

import io.r2dbc.pool.ConnectionPool;
import io.r2dbc.spi.ConnectionFactory;

@Configuration
@ConditionalOnProperty(name = "app.controller.mode", havingValue = "webflux")
public class ClientRepositoryReactiveConfig {
    
    @Bean("ClientRepository")
    ClientRepository clientWebFluxRepository(
        @Qualifier("clientConnectionPool") ConnectionPool connectionPool // Используем пул
    ){
        return new ClientReactiveRepositoryImpl(connectionPool);
    }
}
package com.connection.service.auth.config;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.connection.client.converter.ClientConverter;
import com.connection.client.repository.ClientReactiveRepositoryImpl;
import com.connection.client.repository.ClientRepository;
import com.connection.client.repository.ClientRepositorySQLImpl;


import io.r2dbc.spi.ConnectionFactory;

@Configuration
@ConditionalOnProperty(name = "app.controller.mode", havingValue = "mvc", matchIfMissing = true)
public class ClientRepositoryConfig {
    @Bean("ClientRepository")
    ClientRepository clientRepository(@Qualifier("ClientJdbcTemplate")NamedParameterJdbcTemplate template){
        return new ClientRepositorySQLImpl(template);
    }

}
package com.connection.service.auth.config;

import javax.crypto.SecretKey;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.connection.token.converter.AccessTokenConverter;
import com.connection.token.generator.AccessTokenGenerator;
import com.connection.token.validator.AccessTokenValidator;
@Configuration
public class AccessTokenUtilsConfig {
    @Bean("AccessTokenValidator")
    AccessTokenValidator accessTokenValidator() {
        return new AccessTokenValidator();
    }

    @Bean("AccessTokenGenerator")
    AccessTokenGenerator accessTokenGenerator(
            @Qualifier("jwtSecretKey") SecretKey secretKey,
            @Qualifier("appName") String appNameString,
            @Qualifier("jwtSubject") String subjecString) {
        return new AccessTokenGenerator(secretKey, appNameString, subjecString);
    }

    @Bean("AccessTokenConverter")
    AccessTokenConverter accessTokenConverter(
            @Qualifier("AccessTokenGenerator") AccessTokenGenerator accessTokenGenerator) {
        return new AccessTokenConverter(accessTokenGenerator);
    }

}
package com.connection.service.auth.config;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;


import com.connection.token.repository.RefreshTokenReactiveRepositoryImpl;
import com.connection.token.repository.RefreshTokenRepository;
import com.connection.token.repository.RefreshTokenRepositorySQLImpl;

import io.r2dbc.pool.ConnectionPool;
import io.r2dbc.spi.ConnectionFactory;

@Configuration
@ConditionalOnProperty(name = "app.controller.mode", havingValue = "webflux")
public class RefreshTokenRepositoryReactiveConfig {

    @Bean("RefreshTokenRepository")
    RefreshTokenRepository refreshTokenRepository(
        @Qualifier("refreshTokenConnectionPool") ConnectionPool connectionPool // Используем пул
    ){
        return new RefreshTokenReactiveRepositoryImpl(connectionPool);
    }
}
package com.connection.service.auth.controller;

import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import com.connection.client.converter.ClientConverter;
import com.connection.client.model.ClientBLM;
import com.connection.client.model.ClientDTO;
import com.connection.client.validator.ClientValidator;
import com.connection.service.auth.AuthService;
import com.connection.service.auth.controller.model.HealthResponse;
import com.connection.service.auth.controller.model.LoginRequest;
import com.connection.service.auth.controller.model.LoginResponse;
import com.connection.service.auth.controller.model.RefreshTokenRequest;
import com.connection.service.auth.controller.model.RegistrationResponse;
import com.connection.service.auth.controller.model.ValidationResponse;
import com.connection.token.converter.AccessTokenConverter;
import com.connection.token.converter.RefreshTokenConverter;
import com.connection.token.exception.BaseTokenException;
import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.AccessTokenDTO;
import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDTO;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Mono;

@Slf4j
@RestController
@RequiredArgsConstructor
@ConditionalOnProperty(name = "app.controller.mode", havingValue = "mvc", matchIfMissing = true)
@RequestMapping("/api/v1/auth")
@Tag(name = "Auth Service", description = "Authentication and Authorization APIs (MVC)")
public class AuthServiceController implements AuthController {

    private final AccessTokenConverter accessTokenConverter;
    private final RefreshTokenConverter refreshTokenConverter;
    private final ClientConverter clientConverter;
    private final ClientValidator clientValidator;
    private final AuthService authService;

    @Operation(summary = "Register new client", description = "Register a new client in the system")
    @ApiResponse(responseCode = "200", description = "Client registered successfully", content = @Content(schema = @Schema(implementation = RegistrationResponse.class)))
    @PostMapping("/register")
    public Mono<ResponseEntity<RegistrationResponse>> register(
            @Parameter(description = "Client data", required = true) @RequestBody ClientDTO clientDTO) {
        
        return Mono.fromCallable(() -> {
            clientValidator.validate(clientDTO);
            return clientConverter.toBLM(clientDTO);
        })
        .flatMap(authService::register)
        .then(Mono.fromCallable(() -> {
            log.info("Client registered successfully: {}", clientDTO.getUid());
            return ResponseEntity.ok(new RegistrationResponse(
                    "User registered successfully",
                    clientDTO.getEmail()));
        }))
        .onErrorResume(throwable -> {
            log.error("Registration failed for email: {}", clientDTO.getEmail(), throwable);
            return Mono.just(ResponseEntity.badRequest().build());
        });
    }

    @Operation(summary = "Login by email", description = "Authenticate client using email and password")
    @ApiResponse(responseCode = "201", description = "Login successful", content = @Content(schema = @Schema(implementation = LoginResponse.class)))
    @PostMapping("/login")
    public Mono<ResponseEntity<LoginResponse>> loginByEmail(
            @io.swagger.v3.oas.annotations.parameters.RequestBody(description = "Login credentials", required = true, content = @Content(schema = @Schema(implementation = LoginRequest.class))) @RequestBody LoginRequest loginRequest) {
        
        return authService.authorizeByEmail(loginRequest.getEmail(), loginRequest.getPassword())
                .map(tokens -> {
                    log.info("Login successful for email: {}", loginRequest.getEmail());
                    return ResponseEntity.ok(new LoginResponse(
                            tokens.getFirst().getToken(),
                            tokens.getSecond().getToken(),
                            tokens.getFirst().getExpiresAt(),
                            tokens.getSecond().getExpiresAt(),
                            tokens.getFirst().getClientUID()));
                })
                .onErrorResume(throwable -> {
                    log.error("Login failed for email: {}", loginRequest.getEmail(), throwable);
                    return Mono.just(ResponseEntity.badRequest().build());
                });
    }

    @Operation(summary = "Refresh tokens", description = "Get new access and refresh tokens using refresh token")
    @ApiResponse(responseCode = "201", description = "Tokens refreshed successfully", content = @Content(schema = @Schema(implementation = LoginResponse.class)))
    @PostMapping("/refresh")
    public Mono<ResponseEntity<LoginResponse>> refreshToken(
            @Parameter(description = "Refresh token request", required = true) @RequestBody RefreshTokenRequest refreshRequest) {
        
        return Mono.fromCallable(() -> {
            RefreshTokenDTO refreshTokenDTO = new RefreshTokenDTO(refreshRequest.getRefreshToken());
            return refreshTokenConverter.toBLM(refreshTokenDTO);
        })
        .flatMap(authService::refresh)
        .map(newTokens -> {
            log.info("Token refresh successful");
            return ResponseEntity.ok(new LoginResponse(
                    newTokens.getFirst().getToken(),
                    newTokens.getSecond().getToken(),
                    newTokens.getFirst().getExpiresAt(),
                    newTokens.getSecond().getExpiresAt(),
                    newTokens.getFirst().getClientUID()));
        })
        .onErrorResume(BaseTokenException.class, e -> {
            log.error("Token refresh failed", e);
            return Mono.just(ResponseEntity.badRequest().build());
        });
    }

    @Operation(summary = "Health check", description = "Check service health")
    @ApiResponse(responseCode = "200", description = "Service is healthy", content = @Content(schema = @Schema(implementation = HealthResponse.class)))
    @GetMapping("/health")
    public Mono<ResponseEntity<HealthResponse>> healthCheck() {
        return authService.getHealthStatus()
                .map(healthMap -> {
                    log.info("Health check: status: OK, service: auth-service, timestamp: {}",
                            System.currentTimeMillis());
                    return ResponseEntity.ok(new HealthResponse(
                            "OK",
                            "auth-service",
                            System.currentTimeMillis()));
                });
    }

    @Operation(summary = "Validate access token", description = "Check if access token is valid")
    @ApiResponse(responseCode = "200", description = "Token is valid", content = @Content(schema = @Schema(implementation = ValidationResponse.class)))
    @PostMapping("/validate/access")
    public Mono<ResponseEntity<ValidationResponse>> validateAccessToken(
            @Parameter(description = "Access token to validate", required = true) @RequestParam String accessToken) {
        
        return authService.validateAccessToken(accessToken)
                .map(accessTokenBLM -> ResponseEntity.ok(new ValidationResponse("OK")))
                .onErrorResume(BaseTokenException.class, e -> 
                    Mono.just(ResponseEntity.badRequest().build())
                );
    }

    @Operation(summary = "Validate refresh token", description = "Check if refresh token is valid")
    @ApiResponse(responseCode = "200", description = "Token is valid", content = @Content(schema = @Schema(implementation = ValidationResponse.class)))
    @PostMapping("/validate/refresh")
    public Mono<ResponseEntity<ValidationResponse>> validateRefreshToken(
            @Parameter(description = "Refresh token to validate", required = true) @RequestParam String refreshToken) {
        
        return Mono.fromCallable(() -> {
            RefreshTokenDTO refreshTokenDTO = new RefreshTokenDTO(refreshToken);
            return refreshTokenConverter.toBLM(refreshTokenDTO);
        })
        .flatMap(authService::validateRefreshToken)
        .then(Mono.fromCallable(() -> ResponseEntity.ok(new ValidationResponse("OK"))))
        .onErrorResume(BaseTokenException.class, e -> 
            Mono.just(ResponseEntity.badRequest().build())
        );
    }
}package com.connection.service.auth.controller;

import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import com.connection.client.converter.ClientConverter;
import com.connection.client.model.ClientBLM;
import com.connection.client.model.ClientDTO;
import com.connection.client.validator.ClientValidator;
import com.connection.service.auth.AuthService;
import com.connection.service.auth.controller.model.HealthResponse;
import com.connection.service.auth.controller.model.LoginRequest;
import com.connection.service.auth.controller.model.LoginResponse;
import com.connection.service.auth.controller.model.RefreshTokenRequest;
import com.connection.service.auth.controller.model.RegistrationResponse;
import com.connection.service.auth.controller.model.ValidationResponse;
import com.connection.token.converter.AccessTokenConverter;
import com.connection.token.converter.RefreshTokenConverter;
import com.connection.token.exception.BaseTokenException;
import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.AccessTokenDTO;
import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDTO;

import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Mono;

import java.time.Duration;
// import java.util.concurrent//.timeoutException;

@Slf4j
@RestController
@RequiredArgsConstructor
@ConditionalOnProperty(name = "app.controller.mode", havingValue = "webflux", matchIfMissing = true)
@RequestMapping("/api/v1/auth")
@Tag(name = "Auth Service", description = "Authentication and Authorization APIs (WebFlux)")
public class AuthServiceWebFluxController implements AuthController {

    private final AccessTokenConverter accessTokenConverter;
    private final RefreshTokenConverter refreshTokenConverter;
    private final ClientConverter clientConverter;
    private final ClientValidator clientValidator;
    private final AuthService authService;

    @Operation(summary = "Register new client", description = "Register a new client in the system")
    @ApiResponse(responseCode = "200", description = "Client registered successfully", content = @Content(schema = @Schema(implementation = RegistrationResponse.class)))
    @ApiResponse(responseCode = "400", description = "Invalid client data")
    @ApiResponse(responseCode = "408", description = "Request timeout")
    @PostMapping("/register")
    public Mono<ResponseEntity<RegistrationResponse>> register(
            @Parameter(description = "Client data", required = true) @RequestBody ClientDTO clientDTO) {
        
        log.info("Registration attempt for email: {}", clientDTO.getEmail());

        return Mono.fromCallable(() -> {
            clientValidator.validate(clientDTO);
            return clientConverter.toBLM(clientDTO);
        })
        .flatMap(authService::register)
        .then(Mono.fromCallable(() -> {
            log.info("Client registered successfully: {}", clientDTO.getUid());
            return ResponseEntity.ok(new RegistrationResponse(
                    "User registered successfully",
                    clientDTO.getEmail()));
        }))
        //.timeout(Duration.ofMillis(500))
        // .onErrorResume(TimeoutException.class, e -> {
        //     log.error("Registration timeout for email: {} after 500ms", clientDTO.getEmail());
        //     return Mono.just(ResponseEntity.status(HttpStatus.REQUEST_TIMEOUT)
        //             .body(new RegistrationResponse("Registration timeout - service unavailable", clientDTO.getEmail())));
        // })
        .onErrorResume(throwable -> {
            log.error("Registration failed for email: {}", clientDTO.getEmail(), throwable);
            return Mono.just(ResponseEntity.badRequest().build());
        });
    }

    @Operation(summary = "Login by email", description = "Authenticate client using email and password")
    @ApiResponse(responseCode = "200", description = "Login successful", content = @Content(schema = @Schema(implementation = LoginResponse.class)))
    @ApiResponse(responseCode = "400", description = "Invalid credentials")
    @ApiResponse(responseCode = "408", description = "Request timeout")
    @PostMapping("/login")
    public Mono<ResponseEntity<LoginResponse>> loginByEmail(
            @io.swagger.v3.oas.annotations.parameters.RequestBody(description = "Login credentials", required = true, content = @Content(schema = @Schema(implementation = LoginRequest.class))) @RequestBody LoginRequest loginRequest) {
        
        log.info("Login attempt by email: {}", loginRequest.getEmail());

        return authService.authorizeByEmail(loginRequest.getEmail(), loginRequest.getPassword())
                .map(tokens -> {
                    log.info("Login successful for email: {}", loginRequest.getEmail());
                    return ResponseEntity.ok(new LoginResponse(
                            tokens.getFirst().getToken(),
                            tokens.getSecond().getToken(),
                            tokens.getFirst().getExpiresAt(),
                            tokens.getSecond().getExpiresAt(),
                            tokens.getFirst().getClientUID()));
                })
                //.timeout(Duration.ofMillis(500))
                // .onErrorResume(TimeoutException.class, e -> {
                //     log.error("Login timeout for email: {} after 500ms", loginRequest.getEmail());
                //     return Mono.just(ResponseEntity.status(HttpStatus.REQUEST_TIMEOUT).build());
                // })
                .onErrorResume(throwable -> {
                    log.error("Login failed for email: {}", loginRequest.getEmail(), throwable);
                    return Mono.just(ResponseEntity.badRequest().build());
                });
    }

    @Operation(summary = "Refresh tokens", description = "Get new access and refresh tokens using refresh token")
    @ApiResponse(responseCode = "200", description = "Tokens refreshed successfully", content = @Content(schema = @Schema(implementation = LoginResponse.class)))
    @ApiResponse(responseCode = "400", description = "Invalid refresh token")
    @ApiResponse(responseCode = "408", description = "Request timeout")
    @PostMapping("/refresh")
    public Mono<ResponseEntity<LoginResponse>> refreshToken(
            @Parameter(description = "Refresh token request", required = true) @RequestBody RefreshTokenRequest refreshRequest) {
        
        log.info("Token refresh attempt");

        return Mono.fromCallable(() -> {
            RefreshTokenDTO refreshTokenDTO = new RefreshTokenDTO(refreshRequest.getRefreshToken());
            return refreshTokenConverter.toBLM(refreshTokenDTO);
        })
        .flatMap(authService::refresh)
        .map(newTokens -> {
            log.info("Token refresh successful");
            return ResponseEntity.ok(new LoginResponse(
                    newTokens.getFirst().getToken(),
                    newTokens.getSecond().getToken(),
                    newTokens.getFirst().getExpiresAt(),
                    newTokens.getSecond().getExpiresAt(),
                    newTokens.getFirst().getClientUID()));
        })
        //.timeout(Duration.ofMillis(500))
        // .onErrorResume(TimeoutException.class, e -> {
        //     log.error("Token refresh timeout after 500ms");
        //     return Mono.just(ResponseEntity.status(HttpStatus.REQUEST_TIMEOUT).build());
        // })
        .onErrorResume(BaseTokenException.class, e -> {
            log.error("Token refresh failed", e);
            return Mono.just(ResponseEntity.badRequest().build());
        });
    }

    @Operation(summary = "Health check", description = "Check service health")
    @ApiResponse(responseCode = "200", description = "Service is healthy", content = @Content(schema = @Schema(implementation = HealthResponse.class)))
    @ApiResponse(responseCode = "408", description = "Request timeout")
    @GetMapping("/health")
    public Mono<ResponseEntity<HealthResponse>> healthCheck() {
        return authService.getHealthStatus()
                .map(healthMap -> {
                    log.info("Health check: status: OK, service: auth-service, timestamp: {}",
                            System.currentTimeMillis());
                    return ResponseEntity.ok(new HealthResponse(
                            "OK",
                            "auth-service",
                            System.currentTimeMillis()));
                })
                //.timeout(Duration.ofMillis(500))
                // .onErrorResume(TimeoutException.class, e -> {
                //     log.error("Health check timeout after 500ms");
                //     return Mono.just(ResponseEntity.status(HttpStatus.REQUEST_TIMEOUT)
                //             .body(new HealthResponse("TIMEOUT", "auth-service", System.currentTimeMillis())));
                // });
                ;
    }

    @Operation(summary = "Validate access token", description = "Check if access token is valid")
    @ApiResponse(responseCode = "200", description = "Token is valid", content = @Content(schema = @Schema(implementation = ValidationResponse.class)))
    @ApiResponse(responseCode = "400", description = "Invalid access token")
    @ApiResponse(responseCode = "408", description = "Request timeout")
    @PostMapping("/validate/access")
    public Mono<ResponseEntity<ValidationResponse>> validateAccessToken(
            @Parameter(description = "Access token to validate", required = true) @RequestParam String accessToken) {
        
        log.info("Validating access token");

        return authService.validateAccessToken(accessToken)
                .map(accessTokenBLM -> {
                    log.info("Access token validation successful for client: {}", accessTokenBLM.getClientUID());
                    return ResponseEntity.ok(new ValidationResponse("OK"));
                })
                //.timeout(Duration.ofMillis(500))
                // .onErrorResume(TimeoutException.class, e -> {
                //     log.error("Access token validation timeout after 500ms");
                //     return Mono.just(ResponseEntity.status(HttpStatus.REQUEST_TIMEOUT).build());
                // })
                .onErrorResume(BaseTokenException.class, e -> {
                    log.error("Access token validation failed", e);
                    return Mono.just(ResponseEntity.badRequest().build());
                });
    }

    @Operation(summary = "Validate refresh token", description = "Check if refresh token is valid")
    @ApiResponse(responseCode = "200", description = "Token is valid", content = @Content(schema = @Schema(implementation = ValidationResponse.class)))
    @ApiResponse(responseCode = "400", description = "Invalid refresh token")
    @ApiResponse(responseCode = "408", description = "Request timeout")
    @PostMapping("/validate/refresh")
    public Mono<ResponseEntity<ValidationResponse>> validateRefreshToken(
            @Parameter(description = "Refresh token to validate", required = true) @RequestParam String refreshToken) {
        
        log.info("Validating refresh token");

        return Mono.fromCallable(() -> {
            RefreshTokenDTO refreshTokenDTO = new RefreshTokenDTO(refreshToken);
            return refreshTokenConverter.toBLM(refreshTokenDTO);
        })
        .flatMap(authService::validateRefreshToken)
        .then(Mono.fromCallable(() -> {
            log.info("Refresh token validation successful");
            return ResponseEntity.ok(new ValidationResponse("OK"));
        }))
        //.timeout(Duration.ofMillis(500))
        // .onErrorResume(TimeoutException.class, e -> {
        //     log.error("Refresh token validation timeout after 500ms");
        //     return Mono.just(ResponseEntity.status(HttpStatus.REQUEST_TIMEOUT).build());
        // })
        .onErrorResume(BaseTokenException.class, e -> {
            log.error("Refresh token validation failed", e);
            return Mono.just(ResponseEntity.badRequest().build());
        });
    }
}package com.connection.service.auth.controller.model;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
@Schema
public class ValidationResponse {
    private final String status;
}
package com.connection.service.auth.controller.model;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
@Schema
public class ErrorResponse {
    private final String error;
    private final String message;
}

package com.connection.service.auth.controller.model;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
@Schema
public class HealthResponse {
    private final String status;
    private final String service;
    private final long timestamp;
}

package com.connection.service.auth.controller.model;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
@Getter
@Setter
@Schema
public class RegistrationResponse {
    private final String message;
    private final String email;
}package com.connection.service.auth.controller.model;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Getter
@Setter
@Schema(description = "Login request with email and password")
public class LoginRequest {
    
    @Schema(description = "User email", required = true)
    private String email;
    
    @Schema(description = "User password", required = true)
    private String password;
}package com.connection.service.auth.controller.model;

import java.util.Date;
import java.util.UUID;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Getter;
import lombok.Setter;

@Data
@AllArgsConstructor
@Getter
@Setter
@Schema(description = "Login response with tokens")
public class LoginResponse {
    
    private String accessToken;
    
    private String refreshToken;

    private Date accessTokenExpiresAt;  // Используйте конкретный тип
    
    private Date refreshTokenExpiresAt;  // Используйте конкретный тип
    
    private UUID clientUid;
}package com.connection.service.auth.controller.model;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
@Getter
@Setter
@Schema
public class RefreshTokenRequest {
    private String refreshToken;
}

package com.connection.service.auth.controller;

import org.springframework.http.ResponseEntity;

import com.connection.client.model.ClientDTO;
import com.connection.service.auth.controller.model.HealthResponse;
import com.connection.service.auth.controller.model.LoginRequest;
import com.connection.service.auth.controller.model.LoginResponse;
import com.connection.service.auth.controller.model.RefreshTokenRequest;
import com.connection.service.auth.controller.model.RegistrationResponse;
import com.connection.service.auth.controller.model.ValidationResponse;

import reactor.core.publisher.Mono;

public interface AuthController {
    Mono<ResponseEntity<RegistrationResponse>> register(ClientDTO clientDTO);
    Mono<ResponseEntity<LoginResponse>> loginByEmail(LoginRequest loginRequest);
    Mono<ResponseEntity<LoginResponse>> refreshToken(RefreshTokenRequest refreshRequest);
    Mono<ResponseEntity<HealthResponse>> healthCheck();
    Mono<ResponseEntity<ValidationResponse>> validateAccessToken(String accessToken);
    Mono<ResponseEntity<ValidationResponse>> validateRefreshToken(String refreshToken);
}package com.connection.service.auth.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import com.connection.service.auth.controller.model.ErrorResponse;

import java.util.Map;

@Slf4j
@RestControllerAdvice
public class AuthGlobalExceptionHandler {

    @ExceptionHandler(com.connection.client.exception.ClientAlreadyExisistsException.class)
    public ResponseEntity<?> handleClientAlreadyExistsException(
            com.connection.client.exception.ClientAlreadyExisistsException e) {
        log.warn("Client registration failed: {}", e);
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(new ErrorResponse(
                "client_already_exist",
                "An account with such email or uid already exists"));
    }

    @ExceptionHandler(com.connection.client.exception.ClientNotFoundException.class)
    public ResponseEntity<?> handleClientNotFoundException(com.connection.client.exception.ClientNotFoundException e) {
        log.warn("Client not found: {}", e);
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ErrorResponse(
                "client_not_found",
                "User not found"));
    }

    @ExceptionHandler(com.connection.client.exception.ClientValidateException.class)
    public ResponseEntity<?> handleClientValidateException(com.connection.client.exception.ClientValidateException e) {
        log.warn("Client validation failed: {}\n {}", e, e.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(new ErrorResponse(
                "validation_failed",
                e.getMessage() != null ? e.getMessage() : "Invalid user data"));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<?> handleGenericException(Exception e) {
        log.error("Unexpected error occurred: {}", e);
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of(
                "error", "Internal server error",
                "message", "An unexpected error occurred"));
    }
}package com.connection.service.auth.kafka;
// package com.service.auth.kafka;

// import org.apache.kafka.clients.consumer.ConsumerRecord;
// import org.springframework.kafka.annotation.KafkaListener;
// import org.springframework.kafka.core.KafkaTemplate;
// import org.springframework.stereotype.Component;

// import com.connection.auth.events.commands.HealthCheckCommand;
// import com.connection.auth.events.commands.ValidateTokenCommand;
// import com.connection.auth.events.responses.HealthCheckResponse;
// import com.connection.auth.events.responses.TokenValidationResponse;
// import com.connection.token.converter.AccessTokenConverter;
// import com.connection.token.model.AccessTokenBLM;
// import com.service.auth.AuthService;

// import lombok.RequiredArgsConstructor;
// import lombok.extern.slf4j.Slf4j;

// @Slf4j
// @Component
// @RequiredArgsConstructor
// public class AuthCommandConsumer {

//     private final AuthService authService;
//     private final AccessTokenConverter accessTokenConverter;
//     private final KafkaTemplate<String, Object> kafkaTemplate;

//     @KafkaListener(
//         topics = "${app.kafka.topics.auth-commands:auth.commands}",
//         containerFactory = "kafkaListenerContainerFactory" // Указываем конкретную фабрику
//     )
//     public void handleAuthCommand(ConsumerRecord<String, Object> record) { // Изменен тип на Object
//         try {
//             log.debug("Received command from Kafka: key={}, topic={}, partition={}", 
//                      record.key(), record.topic(), record.partition());

//             Object command = record.value();

//             if (command instanceof ValidateTokenCommand) {
//                 ValidateTokenCommand validateCommand = (ValidateTokenCommand) command;
//                 handleValidateTokenCommand(validateCommand, record.key());
//             } else if (command instanceof HealthCheckCommand) {
//                 HealthCheckCommand healthCommand = (HealthCheckCommand) command;
//                 handleHealthCheckCommand(healthCommand, record.key());
//             } else {
//                 log.warn("Unknown command type: {}", command != null ? command.getClass().getCanonicalName() : "null");
//             }

//         } catch (Exception e) {
//             log.error("Error processing auth command from Kafka: key={}", record.key(), e);
//         }
//     }

//     private void handleValidateTokenCommand(ValidateTokenCommand command, String key) {
//         try {
//             log.info("Processing token validation: correlationId={}", command.getCorrelationId());

//             AccessTokenBLM tokenBLM = accessTokenConverter.toBLM(
//                     new com.connection.token.model.AccessTokenDTO(command.getToken()));
//             authService.validateAccessToken(tokenBLM);

//             TokenValidationResponse response = TokenValidationResponse.valid(
//                     command.getCorrelationId(),
//                     tokenBLM.getClientUID(),
//                     command.getTokenType().name());

//             kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
//             log.info("Token validation response sent to {}: correlationId={}",
//                     command.getReplyTopic(), command.getCorrelationId());

//         } catch (Exception e) {
//             TokenValidationResponse response = TokenValidationResponse.error(
//                     command.getCorrelationId(),
//                     e.getMessage());

//             kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
//             log.error("Token validation failed: correlationId={}, error={}",
//                     command.getCorrelationId(), e.getMessage());
//         }
//     }

//     private void handleHealthCheckCommand(HealthCheckCommand command, String key) {
//         try {
//             java.util.Map<String, Object> healthStatus = java.util.Map.of(
//                     "status", "OK",
//                     "service", "auth-service",
//                     "timestamp", System.currentTimeMillis());

//             HealthCheckResponse response = HealthCheckResponse.success(
//                     command.getCorrelationId(),
//                     healthStatus);

//             kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
//             log.info("Health check response sent to {}: correlationId={}",
//                     command.getReplyTopic(), command.getCorrelationId());

//         } catch (Exception e) {
//             HealthCheckResponse response = HealthCheckResponse.error(
//                     command.getCorrelationId(),
//                     e.getMessage());

//             kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
//             log.error("Health check failed: correlationId={}, error={}",
//                     command.getCorrelationId(), e.getMessage());
//         }
//     }
// }package com.connection.service.auth;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class AuthServiceApplication {

	public static void main(String[] args) {
		SpringApplication.run(AuthServiceApplication.class, args);
	}
	
}
package com.connection.service.auth;

import java.util.Map;

import org.springframework.data.util.Pair;

import com.connection.client.model.ClientBLM;
import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.RefreshTokenBLM;

import reactor.core.publisher.Mono;

public interface AuthService {
    Mono<Pair<AccessTokenBLM, RefreshTokenBLM>> authorizeByEmail(String email, String password);
    Mono<Void> register(ClientBLM clientBLM);
    Mono<Pair<AccessTokenBLM, RefreshTokenBLM>> refresh(RefreshTokenBLM refreshTokenBLM);
    Mono<Void> validateAccessToken(AccessTokenBLM accessTokenBLM);
    Mono<Void> validateRefreshToken(RefreshTokenBLM refreshTokenBLM);
    Mono<AccessTokenBLM> validateAccessToken(String token);
    Mono<Map<String, Object>> getHealthStatus();
}package com.connection.service.auth;

import java.time.Duration;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration;
import org.springframework.data.util.Pair;
import org.springframework.stereotype.Service;

import com.connection.client.model.ClientBLM;
import com.connection.client.repository.ClientRepository;
import com.connection.client.validator.ClientValidator;
import com.connection.token.converter.RefreshTokenConverter;
import com.connection.token.generator.AccessTokenGenerator;
import com.connection.token.generator.RefreshTokenGenerator;
import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.RefreshTokenBLM;
import com.connection.token.model.RefreshTokenDALM;
import com.connection.token.repository.RefreshTokenRepository;
import com.connection.token.validator.AccessTokenValidator;
import com.connection.token.validator.RefreshTokenValidator;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import reactor.core.publisher.Mono;

@Slf4j
@RequiredArgsConstructor
@Service
@EnableAutoConfiguration(exclude = {
        JpaRepositoriesAutoConfiguration.class
})
public class AuthServiceImpl implements AuthService {
    private final RefreshTokenConverter refreshTokenConverter;

    private final ClientValidator clientValidator;
    private final RefreshTokenValidator refreshTokenValidator;
    private final AccessTokenValidator accessTokenValidator;

    private final RefreshTokenGenerator refreshTokenGenerator;
    private final AccessTokenGenerator accessTokenGenerator;

    private final ClientRepository clientRepository;
    private final RefreshTokenRepository refreshTokenRepository;

    @Qualifier("jwtAccessTokenExpiration")
    private final Duration jwtAccessTokenDuration;

    @Qualifier("jwtRefreshTokenExpiration")
    private final Duration jwtRefreshTokenDuration;

    @Override
    public Mono<Pair<AccessTokenBLM, RefreshTokenBLM>> authorizeByEmail(String email, String password) {
        // Валидация email
        clientValidator.validateEmail(email);

        return clientRepository.findByEmail(email)
                .flatMap(clientBLM -> {
                    // Проверка пароля
                    if (!clientBLM.getPassword().equals(password)) {
                        return Mono.error(new SecurityException("Invalid email or password"));
                    }

                    // Инициализация общих полей
                    UUID newClientUuid = clientBLM.getUid();
                    Date newCreatedAt = new Date();

                    // Инициализация нового refreshToken
                    UUID newRefreshUID = UUID.randomUUID();
                    Date newRefreshExpiresAt = Date.from(newCreatedAt.toInstant().plus(jwtRefreshTokenDuration));
                    String newRefreshTokenString = refreshTokenGenerator.generateRefreshToken(newRefreshUID, newClientUuid,
                            newCreatedAt, newRefreshExpiresAt);

                    RefreshTokenBLM newRefreshTokenBLM = new RefreshTokenBLM(newRefreshTokenString, newRefreshUID, newClientUuid,
                            newCreatedAt, newRefreshExpiresAt);

                    // Валидация refresh token
                    refreshTokenValidator.validate(newRefreshTokenBLM);

                    // Инициализация нового accessToken
                    Date newAccessExpiresAt = Date.from(newCreatedAt.toInstant().plus(jwtAccessTokenDuration));
                    String newAccessTokenString = accessTokenGenerator.generateAccessToken(newClientUuid, newCreatedAt,
                            newAccessExpiresAt);
                    AccessTokenBLM newAccessTokenBLM = new AccessTokenBLM(newAccessTokenString, newClientUuid, newCreatedAt,
                            newAccessExpiresAt);
                    accessTokenValidator.validate(newAccessTokenBLM);

                    // Добавление нового refreshToken в БД
                    RefreshTokenDALM newRefreshTokenDALM = refreshTokenConverter.toDALM(newRefreshTokenBLM);
                    
                    return refreshTokenRepository.add(newRefreshTokenDALM)
                            .thenReturn(Pair.of(newAccessTokenBLM, newRefreshTokenBLM));
                });
    }

    @Override
    public Mono<Void> register(ClientBLM clientBLM) {
        // Валидация клиента
        clientValidator.validate(clientBLM);
        
        // Регистрация клиента
        return clientRepository.add(clientBLM);
    }

    @Override
    public Mono<Pair<AccessTokenBLM, RefreshTokenBLM>> refresh(RefreshTokenBLM refreshTokenBLM) {
        log.info("Validating refresh token");
        
        // Валидация refresh token
        refreshTokenValidator.validate(refreshTokenBLM);
        log.info("Validated refresh token");

        // Инициализация общих полей
        UUID newClientUuid = refreshTokenBLM.getClientUID();
        Date newCreatedAt = new Date();

        // Инициализация нового refreshToken
        UUID newRefreshUID = refreshTokenBLM.getUid();
        Date newRefreshExpiresAt = Date.from(newCreatedAt.toInstant().plus(jwtRefreshTokenDuration));
        String newRefreshTokenString = refreshTokenGenerator.generateRefreshToken(newRefreshUID, newClientUuid,
                newCreatedAt, newRefreshExpiresAt);

        RefreshTokenBLM newRefreshTokenBLM = new RefreshTokenBLM(newRefreshTokenString, newRefreshUID, newClientUuid,
                newCreatedAt, newRefreshExpiresAt);
        
        log.info("Validating new refresh token");
        refreshTokenValidator.validate(newRefreshTokenBLM);
        log.info("Validated new refresh token");

        // Инициализация нового accessToken
        Date newAccessExpiresAt = Date.from(newCreatedAt.toInstant().plus(jwtAccessTokenDuration));
        String newAccessTokenString = accessTokenGenerator.generateAccessToken(newClientUuid, newCreatedAt,
                newAccessExpiresAt);
        log.info("Generated new access token");
        
        AccessTokenBLM newAccessTokenBLM = new AccessTokenBLM(newAccessTokenString, newClientUuid, newCreatedAt,
                newAccessExpiresAt);
        accessTokenValidator.validate(newAccessTokenBLM);
        log.info("Validated new access token");

        // Конвертация токенов и обновление в репозитории
        RefreshTokenDALM refreshTokenDALM = refreshTokenConverter.toDALM(refreshTokenBLM);
        log.info("Converted refresh token");
        
        RefreshTokenDALM newRefreshTokenDALM = refreshTokenConverter.toDALM(newRefreshTokenBLM);
        log.info("Converted new refresh token");

        // Обновление RefreshToken в репозитории и возврат новых токенов
        return refreshTokenRepository.updateToken(refreshTokenDALM, newRefreshTokenDALM)
                .thenReturn(Pair.of(newAccessTokenBLM, newRefreshTokenBLM))
                .doOnSuccess(tokens -> log.info("Updated by repo refresh token"));
    }

    @Override
    public Mono<Void> validateAccessToken(AccessTokenBLM accessTokenBLM) {
        return Mono.fromRunnable(() -> accessTokenValidator.validate(accessTokenBLM));
    }

    @Override
    public Mono<Void> validateRefreshToken(RefreshTokenBLM refreshTokenBLM) {
        return Mono.fromRunnable(() -> refreshTokenValidator.validate(refreshTokenBLM));
    }

    @Override
    public Mono<Map<String, Object>> getHealthStatus() {
        return Mono.fromCallable(() -> {
            Map<String, Object> map = new HashMap<>();
            map.put("status", "OK");
            map.put("service", "auth-service");
            map.put("timestamp", System.currentTimeMillis());
            return map;
        });
    }

    @Override
    public Mono<AccessTokenBLM> validateAccessToken(String token) {
        return Mono.fromCallable(() -> {
            AccessTokenBLM accessTokenBLM = accessTokenGenerator.getAccessTokenBLM(token);
            accessTokenValidator.validate(accessTokenBLM);
            return accessTokenBLM;
        });
    }
}package com.connection.service.auth.mother;

import java.util.Date;
import java.util.UUID;

import com.connection.client.model.ClientBLM;
import com.connection.client.model.ClientDALM;
import com.connection.client.model.ClientDTO;
import com.connection.token.model.AccessTokenBLM;
import com.connection.token.model.RefreshTokenBLM;

public class AuthObjectMother {

    public static final UUID CLIENT_UUID = UUID.fromString("123e4567-e89b-12d3-a456-426614174000");
    public static final UUID REFRESH_TOKEN_UUID = UUID.fromString("323e4567-e89b-12d3-a456-426614174002");
    public static final String VALID_EMAIL = "test@example.com";
    public static final String VALID_PASSWORD = "securePassword123";
    public static final String VALID_USERNAME = "testuser";
    public static final Date BIRTH_DATE = new Date(System.currentTimeMillis() - 25L * 365 * 24 * 60 * 60 * 1000); // 25 years ago

    public static ClientDTO randomValidClientDTO() {
        String timestamp = String.valueOf(System.currentTimeMillis());
        String threadId = String.valueOf(Thread.currentThread().getId());
        String uniqueSuffix = timestamp + "_" + threadId;

        return new ClientDTO(
            UUID.randomUUID(),
            new Date(System.currentTimeMillis() - 25L * 365 * 24 * 60 * 60 * 1000),
            "test_" + uniqueSuffix + "@example.com",
            "Password123!" + uniqueSuffix,
            "user_" + uniqueSuffix
        );
    }

    public static ClientBLM randomValidClientBLM() {
        String timestamp = String.valueOf(System.currentTimeMillis());
        String threadId = String.valueOf(Thread.currentThread().getId());
        String uniqueSuffix = timestamp + "_" + threadId;

        return new ClientBLM(
            UUID.randomUUID(),
            new Date(System.currentTimeMillis() - 25L * 365 * 24 * 60 * 60 * 1000),
            "test_" + uniqueSuffix + "@example.com",
            "Password123!" + uniqueSuffix,
            "user_" + uniqueSuffix
        );
    }

    public static ClientBLM createValidClientBLM() {
        return new ClientBLM(
            CLIENT_UUID,
            BIRTH_DATE,
            VALID_EMAIL,
            VALID_PASSWORD,
            VALID_USERNAME
        );
    }

    public static ClientDALM createValidClientDALM() {
        return new ClientDALM(
            CLIENT_UUID,
            BIRTH_DATE,
            VALID_EMAIL,
            VALID_PASSWORD,
            VALID_USERNAME
        );
    }

    public static AccessTokenBLM createValidAccessTokenBLM() {
        Date createdAt = new Date();
        Date expiresAt = new Date(createdAt.getTime() + 600000); // 10 minutes
        String tokenString = "valid.access.token.string";
        
        return new AccessTokenBLM(
            tokenString,
            CLIENT_UUID,
            createdAt,
            expiresAt
        );
    }

    public static RefreshTokenBLM createValidRefreshTokenBLM() {
        Date createdAt = new Date();
        Date expiresAt = new Date(createdAt.getTime() + 86400000); // 24 hours
        String tokenString = "valid.refresh.token.string";
        
        return new RefreshTokenBLM(
            tokenString,
            REFRESH_TOKEN_UUID,
            CLIENT_UUID,
            createdAt,
            expiresAt
        );
    }

    public static RefreshTokenBLM createExpiredRefreshTokenBLM() {
        Date createdAt = new Date(System.currentTimeMillis() - 86400000); // 24 hours ago
        Date expiresAt = new Date(createdAt.getTime() + 3600000); // 1 hour, already expired
        String tokenString = "expired.refresh.token.string";
        
        return new RefreshTokenBLM(
            tokenString,
            REFRESH_TOKEN_UUID,
            CLIENT_UUID,
            createdAt,
            expiresAt
        );
    }
}