// DeviceAccessTokenUtilsConfig.java
package com.service.device.auth.config;

import javax.crypto.SecretKey;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.connection.device.token.converter.DeviceAccessTokenConverter;
import com.connection.device.token.generator.DeviceAccessTokenGenerator;
import com.connection.device.token.validator.DeviceAccessTokenValidator;

@Configuration
public class DeviceAccessTokenUtilsConfig {

    @Bean
    DeviceAccessTokenValidator deviceAccessTokenValidator() {
        return new DeviceAccessTokenValidator();
    }

    @Bean
    DeviceAccessTokenGenerator deviceAccessTokenGenerator(
            SecretKey jwtSecretKey,
            @Qualifier("appName") String appNameString,
            @Qualifier("jwtSubject") String subjectString) {
        return new DeviceAccessTokenGenerator(jwtSecretKey, appNameString, subjectString);
    }

    @Bean
    DeviceAccessTokenConverter deviceAccessTokenConverter(DeviceAccessTokenGenerator deviceAccessTokenGenerator) {
        return new DeviceAccessTokenConverter(deviceAccessTokenGenerator);
    }
}package com.service.device.auth.config;

import io.swagger.v3.oas.annotations.enums.SecuritySchemeType;
import io.swagger.v3.oas.annotations.security.SecurityScheme;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@SecurityScheme(
    name = "bearerAuth",
    type = SecuritySchemeType.HTTP,
    bearerFormat = "JWT",
    scheme = "bearer"
)
public class SwaggerConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("Buffer Service API")
                        .version("1.0")
                        .description("API для управления буферами"))
                .addSecurityItem(new SecurityRequirement().addList("bearerAuth"))
                .components(new Components()
                        .addSecuritySchemes("bearerAuth", 
                            new io.swagger.v3.oas.models.security.SecurityScheme()
                                .type(io.swagger.v3.oas.models.security.SecurityScheme.Type.HTTP)
                                .scheme("bearer")
                                .bearerFormat("JWT")));
    }
}// DatabaseConfig.java
package com.service.device.auth.config;

import java.util.Properties;

import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.atomikos.jdbc.AtomikosDataSourceBean;

@Configuration
public class DatabaseConfig {
    
    // Device Token DataSource
    @Value("${app.datasource.device-token.xa-data-source-class-name:org.postgresql.xa.PGXADataSource}")
    private String deviceTokenXaDataSourceClassName;

    @Value("${app.datasource.device-token.xa-properties.url}")
    private String deviceTokenJdbcUrl;

    @Value("${app.datasource.device-token.xa-properties.user}")
    private String deviceTokenUsername;

    @Value("${app.datasource.device-token.xa-properties.password}")
    private String deviceTokenPassword;

    @Value("${app.datasource.device-token.unique-resource-name:deviceTokenXADataSource}")
    private String deviceTokenUniqueResourceName;

    // Device Access Token DataSource
    @Value("${app.datasource.device-access-token.xa-data-source-class-name:org.postgresql.xa.PGXADataSource}")
    private String deviceAccessTokenXaDataSourceClassName;

    @Value("${app.datasource.device-access-token.xa-properties.url}")
    private String deviceAccessTokenJdbcUrl;

    @Value("${app.datasource.device-access-token.xa-properties.user}")
    private String deviceAccessTokenUsername;

    @Value("${app.datasource.device-access-token.xa-properties.password}")
    private String deviceAccessTokenPassword;

    @Value("${app.datasource.device-access-token.unique-resource-name:deviceAccessTokenXADataSource}")
    private String deviceAccessTokenUniqueResourceName;

    @Bean("deviceTokenDataSource")
    DataSource deviceTokenDataSource() {
        return createDataSource(
            deviceTokenUniqueResourceName,
            deviceTokenXaDataSourceClassName,
            deviceTokenJdbcUrl,
            deviceTokenUsername,
            deviceTokenPassword
        );
    }

    @Bean("deviceAccessTokenDataSource")
    DataSource deviceAccessTokenDataSource() {
        return createDataSource(
            deviceAccessTokenUniqueResourceName,
            deviceAccessTokenXaDataSourceClassName,
            deviceAccessTokenJdbcUrl,
            deviceAccessTokenUsername,
            deviceAccessTokenPassword
        );
    }

    @Bean("deviceTokenJdbcTemplate")
    NamedParameterJdbcTemplate deviceTokenJdbcTemplate(
            @Qualifier("deviceTokenDataSource") DataSource dataSource) {
        return new NamedParameterJdbcTemplate(dataSource);
    }

    @Bean("deviceAccessTokenJdbcTemplate")
    NamedParameterJdbcTemplate deviceAccessTokenJdbcTemplate(
            @Qualifier("deviceAccessTokenDataSource") DataSource dataSource) {
        return new NamedParameterJdbcTemplate(dataSource);
    }

    private DataSource createDataSource(String uniqueResourceName, String xaDataSourceClassName, 
                                      String url, String username, String password) {
        AtomikosDataSourceBean dataSource = new AtomikosDataSourceBean();
        dataSource.setUniqueResourceName(uniqueResourceName);
        dataSource.setXaDataSourceClassName(xaDataSourceClassName);

        Properties xaProperties = new Properties();
        xaProperties.setProperty("url", url);
        xaProperties.setProperty("user", username);
        xaProperties.setProperty("password", password);

        dataSource.setXaProperties(xaProperties);
        dataSource.setPoolSize(5);
        dataSource.setMaxPoolSize(10);
        dataSource.setTestQuery("SELECT 1");

        return dataSource;
    }
}// RepositoryConfig.java
package com.service.device.auth.config;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.connection.device.token.repository.DeviceTokenRepository;
import com.connection.device.token.repository.DeviceTokenRepositorySQLImpl;
import com.connection.device.token.repository.DeviceAccessTokenRepository;
import com.connection.device.token.repository.DeviceAccessTokenRepositorySQLImpl;

@Configuration
public class RepositoryConfig {
    
    @Bean
    DeviceTokenRepository deviceTokenRepository(
            @Qualifier("deviceTokenJdbcTemplate") NamedParameterJdbcTemplate template) {
        return new DeviceTokenRepositorySQLImpl(template);
    }
    
    @Bean
    DeviceAccessTokenRepository deviceAccessTokenRepository(
            @Qualifier("deviceAccessTokenJdbcTemplate") NamedParameterJdbcTemplate template,
            DeviceTokenRepository deviceTokenRepository) {
        return new DeviceAccessTokenRepositorySQLImpl(template);
    }
}// JwtConfig.java
package com.service.device.auth.config;

import java.nio.charset.StandardCharsets;
import java.time.Duration;

import javax.crypto.SecretKey;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.security.Keys;
import io.jsonwebtoken.security.MacAlgorithm;

@Configuration
public class JwtConfig {
    @Value("${DEVICE_JWT_KEY:${app.jwt.device.key:deviceJwtSecretKeyForAuthService123}}")
    private String jwtSecretString;

    @Value("DeviceToken")
    private String jwtSubjectString;

    @Value("${DEVICE_ACCESS_TOKEN_EXPIRATION:${app.jwt.device.access-token.expiration:3600}}")
    private long deviceAccessTokenExpiration;
    
    @Value("${DEVICE_TOKEN_EXPIRATION:${app.jwt.device.token.expiration:2592000}}") // 30 дней
    private long deviceTokenExpiration;

    private final MacAlgorithm jwtAlgorithmMacAlgorithm = Jwts.SIG.HS256;

    @Bean
    SecretKey jwtSecretKey() {
        return createSecretKeyFromString(jwtSecretString, jwtAlgorithmMacAlgorithm);
    }

    @Bean
    String jwtSubject(){
        return jwtSubjectString;
    }

    @Bean
    Duration deviceAccessTokenDuration(){
        return Duration.ofSeconds(deviceAccessTokenExpiration);
    }

    @Bean
    Duration deviceTokenDuration(){
        return Duration.ofSeconds(deviceTokenExpiration);
    }
    
    @Bean
    MacAlgorithm jwtAlgorithm(){
        return jwtAlgorithmMacAlgorithm;
    }

    private SecretKey createSecretKeyFromString(String secretString, MacAlgorithm algorithm) {
        byte[] keyBytes = secretString.getBytes(StandardCharsets.UTF_8);
        return Keys.hmacShaKeyFor(keyBytes);
    }
}// DeviceTokenUtilsConfig.java
package com.service.device.auth.config;

import javax.crypto.SecretKey;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.connection.device.token.converter.DeviceTokenConverter;
import com.connection.device.token.generator.DeviceTokenGenerator;
import com.connection.device.token.validator.DeviceTokenValidator;

@Configuration
public class DeviceTokenUtilsConfig {

    @Bean
    DeviceTokenValidator deviceTokenValidator(){
        return new DeviceTokenValidator();
    }

    @Bean
    DeviceTokenGenerator deviceTokenGenerator(
            SecretKey jwtSecretKey,
            @Qualifier("appName") String appNameString,
            @Qualifier("jwtSubject") String subjectString) {
        return new DeviceTokenGenerator(jwtSecretKey, appNameString, subjectString);
    }

    @Bean
    DeviceTokenConverter deviceTokenConverter(DeviceTokenGenerator deviceTokenGenerator) {
        return new DeviceTokenConverter(deviceTokenGenerator);
    }
}// KafkaConfig.java
package com.service.device.auth.config;

import org.apache.kafka.clients.admin.NewTopic;
import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.clients.producer.ProducerConfig;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.config.TopicBuilder;
import org.springframework.kafka.core.ConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaProducerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.core.ProducerFactory;
import org.springframework.kafka.listener.DefaultErrorHandler;
import org.springframework.kafka.support.serializer.ErrorHandlingDeserializer;
import org.springframework.kafka.support.serializer.JsonDeserializer;
import org.springframework.kafka.support.serializer.JsonSerializer;
import org.springframework.util.backoff.FixedBackOff;

import com.connection.device.auth.events.DeviceAuthEventConstants;

import java.util.HashMap;
import java.util.Map;

@Configuration
public class KafkaConfig {

    @Value("${spring.kafka.bootstrap-servers:kafka:9092}")
    private String bootstrapServers;

    @Bean
    public NewTopic deviceAuthCommandsTopic() {
        return TopicBuilder.name(DeviceAuthEventConstants.DEVICE_AUTH_COMMANDS_TOPIC)
                .partitions(3)
                .replicas(1)
                .build();
    }

    @Bean
    public NewTopic deviceAuthResponsesTopic() {
        return TopicBuilder.name(DeviceAuthEventConstants.DEVICE_AUTH_RESPONSES_TOPIC)
                .partitions(3)
                .replicas(1)
                .build();
    }

    @Bean
    public NewTopic deviceAuthEventsTopic() {
        return TopicBuilder.name(DeviceAuthEventConstants.DEVICE_AUTH_EVENTS_TOPIC)
                .partitions(3)
                .replicas(1)
                .build();
    }

    @Bean
    public NewTopic deviceTokenEventsTopic() {
        return TopicBuilder.name(DeviceAuthEventConstants.DEVICE_TOKEN_EVENTS_TOPIC)
                .partitions(3)
                .replicas(1)
                .build();
    }

    @Bean
    public ConsumerFactory<String, Object> consumerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        configProps.put(ConsumerConfig.GROUP_ID_CONFIG, "device-auth-service-group");
        configProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");

        configProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer.class);
        configProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer.class);

        configProps.put(ErrorHandlingDeserializer.KEY_DESERIALIZER_CLASS,
                org.apache.kafka.common.serialization.StringDeserializer.class);
        configProps.put(ErrorHandlingDeserializer.VALUE_DESERIALIZER_CLASS, JsonDeserializer.class);

        configProps.put(JsonDeserializer.TRUSTED_PACKAGES,
                "com.connection.device.auth.events.commands,com.connection.common.events");
        configProps.put(JsonDeserializer.USE_TYPE_INFO_HEADERS, true);
        configProps.put(JsonDeserializer.REMOVE_TYPE_INFO_HEADERS, false);
        configProps.put(JsonDeserializer.VALUE_DEFAULT_TYPE, "com.connection.common.events.Command");

        configProps.put(JsonDeserializer.TRUSTED_PACKAGES, "*");

        return new DefaultKafkaConsumerFactory<>(configProps);
    }

    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, Object> kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory<String, Object> factory = new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory());

        DefaultErrorHandler errorHandler = new DefaultErrorHandler(
                (record, exception) -> {
                    org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger("DeviceAuthKafkaErrorHandler");
                    logger.error("Skipping invalid device auth message - Topic: {}, Partition: {}, Offset: {}, Key: {}, Error: {}",
                            record.topic(), record.partition(), record.offset(), record.key(), exception.getMessage());
                },
                new FixedBackOff(0L, 0L)
        );

        factory.setCommonErrorHandler(errorHandler);
        return factory;
    }

    @Bean
    public ProducerFactory<String, Object> producerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,
                org.apache.kafka.common.serialization.StringSerializer.class);
        configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
        configProps.put(JsonSerializer.ADD_TYPE_INFO_HEADERS, true);
        return new DefaultKafkaProducerFactory<>(configProps);
    }

    @Bean
    public KafkaTemplate<String, Object> kafkaTemplate() {
        return new KafkaTemplate<>(producerFactory());
    }
}package com.service.device.auth.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.jta.JtaTransactionManager;

import com.atomikos.icatch.jta.UserTransactionManager;

import jakarta.transaction.SystemException;

@Configuration
@ConditionalOnProperty(name = "app.transaction.mode", havingValue = "atomikos")
public class TransactionConfig {

    @Bean
    public UserTransactionManager userTransactionManager() throws SystemException{
        UserTransactionManager manager = new UserTransactionManager();
        manager.setTransactionTimeout(300);
        manager.setForceShutdown(true);
        return manager;
    }

    @Bean(name = "atomicosTransactionManager")
    public JtaTransactionManager jtaTransactionManager() throws SystemException {
        JtaTransactionManager jtaTransactionManager = new JtaTransactionManager();
        jtaTransactionManager.setTransactionManager(userTransactionManager());
        jtaTransactionManager.setUserTransaction(userTransactionManager());
        return jtaTransactionManager;
    }
}// ApplicationConfig.java
package com.service.device.auth.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ApplicationConfig {
    @Value("${spring.application.name:device-auth-service}")
    private String appNameString;

    @Bean
    String appName(){
        return appNameString;
    }
}// DeviceAuthService.java
package com.service.device.auth;

import java.util.UUID;

import org.springframework.data.util.Pair;

import com.connection.device.token.model.DeviceTokenBLM;
import com.connection.device.token.model.DeviceAccessTokenBLM;

public interface DeviceAuthService {
    // Device Token operations
    DeviceTokenBLM createDeviceToken(UUID deviceUid);
    DeviceTokenBLM getDeviceToken(UUID deviceUid);
    void revokeDeviceToken(UUID deviceUid);
    void validateDeviceToken(DeviceTokenBLM deviceToken);
    
    // Device Access Token operations
    Pair<DeviceAccessTokenBLM, DeviceTokenBLM> createDeviceAccessToken(DeviceTokenBLM deviceToken);
    DeviceAccessTokenBLM refreshDeviceAccessToken(DeviceAccessTokenBLM deviceAccessToken);
    void validateDeviceAccessToken(DeviceAccessTokenBLM deviceAccessToken);
    
    // Utility methods
    UUID extractDeviceUidFromToken(DeviceTokenBLM deviceToken);
    UUID extractDeviceUidFromAccessToken(DeviceAccessTokenBLM deviceAccessToken);
}package com.service.device.auth.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;


import java.util.Map;

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(com.connection.device.exception.DeviceAlreadyExistsException.class)
    public ResponseEntity<?> handleDeviceAlreadyExistsException(
            com.connection.device.exception.DeviceAlreadyExistsException e) {
        log.warn("Device registration failed: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(new ErrorResponse(
                "device_already_exist",
                "An device with such uid already exists"));
    }

    @ExceptionHandler(com.connection.device.exception.DeviceNotFoundException.class)
    public ResponseEntity<?> handleDeviceNotFoundException(com.connection.device.exception.DeviceNotFoundException e) {
        log.warn("Device not found: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ErrorResponse(
                "device_not_found",
                "User not found"));
    }

    @ExceptionHandler(com.connection.device.exception.DeviceValidateException.class)
    public ResponseEntity<?> handleDeviceValidateException(com.connection.device.exception.DeviceValidateException e) {
        log.warn("Device validation failed: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(new ErrorResponse(
                "validation_failed",
                e.getMessage() != null ? e.getMessage() : "Invalid device data"));
    }




    @ExceptionHandler(com.connection.device.token.exception.DeviceTokenAlreadyExistsException.class)
    public ResponseEntity<?> handeleDeviceTokenException(com.connection.device.token.exception.DeviceTokenAlreadyExistsException e){
        log.warn("Device token adding failed: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(new ErrorResponse(
                "device_token_already_exist",
                "Token for this device already exists"));

    }

    @ExceptionHandler(com.connection.device.token.exception.DeviceTokenNotFoundException.class)
    public ResponseEntity<?> handeleDeviceTokenException(com.connection.device.token.exception.DeviceTokenNotFoundException e){
        log.warn("Device token getting failed: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ErrorResponse(
                "device_token_not_found",
                "No such token exist"));
    }

    @ExceptionHandler(com.connection.device.token.exception.DeviceTokenValidateException.class)
    public ResponseEntity<?> handeleDeviceTokenException(com.connection.device.token.exception.DeviceTokenValidateException e){
        log.warn("Device token getting failed: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(new ErrorResponse(
                "device_token_invalid",
                "Invalid token"));
    }





    @ExceptionHandler(com.connection.device.token.exception.DeviceAccessTokenExistsException.class)
    public ResponseEntity<?> handeleDeviceTokenException(com.connection.device.token.exception.DeviceAccessTokenExistsException e){
        log.warn("Device access token adding failed: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(new ErrorResponse(
                "device_access_token_already_exist",
                "Access token for this device already exists"));

    }

    @ExceptionHandler(com.connection.device.token.exception.DeviceAccessTokenNotFoundException.class)
    public ResponseEntity<?> handeleDeviceTokenException(com.connection.device.token.exception.DeviceAccessTokenNotFoundException e){
        log.warn("Device access token getting failed: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ErrorResponse(
                "device_access_token_not_found",
                "No such access token exist"));
    }

    @ExceptionHandler(com.connection.device.token.exception.DeviceAccessTokenValidateException.class)
    public ResponseEntity<?> handeleDeviceTokenException(com.connection.device.token.exception.DeviceAccessTokenValidateException e){
        log.warn("Device token getting failed: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(new ErrorResponse(
                "device_access_token_invalid",
                "Invalid access token"));
    }
    
    @ExceptionHandler(io.jsonwebtoken.JwtException.class)
    public ResponseEntity<?> handeleJwtException(io.jsonwebtoken.JwtException e){
        log.warn("JWT token invalid: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(new ErrorResponse(
                "jwt_token_invalid",
                "Invalid jwt token"));
    }

    @ExceptionHandler(exception = IllegalArgumentException.class)
    public ResponseEntity<?> handeleJwtException(IllegalArgumentException e){
        log.warn("JWT token invalid: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(new ErrorResponse(
                "illegal_argument",
                "Illegal argument"));
    }



    @ExceptionHandler(Exception.class)
    public ResponseEntity<?> handleGenericException(Exception e) {
        log.error("Unexpected error occurred: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(Map.of(
                "error", "Internal server error",
                "message", "An unexpected error occurred"));
    }
}package com.service.device.auth.controller;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class ErrorResponse {
    private final String error;
    private final St