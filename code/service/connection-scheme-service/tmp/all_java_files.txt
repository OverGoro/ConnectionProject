// ConnectionSchemeServiceApplication.java
package com.service.connectionscheme;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ConnectionSchemeServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConnectionSchemeServiceApplication.class, args);
    }
}// FeignClientConfig.java
package com.service.connectionscheme.config;

import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.service.connectionscheme.client.FeignErrorDecoder;

@Configuration
@EnableFeignClients(basePackages = "com.service.connectionscheme.client")
public class FeignClientConfig {
    
    @Bean
    public FeignErrorDecoder feignErrorDecoder() {
        return new FeignErrorDecoder();
    }
}// ConnectionSchemeUtilsConfig.java
package com.service.connectionscheme.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.connection.scheme.converter.ConnectionSchemeConverter;
import com.connection.scheme.validator.ConnectionSchemeValidator;

@Configuration
public class ConnectionSchemeUtilsConfig {
    @Bean("ConnectionSchemeConverter")
    ConnectionSchemeConverter connectionSchemeConverter(){
        return new ConnectionSchemeConverter();
    }

    @Bean("ConnectionSchemeValidator")
    ConnectionSchemeValidator connectionSchemeValidator(){
        return new ConnectionSchemeValidator();
    }
}// ConnectionSchemeRepositoryConfig.java
package com.service.connectionscheme.config;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.connection.scheme.repository.ConnectionSchemeRepository;
import com.connection.scheme.repository.ConnectionSchemeRepositorySQLImpl;

@Configuration
public class ConnectionSchemeRepositoryConfig {
    @Bean("ConnectionSchemeRepository")
    ConnectionSchemeRepository connectionSchemeRepository(@Qualifier("ConnectionSchemeJdbcTemplate") NamedParameterJdbcTemplate template){
        return new ConnectionSchemeRepositorySQLImpl(template);
    }
}// ConnectionSchemeJDBCConfig.java
package com.service.connectionscheme.config;

import java.util.Properties;
import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.atomikos.jdbc.AtomikosDataSourceBean;

@Configuration
public class ConnectionSchemeJDBCConfig {
    
    @Value("${app.datasource.connection-scheme.xa-data-source-class-name:org.postgresql.xa.PGXADataSource}")
    private String xaDataSourceClassName;

    @Value("${app.datasource.connection-scheme.xa-properties.url}")
    private String jdbcUrl;

    @Value("${app.datasource.connection-scheme.xa-properties.user}")
    private String username;

    @Value("${app.datasource.connection-scheme.xa-properties.password}")
    private String password;

    @Value("${app.datasource.connection-scheme.unique-resource-name:connectionSchemeXADataSource}")
    private String uniqueResourceName;

    @Bean("ConnectionSchemeDataSource")
    DataSource connectionSchemeDataSource() {
        AtomikosDataSourceBean dataSource = new AtomikosDataSourceBean();
        dataSource.setUniqueResourceName(uniqueResourceName);
        dataSource.setXaDataSourceClassName(xaDataSourceClassName);
        
        Properties xaProperties = new Properties();
        xaProperties.setProperty("url", jdbcUrl);
        xaProperties.setProperty("user", username);
        xaProperties.setProperty("password", password);

        dataSource.setXaProperties(xaProperties);
        dataSource.setPoolSize(5);
        dataSource.setTestQuery("SELECT 1");

        return dataSource;
    }

    @Bean("ConnectionSchemeJdbcTemplate")
    NamedParameterJdbcTemplate connectionSchemeNamedParameterJdbcTemplate(
            @Qualifier("ConnectionSchemeDataSource") DataSource connectionSchemeDataSource) {
        return new NamedParameterJdbcTemplate(connectionSchemeDataSource);
    }
}package com.service.connectionscheme.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.jta.JtaTransactionManager;

import com.atomikos.icatch.jta.UserTransactionManager;

import jakarta.transaction.SystemException;

@Configuration
public class TransactionConfig {

    @Bean
    public UserTransactionManager userTransactionManager() throws SystemException{
        UserTransactionManager manager = new UserTransactionManager();
        manager.setTransactionTimeout(300);
        manager.setForceShutdown(true);
        return manager;
    }

    @Bean(name = "atomicosTransactionManager")
    public JtaTransactionManager jtaTransactionManager() throws SystemException {
        JtaTransactionManager jtaTransactionManager = new JtaTransactionManager();
        jtaTransactionManager.setTransactionManager(userTransactionManager());
        jtaTransactionManager.setUserTransaction(userTransactionManager());
        return jtaTransactionManager;
    }
}package com.service.connectionscheme.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import com.service.connectionscheme.client.AuthServiceClient;
import com.service.connectionscheme.client.JwtAuthenticationFilter;

@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    private final AuthServiceClient authServiceClient;

    public SecurityConfig(AuthServiceClient authServiceClient) {
        this.authServiceClient = authServiceClient;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED))
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/swagger-ui.html").permitAll()
                .requestMatchers("/swagger-ui/**").permitAll()
                .requestMatchers("/api-docs/**").permitAll()
                .requestMatchers("/webjars/**").permitAll()
                .requestMatchers("/v3/api-docs/**").permitAll()
                .requestMatchers("/api/device-service/health").permitAll()
                .requestMatchers("/api/device-service/**").permitAll()//.authenticated()
                .anyRequest().permitAll()
            )
            .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class);
        
        return http.build();
    }

    @Bean
    public JwtAuthenticationFilter jwtAuthenticationFilter() {
        return new JwtAuthenticationFilter(authServiceClient);
    }
}// ConnectionSchemeServiceImpl.java
package com.service.connectionscheme;

import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.connection.scheme.converter.ConnectionSchemeConverter;
import com.connection.scheme.exception.ConnectionSchemeAlreadyExistsException;
import com.connection.scheme.model.ConnectionSchemeBLM;
import com.connection.scheme.model.ConnectionSchemeDALM;
import com.connection.scheme.model.ConnectionSchemeDTO;
import com.connection.scheme.repository.ConnectionSchemeRepository;
import com.connection.scheme.validator.ConnectionSchemeValidator;
import com.service.connectionscheme.client.AuthServiceClient;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RequiredArgsConstructor
@Service
@EnableAutoConfiguration(exclude = {
        JpaRepositoriesAutoConfiguration.class
})
@Transactional("atomicosTransactionManager")
public class ConnectionSchemeServiceImpl implements ConnectionSchemeService {

    private final ConnectionSchemeRepository schemeRepository;
    private final ConnectionSchemeConverter schemeConverter;
    private final ConnectionSchemeValidator schemeValidator;
    private final AuthServiceClient authServiceClient;

    @Override
    public ConnectionSchemeBLM createScheme(UUID clientUid, ConnectionSchemeDTO schemeDTO) {
        schemeValidator.validate(schemeDTO);
        ConnectionSchemeBLM schemeBLM = schemeConverter.toBLM(schemeDTO);

        if (!clientUid.equals(schemeBLM.getClientUid())) {
            throw new SecurityException("Client UID from token doesn't match scheme client UID");
        }

        if (schemeRepository.exists(schemeBLM.getUid())) {
            throw new ConnectionSchemeAlreadyExistsException(
                    "Scheme with UID '" + schemeBLM.getUid() + "' already exists");
        }

        ConnectionSchemeDALM schemeDALM = schemeConverter.toDALM(schemeBLM);
        schemeRepository.add(schemeDALM);

        log.info("Connection scheme created: {} for client: {}", schemeBLM.getUid(), clientUid);
        return schemeBLM;
    }

    @Override
    public ConnectionSchemeBLM getSchemeByUid(UUID clientUid, UUID schemeUid) {
        ConnectionSchemeDALM schemeDALM = schemeRepository.findByUid(schemeUid);

        if (!clientUid.equals(schemeDALM.getClientUid())) {
            throw new SecurityException("Scheme doesn't belong to the authenticated client");
        }

        return schemeConverter.toBLM(schemeDALM);
    }

    @Override
    public List<ConnectionSchemeBLM> getSchemesByClient(UUID clientUid) {
        List<ConnectionSchemeDALM> schemesDALM = schemeRepository.findByClientUid(clientUid);
        return schemesDALM.stream()
                .map(schemeConverter::toBLM)
                .collect(Collectors.toList());
    }

    @Override
    public ConnectionSchemeBLM updateScheme(UUID clientUid, UUID schemeUid, ConnectionSchemeDTO schemeDTO) {
        ConnectionSchemeDALM existingScheme = schemeRepository.findByUid(schemeUid);
        if (!clientUid.equals(existingScheme.getClientUid())) {
            throw new SecurityException("Scheme doesn't belong to the authenticated client");
        }

        schemeValidator.validate(schemeDTO);
        ConnectionSchemeBLM schemeBLM = schemeConverter.toBLM(schemeDTO);

        // Проверяем, что клиент из токена совпадает с клиентом схемы
        if (!clientUid.equals(schemeBLM.getClientUid())) {
            throw new SecurityException("Client UID from token doesn't match scheme client UID");
        }

        // Проверяем, что UID не изменяется
        if (!schemeUid.equals(schemeBLM.getUid())) {
            throw new IllegalArgumentException("Cannot change scheme UID");
        }

        ConnectionSchemeDALM schemeDALM = schemeConverter.toDALM(schemeBLM);
        schemeRepository.update(schemeDALM);

        log.info("Connection scheme updated: {} for client: {}", schemeUid, clientUid);
        return schemeBLM;
    }

    @Override
    public void deleteScheme(UUID clientUid, UUID schemeUid) {
        ConnectionSchemeDALM existingScheme = schemeRepository.findByUid(schemeUid);
        if (!clientUid.equals(existingScheme.getClientUid())) {
            throw new SecurityException("Scheme doesn't belong to the authenticated client");
        }

        schemeRepository.delete(schemeUid);
        log.info("Connection scheme deleted: {} for client: {}", schemeUid, clientUid);
    }

    @Override
    public boolean schemeExists(UUID clientUid, UUID schemeUid) {
        return schemeRepository.exists(schemeUid);
    }

    @Override
    public Map<String, Object> getHealthStatus() {
        Map<String, Object> authServiceHealth;
        try {
            authServiceHealth = authServiceClient.healthCheck();
        } catch (Exception e) {
            authServiceHealth = Map.of("status", "DOWN");
        }
        return Map.of(
                "status", "OK",
                "service", "connection-scheme-service",
                "timestamp", System.currentTimeMillis(),
                "auth-service: ", authServiceHealth);
    }
}// FeignErrorDecoder.java
package com.service.connectionscheme.client;

import feign.Response;
import feign.codec.ErrorDecoder;
import org.springframework.http.HttpStatus;
import org.springframework.web.server.ResponseStatusException;

public class FeignErrorDecoder implements ErrorDecoder {

    @Override
    public Exception decode(String methodKey, Response response) {
        switch (response.status()) {
            case 401:
                return new ResponseStatusException(HttpStatus.UNAUTHORIZED, "Invalid access token");
            case 403:
                return new ResponseStatusException(HttpStatus.FORBIDDEN, "Access denied");
            case 404:
                return new ResponseStatusException(HttpStatus.NOT_FOUND, "Resource not found");
            default:
                return new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, 
                    "Auth service error: " + response.status());
        }
    }
}// JwtAuthenticationFilter.java
package com.service.connectionscheme.client;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Collections;

@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final AuthServiceClient authServiceClient;

    @Override
    protected void doFilterInternal(HttpServletRequest request, 
                                  HttpServletResponse response, 
                                  FilterChain filterChain) throws ServletException, IOException {
        
        String authorizationHeader = request.getHeader("Authorization");
        
        if (authorizationHeader != null && authorizationHeader.startsWith("Bearer ")) {
            String token = authorizationHeader.substring(7);
            
            try {
                // Валидируем токен через auth service
                authServiceClient.validateAccessToken(token);
                
                // Получаем client UID из токена
                String clientUid = authServiceClient.getAccessTokenClientUID(token).toString();
                
                // Создаем аутентификацию
                Authentication authentication = new UsernamePasswordAuthenticationToken(
                    clientUid, 
                    null, 
                    Collections.emptyList()
                );
                
                SecurityContextHolder.getContext().setAuthentication(authentication);
                
            } catch (Exception e) {
                SecurityContextHolder.clearContext();
                response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Invalid token: " + e.getMessage());
                return;
            }
        }
        
        filterChain.doFilter(request, response);
    }
}// AuthServiceClient.java
package com.service.connectionscheme.client;

import java.util.Map;
import java.util.UUID;

import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestParam;

@FeignClient(name = "auth-service", url = "${auth.service.url}")
public interface AuthServiceClient {
    
    @GetMapping("/extract/accessTokenClientUID")
    UUID getAccessTokenClientUID(@RequestParam String accessToken);
    
    @GetMapping("/validate/token/access")
    void validateAccessToken(@RequestParam String accessToken);

    @GetMapping("/health")
    Map<String, Object> healthCheck();
}// ConnectionSchemeService.java
package com.service.connectionscheme;

import java.util.List;
import java.util.Map;
import java.util.UUID;

import com.connection.scheme.model.ConnectionSchemeBLM;
import com.connection.scheme.model.ConnectionSchemeDTO;

public interface ConnectionSchemeService {
    ConnectionSchemeBLM createScheme(UUID clientUuid, ConnectionSchemeDTO schemeDTO);
    ConnectionSchemeBLM getSchemeByUid(UUID clientUuid, UUID schemeUid);
    List<ConnectionSchemeBLM> getSchemesByClient(UUID clientUuid);
    ConnectionSchemeBLM updateScheme(UUID clientUuid, UUID schemeUid, ConnectionSchemeDTO schemeDTO);
    void deleteScheme(UUID clientUuid, UUID schemeUid);
    boolean schemeExists(UUID clientUuid, UUID schemeUid);
    Map<String, Object> getHealthStatus();
}// ConnectionSchemeController.java
package com.service.connectionscheme;

import java.util.List;
import java.util.UUID;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.connection.scheme.model.ConnectionSchemeBLM;
import com.connection.scheme.model.ConnectionSchemeDTO;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/connection-scheme-service")
public class ConnectionSchemeController {
    
    private final ConnectionSchemeService connectionSchemeService;

    @PostMapping("/schemes")
    public ResponseEntity<ConnectionSchemeBLM> createScheme(
            @RequestHeader("Authorization") String authorizationHeader,
            @RequestBody ConnectionSchemeDTO schemeDTO) {
        
        String accessToken = extractToken(authorizationHeader);
        log.info("Creating connection scheme for client");
        
        ConnectionSchemeBLM scheme = connectionSchemeService.createScheme(accessToken, schemeDTO);
        return ResponseEntity.ok(scheme);
    }

    @GetMapping("/schemes/{schemeUid}")
    public ResponseEntity<ConnectionSchemeBLM> getScheme(
            @RequestHeader("Authorization") String authorizationHeader,
            @PathVariable UUID schemeUid) {
        
        String accessToken = extractToken(authorizationHeader);
        log.info("Getting connection scheme: {}", schemeUid);
        
        ConnectionSchemeBLM scheme = connectionSchemeService.getScheme(accessToken, schemeUid);
        return ResponseEntity.ok(scheme);
    }

    @GetMapping("/schemes")
    public ResponseEntity<List<ConnectionSchemeBLM>> getSchemesByClient(
            @RequestHeader("Authorization") String authorizationHeader) {
        
        String accessToken = extractToken(authorizationHeader);
        log.info("Getting all connection schemes for client");
        
        List<ConnectionSchemeBLM> schemes = connectionSchemeService.getSchemesByClient(accessToken);
        return ResponseEntity.ok(schemes);
    }

    @PutMapping("/schemes/{schemeUid}")
    public ResponseEntity<ConnectionSchemeBLM> updateScheme(
            @RequestHeader("Authorization") String authorizationHeader,
            @PathVariable UUID schemeUid,
            @RequestBody ConnectionSchemeDTO schemeDTO) {
        
        String accessToken = extractToken(authorizationHeader);
        log.info("Updating connection scheme: {}", schemeUid);
        
        ConnectionSchemeBLM scheme = connectionSchemeService.updateScheme(accessToken, schemeUid, schemeDTO);
        return ResponseEntity.ok(scheme);
    }

    @DeleteMapping("/schemes/{schemeUid}")
    public ResponseEntity<Void> deleteScheme(
            @RequestHeader("Authorization") String authorizationHeader,
            @PathVariable UUID schemeUid) {
        
        String accessToken = extractToken(authorizationHeader);
        log.info("Deleting connection scheme: {}", schemeUid);
        
        connectionSchemeService.deleteScheme(accessToken, schemeUid);
        return ResponseEntity.noContent().build();
    }

    @GetMapping("/health")
    public ResponseEntity<?> healthCheck() {
        log.info("Health check: status: OK, service: connection-scheme-service, timestamp: {}", 
                System.currentTimeMillis());

        return ResponseEntity.ok().body(connectionSchemeService.getHealthStatus());
    }

    private String extractToken(String authorizationHeader) {
        if (authorizationHeader == null || !authorizationHeader.startsWith("Bearer ")) {
            throw new SecurityException("Invalid authorization header");
        }
        return authorizationHeader.substring(7);
    }
}package com.service.connectionscheme.mother;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import com.connection.scheme.model.ConnectionSchemeBLM;
import com.connection.scheme.model.ConnectionSchemeDALM;
import com.connection.scheme.model.ConnectionSchemeDTO;

public class ConnectionSchemeObjectMother {

    public static final UUID CLIENT_UUID = UUID.fromString("123e4567-e89b-12d3-a456-426614174000");
    public static final UUID SCHEME_UUID = UUID.fromString("323e4567-e89b-12d3-a456-426614174003");
    public static final UUID BUFFER_UUID_1 = UUID.fromString("423e4567-e89b-12d3-a456-426614174004");
    public static final UUID BUFFER_UUID_2 = UUID.fromString("523e4567-e89b-12d3-a456-426614174005");
    public static final UUID BUFFER_UUID_3 = UUID.fromString("623e4567-e89b-12d3-a456-426614174006");
    
    public static final String VALID_TOKEN = "valid-token-123";
    public static final String INVALID_TOKEN = "invalid-token-456";
    
    public static final String SCHEME_JSON = "{" +
        "\"usedBuffers\": [\"" + BUFFER_UUID_1 + "\", \"" + BUFFER_UUID_2 + "\"], " +
        "\"bufferTransitions\": {" +
            "\"" + BUFFER_UUID_1 + "\": [\"" + BUFFER_UUID_2 + "\"], " +
            "\"" + BUFFER_UUID_2 + "\": [\"" + BUFFER_UUID_3 + "\"]" +
        "}" +
    "}";

    public static ConnectionSchemeDTO createValidSchemeDTO() {
        return ConnectionSchemeDTO.builder()
            .uid(SCHEME_UUID.toString())
            .clientUid(CLIENT_UUID.toString())
            .schemeJson(SCHEME_JSON)
            .build();
    }

    public static ConnectionSchemeDTO createInvalidSchemeDTO() {
        return ConnectionSchemeDTO.builder()
            .uid("invalid-uuid")
            .clientUid("invalid-client-uuid")
            .schemeJson("") // empty json
            .build();
    }

    public static ConnectionSchemeDTO createInvalidJsonStructureSchemeDTO() {
        return ConnectionSchemeDTO.builder()
            .uid(SCHEME_UUID.toString())
            .clientUid(CLIENT_UUID.toString())
            .schemeJson("{\"invalid\": \"structure\"}") // missing required fields
            .build();
    }

    public static ConnectionSchemeBLM createValidSchemeBLM() {
        Map<UUID, List<UUID>> bufferTransitions = new HashMap<>();
        bufferTransitions.put(BUFFER_UUID_1, Arrays.asList(BUFFER_UUID_2));
        bufferTransitions.put(BUFFER_UUID_2, Arrays.asList(BUFFER_UUID_3));
        
        return ConnectionSchemeBLM.builder()
            .uid(SCHEME_UUID)
            .clientUid(CLIENT_UUID)
            .schemeJson(SCHEME_JSON)
            .usedBuffers(Arrays.asList(BUFFER_UUID_1, BUFFER_UUID_2))
            .bufferTransitions(bufferTransitions)
            .build();
    }

    public static ConnectionSchemeBLM createSchemeBLMWithEmptyBuffers() {
        return ConnectionSchemeBLM.builder()
            .uid(SCHEME_UUID)
            .clientUid(CLIENT_UUID)
            .schemeJson("{\"usedBuffers\": [], \"bufferTransitions\": {}}")
            .usedBuffers(Arrays.asList())
            .bufferTransitions(new HashMap<>())
            .build();
    }

    public static ConnectionSchemeDALM createValidSchemeDALM() {
        return ConnectionSchemeDALM.builder()
            .uid(SCHEME_UUID)
            .clientUid(CLIENT_UUID)
            .schemeJson(SCHEME_JSON)
            .usedBuffers(Arrays.asList(BUFFER_UUID_1, BUFFER_UUID_2))
            .build();
    }

    public static ConnectionSchemeDALM createSchemeDALMWithUsedBuffers(List<UUID> usedBuffers) {
        return ConnectionSchemeDALM.builder()
            .uid(SCHEME_UUID)
            .clientUid(CLIENT_UUID)
            .schemeJson(SCHEME_JSON)
            .usedBuffers(usedBuffers)
            .build();
    }

    public static ConnectionSchemeDTO createSchemeDTOWithDifferentClient() {
        return ConnectionSchemeDTO.builder()
            .uid(SCHEME_UUID.toString())
            .clientUid(UUID.randomUUID().toString()) // different client
            .schemeJson(SCHEME_JSON)
            .build();
    }

    public static ConnectionSchemeDTO createSchemeDTOWithDifferentUid() {
        return ConnectionSchemeDTO.builder()
            .uid(UUID.randomUUID().toString()) // different UID
            .clientUid(CLIENT_UUID.toString())
            .schemeJson(SCHEME_JSON)
            .build();
    }

    public static ConnectionSchemeDTO createSchemeDTOWithNullFields() {
        return ConnectionSchemeDTO.builder()
            .uid(null)
            .clientUid(null)
            .schemeJson(null)
            .build();
    }

    public static ConnectionSchemeBLM createSchemeBLMWithNullFields() {
        return ConnectionSchemeBLM.builder()
            .uid(null)
            .clientUid(null)
            .schemeJson(null)
            .usedBuffers(null)
            .bufferTransitions(null)
            .build();
    }

    public static ConnectionSchemeDALM createSchemeDALMWithNullFields() {
        return ConnectionSchemeDALM.builder()
            .uid(null)
            .clientUid(null)
            .schemeJson(null)
            .usedBuffers(null)
            .build();
    }

    public static ConnectionSchemeDTO createSchemeDTOForBufferTest(UUID bufferUid) {
        String bufferSpecificJson = "{" +
            "\"usedBuffers\": [\"" + bufferUid + "\"], " +
            "\"bufferTransitions\": {\"" + bufferUid + "\": []}" +
        "}";
        
        return ConnectionSchemeDTO.builder()
            .uid(UUID.randomUUID().toString())
            .clientUid(CLIENT_UUID.toString())
            .schemeJson(bufferSpecificJson)
            .build();
    }
}package com.service.connectionscheme;

import static com.service.connectionscheme.mother.ConnectionSchemeObjectMother.*;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.web.server.ResponseStatusException;

import com.connection.scheme.converter.ConnectionSchemeConverter;
import com.connection.scheme.exception.ConnectionSchemeAlreadyExistsException;
import com.connection.scheme.model.ConnectionSchemeBLM;
import com.connection.scheme.model.ConnectionSchemeDALM;
import com.connection.scheme.model.ConnectionSchemeDTO;
import com.connection.scheme.repository.ConnectionSchemeRepository;
import com.connection.scheme.validator.ConnectionSchemeValidator;
import com.service.connectionscheme.client.AuthServiceClient;

@ExtendWith(MockitoExtension.class)
@DisplayName("Connection Scheme Service Implementation Tests")
class ConnectionSchemeServiceImplLondonTest {

    @Mock
    private ConnectionSchemeRepository schemeRepository;

    @Mock
    private ConnectionSchemeConverter schemeConverter;

    @Mock
    private ConnectionSchemeValidator schemeValidator;

    @Mock
    private AuthServiceClient authServiceClient;

    @InjectMocks
    private ConnectionSchemeServiceImpl connectionSchemeService;

    @BeforeEach
    void setUp() {
        // Пустой метод - заглушки создаем только в тех тестах, где они нужны
    }

    @Test
    @DisplayName("Create scheme - Positive")
    void shouldCreateSchemeWhenValidData() {
        // Arrange
        ConnectionSchemeDTO schemeDTO = createValidSchemeDTO();
        ConnectionSchemeBLM schemeBLM = createValidSchemeBLM();
        ConnectionSchemeDALM schemeDALM = createValidSchemeDALM();

        when(authServiceClient.getAccessTokenClientUID(VALID_TOKEN)).thenReturn(CLIENT_UUID);
        when(schemeConverter.toBLM(schemeDTO)).thenReturn(schemeBLM);
        when(schemeConverter.toDALM(schemeBLM)).thenReturn(schemeDALM);
        when(schemeRepository.exists(SCHEME_UUID)).thenReturn(false);

        // Act
        ConnectionSchemeBLM result = connectionSchemeService.createScheme(VALID_TOKEN, schemeDTO);

        // Assert
        assertThat(result).isNotNull();
        assertThat(result.getUid()).isEqualTo(SCHEME_UUID);
        assertThat(result.getUsedBuffers()).isEqualTo(Arrays.asList(BUFFER_UUID_1, BUFFER_UUID_2));
        assertThat(result.getBufferTransitions()).hasSize(2);
        verify(authServiceClient).validateAccessToken(VALID_TOKEN);
        verify(schemeValidator).validate(schemeDTO);
        verify(schemeRepository).add(schemeDALM);
    }

    @Test
    @DisplayName("Create scheme - Negative: Token validation fails")
    void shouldThrowExceptionWhenTokenValidationFails() {
        // Arrange
        ConnectionSchemeDTO schemeDTO = createValidSchemeDTO();
        
        doThrow(new ResponseStatusException(org.springframework.http.HttpStatus.UNAUTHORIZED))
            .when(authServiceClient).validateAccessToken(INVALID_TOKEN);

        // Act & Assert
        assertThatThrownBy(() -> connectionSchemeService.createScheme(INVALID_TOKEN, schemeDTO))
            .isInstanceOf(ResponseStatusException.class)
            .hasMessageContaining("401 UNAUTHORIZED");

        verify(schemeValidator, never()).validate(any(ConnectionSchemeDTO.class));
        verify(schemeRepository, never()).add(any());
        verify(authServiceClient, never()).getAccessTokenClientUID(any());
    }

    @Test
    @DisplayName("Create scheme - Negative: Client UID mismatch")
    void shouldThrowExceptionWhenClientUidMismatch() {
        // Arrange
        ConnectionSchemeDTO schemeDTO = createSchemeDTOWithDifferentClient();
        UUID differentClientUuid = UUID.randomUUID();
        
        Map<UUID, List<UUID>> bufferTransitions = new HashMap<>();
        bufferTransitions.put(BUFFER_UUID_1, Arrays.asList(BUFFER_UUID_2));
        
        ConnectionSchemeBLM schemeBLM = ConnectionSchemeBLM.builder()
            .uid(SCHEME_UUID)
            .clientUid(differentClientUuid) // different client
            .schemeJson(SCHEME_JSON)
            .usedBuffers(Arrays.asList(BUFFER_UUID_1, BUFFER_UUID_2))
            .bufferTransitions(bufferTransitions)
            .build();

        when(authServiceClient.getAccessTokenClientUID(VALID_TOKEN)).thenReturn(CLIENT_UUID);
        when(schemeConverter.toBLM(schemeDTO)).thenReturn(schemeBLM);

        // Act & Assert
        assertThatThrownBy(() -> connectionSchemeService.createScheme(VALID_TOKEN, schemeDTO))
            .isInstanceOf(SecurityException.class)
            .hasMessageContaining("Client UID from token doesn't match");

        verify(authServiceClient).validateAccessToken(VALID_TOKEN);
        verify(schemeValidator).validate(schemeDTO);
        verify(schemeRepository, never()).add(any());
    }

    @Test
    @DisplayName("Create scheme - Negative: Scheme already exists")
    void shouldThrowExceptionWhenSchemeAlreadyExists() {
        // Arrange
        ConnectionSchemeDTO schemeDTO = createValidSchemeDTO();
        ConnectionSchemeBLM schemeBLM = createValidSchemeBLM();

        when(authServiceClient.getAccessTokenClientUID(VALID_TOKEN)).thenReturn(CLIENT_UUID);
        when(schemeConverter.toBLM(schemeDTO)).thenReturn(schemeBLM);
        when(schemeRepository.exists(SCHEME_UUID)).thenReturn(true);

        // Act & Assert
        assertThatThrownBy(() -> connectionSchemeService.createScheme(VALID_TOKEN, schemeDTO))
            .isInstanceOf(ConnectionSchemeAlreadyExistsException.class);

        verify(authServiceClient).validateAccessToken(VALID_TOKEN);
        verify(schemeValidator).validate(schemeDTO);
        verify(schemeRepository, never()).add(any());
    }

    @Test
    @DisplayName("Get scheme - Positive")
    void shouldGetSchemeWhenValidRequest() {
        // Arrange
        ConnectionSchemeDALM schemeDALM = createValidSchemeDALM();
        ConnectionSchemeBLM expectedBLM = createValidSchemeBLM();

        when(authServiceClient.getAccessTokenClientUID(VALID_TOKEN)).thenReturn(CLIENT_UUID);
        when(schemeRepository.findByUid(SCHEME_UUID)).thenReturn(schemeDALM);
        when(schemeConverter.toBLM(schemeDALM)).thenReturn(expectedBLM);

        // Act
        ConnectionSchemeBLM result = connectionSchemeService.getScheme(VALID_TOKEN, SCHEME_UUID);

        // Assert
        assertThat(result).isNotNull();
        assertThat(result.getUid()).isEqualTo(SCHEME_UUID);
        assertThat(result.getUsedBuffers()).isEqualTo(Arrays.asList(BUFFER_UUID_1, BUFFER_UUID_2));
        assertThat(result.getBufferTransitions()).hasSize(2);
        verify(authServiceClient).validateAccessToken(VALID_TOKEN);
        verify(schemeRepository).findByUid(SCHEME_UUID);
    }

    @Test
    @DisplayName("Get scheme - Negative: Scheme doesn't belong to client")
    void shouldThrowExceptionWhenSchemeNotBelongsToClient() {
        // Arrange
        UUID differentClientUuid = UUID.randomUUID();
        ConnectionSchemeDALM schemeDALM = ConnectionSchemeDALM.builder()
            .uid(SCHEME_UUID)
            .clientUid(differentClientUuid) // different client
            .schemeJson(SCHEME_JSON)
            .usedBuffers(Arrays.asList(BUFFER_UUID_1, BUFFER_UUID_2))
            .build();

        when(authServiceClient.getAccessTokenClientUID(VALID_TOKEN)).thenReturn(CLIENT_UUID);
        when(schemeRepository.findByUid(SCHEME_UUID)).thenReturn(schemeDALM);

        // Act & Assert
        assertThatThrownBy(() -> connectionSchemeService.getScheme(VALID_TOKEN, SCHEME_UUID))
            .isInstanceOf(SecurityException.class)
            .hasMessageContaining("doesn't belong");

        verify(authServiceClient).validateAccessToken(VALID_TOKEN);
        verify(schemeRepository).findByUid(SCHEME_UUID);
        verify(schemeConverter, never()).toBLM(any(ConnectionSchemeDALM.class));
    }

    @Test
    @DisplayName("Get schemes by client - Positive")
    void shouldGetSchemesByClientWhenValidRequest() {
        // Arrange
        ConnectionSchemeDALM schemeDALM = createValidSchemeDALM();
        ConnectionSchemeBLM expectedBLM = createValidSchemeBLM();
        List<ConnectionSchemeDALM> schemesDALM = Collections.singletonList(schemeDALM);

        when(authServiceClient.getAccessTokenClientUID(VALID_TOKEN)).thenReturn(CLIENT_UUID);
        when(schemeRepository.findByClientUid(CLIENT_UUID)).thenReturn(schemesDALM);
        when(schemeConverter.toBLM(schemeDALM)).thenReturn(expectedBLM);

        // Act
        List<ConnectionSchemeBLM> result = connectionSchemeService.getSchemesByClient(VALID_TOKEN);

        // Assert
        assertThat(result).isNotEmpty();
        assertThat(result.get(0).getUid()).isEqualTo(SCHEME_UUID);
        assertThat(result.get(0).getUsedBuffers()).isEqualTo(Arrays.asList(BUFFER_UUID_1, BUFFER_UUID_2));
        assertThat(result.get(0).getBufferTransitions()).hasSize(2);
        verify(authServiceClient).validateAccessToken(VALID_TOKEN);
        verify(schemeRepository).findByClientUid(CLIENT_UUID);
    }

    @Test
    @DisplayName("Update scheme - Positive")
    void shouldUpdateSchemeWhenValidData() {
        // Arrange
        ConnectionSchemeDTO schemeDTO = createValidSchemeDTO();
        ConnectionSchemeBLM schemeBLM = createValidSchemeBLM();
        ConnectionSchemeDALM schemeDALM = createValidSchemeDALM();
        ConnectionSchemeDALM existingScheme = createValidSchemeDALM();

        when(authServiceClient.getAccessTokenClientUID(VALID_TOKEN)).thenReturn(CLIENT_UUID);
        when(schemeRepository.findByUid(SCHEME_UUID)).thenReturn(existingScheme);
        when(schemeConverter.toBLM(schemeDTO)).thenReturn(schemeBLM);
        when(schemeConverter.toDALM(schemeBLM)).thenReturn(schemeDALM);

        // Act
        ConnectionSchemeBLM result = connectionSchemeService.updateScheme(VALID_TOKEN, SCHEME_UUID, schemeDTO);

        // Assert
        assertThat(result).isNotNull();
        assertThat(result.getUsedBuffers()).isEqualTo(Arrays.asList(BUFFER_UUID_1, BUFFER_UUID_2));
        assertThat(result.getBufferTransitions()).hasSize(2);
        verify(authServiceClient).validateAccessToken(VALID_TOKEN);
        verify(schemeValidator).validate(schemeDTO);
        verify(schemeRepository).update(schemeDALM);
    }

    @Test
    @DisplayName("Update scheme - Negative: UID change attempt")
    void shouldThrowExceptionWhenTryingToChangeUid() {
        // Arrange
        ConnectionSchemeDTO schemeDTO = createSchemeDTOWithDifferentUid();
        
        Map<UUID, List<UUID>> bufferTransitions = new HashMap<>();
        bufferTransitions.put(BUFFER_UUID_1, Arrays.asList(BUFFER_UUID_2));
        
        ConnectionSchemeBLM schemeBLM = ConnectionSchemeBLM.builder()
            .uid(UUID.randomUUID()) // different UID
            .clientUid(CLIENT_UUID)
            .schemeJson(SCHEME_JSON)
            .usedBuffers(Arrays.asList(BUFFER_UUID_1, BUFFER_UUID_2))
            .bufferTransitions(bufferTransitions)
            .build();
            
        ConnectionSchemeDALM existingScheme = createValidSchemeDALM();

        when(authServiceClient.getAccessTokenClientUID(VALID_TOKEN)).thenReturn(CLIENT_UUID);
        when(schemeRepository.findByUid(SCHEME_UUID)).thenReturn(existingScheme);
        when(schemeConverter.toBLM(schemeDTO)).thenReturn(schemeBLM);

        // Act & Assert
        assertThatThrownBy(() -> connectionSchemeService.updateScheme(VALID_TOKEN, SCHEME_UUID, schemeDTO))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessageContaining("Cannot change scheme UID");

        verify(authServiceClient).validateAccessToken(VALID_TOKEN);
        verify(schemeValidator).validate(schemeDTO);
        verify(schemeRepository, never()).update(any());
    }

    @Test
    @DisplayName("Update scheme - Negative: Client UID change attempt")
    void shouldThrowExceptionWhenTryingToChangeClientUid() {
        // Arrange
        ConnectionSchemeDTO schemeDTO = createSchemeDTOWithDifferentClient();
        
        Map<UUID, List<UUID>> bufferTransitions = new HashMap<>();
        bufferTransitions.put(BUFFER_UUID_1, Arrays.asList(BUFFER_UUID_2));
        
        ConnectionSchemeBLM schemeBLM = ConnectionSchemeBLM.builder()
            .uid(SCHEME_UUID)
            .clientUid(UUID.randomUUID()) // different client UID
            .schemeJson(SCHEME_JSON)
            .usedBuffers(Arrays.asList(BUFFER_UUID_1, BUFFER_UUID_2))
            .bufferTransitions(bufferTransitions)
            .build();
            
        ConnectionSchemeDALM existingScheme = createValidSchemeDALM();

        when(authServiceClient.getAccessTokenClientUID(VALID_TOKEN)).thenReturn(CLIENT_UUID);
        when(schemeRepository.findByUid(SCHEME_UUID)).thenReturn(existingScheme);
        when(schemeConverter.toBLM(schemeDTO)).thenReturn(schemeBLM);

        // Act & Assert
        assertThatThrownBy(() -> connectionSchemeService.updateScheme(VALID_TOKEN, SCHEME_UUID, schemeDTO))
            .isInstanceOf(RuntimeException.class);

        verify(authServiceClient).validateAccessToken(VALID_TOKEN);
        verify(schemeValidator).validate(schemeDTO);
        verify(schemeRepository, never()).update(any());
    }

    @Test
    @DisplayName("Delete scheme - Positive")
    void shouldDeleteSchemeWhenValidRequest() {
        // Arrange
        ConnectionSchemeDALM existingScheme = createValidSchemeDALM();

        when(authServiceClient.getAccessTokenClientUID(VALID_TOKEN)).thenReturn(CLIENT_UUID);
        when(schemeRepository.findByUid(SCHEME_UUID)).thenReturn(existingScheme);

        // Act
        connectionSchemeService.deleteScheme(VALID_TOKEN, SCHEME_UUID);

        // Assert
        verify(authServiceClient).validateAccessToken(VALID_TOKEN);
        verify(schemeRepository).delete(SCHEME_UUID);
    }

    @Test
    @DisplayName("Scheme exists - Positive")
    void shouldReturnTrueWhenSchemeExists() {
        // Arrange
        when(schemeRepository.exists(SCHEME_UUID)).thenReturn(true);

        // Act
        boolean result = connectionSchemeService.schemeExists(VALID_TOKEN, SCHEME_UUID);

        // Assert
        assertThat(result).isTrue();
        verify(authServiceClient).validateAccessToken(VALID_TOKEN);
        verify(schemeRepository).exists(SCHEME_UUID);
    }

    @Test
    @DisplayName("Scheme exists - Negative: Scheme not found")
    void shouldReturnFalseWhenSchemeNotExists() {
        // Arrange
        when(schemeRepository.exists(SCHEME_UUID)).thenReturn(false);

        // Act
        boolean result = connectionSchemeService.schemeExists(VALID_TOKEN, SCHEME_UUID);

        // Assert
        assertThat(result).isFalse();
        verify(authServiceClient).validateAccessToken(VALID_TOKEN);
        verify(schemeRepository).exists(SCHEME_UUID);
    }

    @Test
    @DisplayName("Get schemes by buffer - Positive")
    void shouldGetSchemesByBufferWhenValidRequest() {
        // Arrange
        ConnectionSchemeDALM schemeDALM = createValidSchemeDALM();
        ConnectionSchemeBLM expectedBLM = createValidSchemeBLM();
        List<ConnectionSchemeDALM> schemesDALM = Collections.singletonList(schemeDALM);

        when(authServiceClient.getAccessTokenClientUID(VALID_TOKEN)).thenReturn(CLIENT_UUID);
        when(schemeRepository.findByBufferUid(BUFFER_UUID_1)).thenReturn(schemesDALM);
        when(schemeConverter.toBLM(schemeDALM)).thenReturn(expectedBLM);

        // Act
        List<ConnectionSchemeBLM> result = connectionSchemeService.getSchemesByBuffer(VALID_TOKEN, BUFFER_UUID_1);

        // Assert
        assertThat(result).isNotEmpty();
        assertThat(result.get(0).getUid()).isEqualTo(SCHEME_UUID);
        assertThat(result.get(0).getUsedBuffers()).contains(BUFFER_UUID_1);
        verify(authServiceClient).validateAccessToken(VALID_TOKEN);
        verify(schemeRepository).findByBufferUid(BUFFER_UUID_1);
    }

    @Test
    @DisplayName("Health check - Positive")
    void shouldReturnHealthStatus() {
        // Arrange
        Map<String, Object> authHealth = Map.of("status", "OK");
        when(authServiceClient.healthCheck()).thenReturn(authHealth);

        // Act
        Map<String, Object> result = connectionSchemeService.getHealthStatus();

        // Assert
        assertThat(result).isNotNull();
        assertThat(result.get("status")).isEqualTo("OK");
        assertThat(result.get("service")).isEqualTo("connection-scheme-service");
        assertThat(result.get("auth-service: ")).isEqualTo(authHealth);
        verify(authServiceClient).healthCheck();
    }

    @Test
    @DisplayName("Health check - Negative: Auth service down")
    void shouldHandleAuthServiceDownInHealthCheck() {
        // Arrange
        when(authServiceClient.healthCheck())
            .thenThrow(new ResponseStatusException(org.springframework.http.HttpStatus.INTERNAL_SERVER_ERROR));

        // Act
        Map<String, Object> result = connectionSchemeService.getHealthStatus();

        // Assert
        assertThat(result).isNotNull();
        assertThat(result.get("status")).isEqualTo("OK");
        assertThat(result.get("service")).isEqualTo("connection-scheme-service");
        assertThat(result.get("auth-service: ").toString().contains("DOWN"));
        verify(authServiceClient).healthCheck();
    }
}