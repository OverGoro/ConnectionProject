// ConnectionSchemeServiceApplication.java
package com.service.connectionscheme;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class ConnectionSchemeServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(ConnectionSchemeServiceApplication.class, args);
    }
}// ConnectionSchemeUtilsConfig.java
package com.service.connectionscheme.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.connection.scheme.converter.ConnectionSchemeConverter;
import com.connection.scheme.validator.ConnectionSchemeValidator;

@Configuration
public class ConnectionSchemeUtilsConfig {
    @Bean("ConnectionSchemeConverter")
    ConnectionSchemeConverter connectionSchemeConverter(){
        return new ConnectionSchemeConverter();
    }

    @Bean("ConnectionSchemeValidator")
    ConnectionSchemeValidator connectionSchemeValidator(){
        return new ConnectionSchemeValidator();
    }
}// SwaggerConfig.java
package com.service.connectionscheme.config;

import io.swagger.v3.oas.annotations.enums.SecuritySchemeType;
import io.swagger.v3.oas.annotations.security.SecurityScheme;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@SecurityScheme(
    name = "bearerAuth",
    type = SecuritySchemeType.HTTP,
    bearerFormat = "JWT",
    scheme = "bearer"
)
public class SwaggerConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("Connection Scheme Service API")
                        .version("1.0")
                        .description("API для управления схемами подключения"))
                .addSecurityItem(new SecurityRequirement().addList("bearerAuth"))
                .components(new Components()
                        .addSecuritySchemes("bearerAuth", 
                            new io.swagger.v3.oas.models.security.SecurityScheme()
                                .type(io.swagger.v3.oas.models.security.SecurityScheme.Type.HTTP)
                                .scheme("bearer")
                                .bearerFormat("JWT")));
    }
}// ConnectionSchemeRepositoryConfig.java
package com.service.connectionscheme.config;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.connection.scheme.repository.ConnectionSchemeRepository;
import com.connection.scheme.repository.ConnectionSchemeRepositorySQLImpl;

@Configuration
public class ConnectionSchemeRepositoryConfig {
    @Bean("ConnectionSchemeRepository")
    ConnectionSchemeRepository connectionSchemeRepository(@Qualifier("ConnectionSchemeJdbcTemplate") NamedParameterJdbcTemplate template){
        return new ConnectionSchemeRepositorySQLImpl(template);
    }
}package com.service.connectionscheme.config;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

import java.util.UUID;

@Component
public class SecurityUtils {

    public static UUID getCurrentClientUid() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        
        if (authentication == null || !authentication.isAuthenticated()) {
            throw new SecurityException("User not authenticated");
        }

        Object principal = authentication.getPrincipal();
        
        if (principal instanceof UUID) {
            return (UUID) principal;
        } else if (principal instanceof String) {
            try {
                return UUID.fromString((String) principal);
            } catch (IllegalArgumentException e) {
                throw new SecurityException("Invalid client UID format in principal");
            }
        } else {
            throw new SecurityException("Unexpected principal type: " + principal.getClass());
        }
    }

    public static String getCurrentClientUidAsString() {
        return getCurrentClientUid().toString();
    }
}package com.service.connectionscheme.config;

import java.util.HashMap;
import java.util.Map;

import org.apache.kafka.clients.admin.NewTopic;
import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.clients.producer.ProducerConfig;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.config.TopicBuilder;
import org.springframework.kafka.core.ConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaProducerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.core.ProducerFactory;
import org.springframework.kafka.listener.DefaultErrorHandler;
import org.springframework.kafka.support.serializer.ErrorHandlingDeserializer;
import org.springframework.kafka.support.serializer.JsonDeserializer;
import org.springframework.kafka.support.serializer.JsonSerializer;
import org.springframework.util.backoff.FixedBackOff;

import com.connection.auth.events.AuthEventConstants;
import com.connection.scheme.events.ConnectionSchemeEventConstants;

@Configuration
public class ConnectionSchemeKafkaConfig {
    @Value("${spring.kafka.bootstrap-servers:localhost:29092}")
    private String bootstrapServers;

    @Bean
    public NewTopic authResponsesTopic() {
        return TopicBuilder.name(AuthEventConstants.AUTH_RESPONSES_TOPIC)
                .partitions(3)
                .replicas(1)
                .build();
    }

    // Конфигурация топиков для connection-scheme-service
    @Bean
    public NewTopic connectionSchemeCommandsTopic() {
        return TopicBuilder.name(ConnectionSchemeEventConstants.CONNECTION_SCHEME_COMMANDS_TOPIC)
                .partitions(3)
                .replicas(1)
                .build();
    }

    @Bean
    public NewTopic connectionSchemeResponsesTopic() {
        return TopicBuilder.name(ConnectionSchemeEventConstants.CONNECTION_SCHEME_RESPONSES_TOPIC)
                .partitions(3)
                .replicas(1)
                .build();
    }

    @Bean
    public NewTopic connectionSchemeEventsTopic() {
        return TopicBuilder.name(ConnectionSchemeEventConstants.CONNECTION_SCHEME_EVENTS_TOPIC)
                .partitions(3)
                .replicas(1)
                .build();
    }

    // Конфигурация для Consumer с обработкой ошибок десериализации
    @Bean
    public ConsumerFactory<String, Object> consumerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        configProps.put(ConsumerConfig.GROUP_ID_CONFIG, "connection-scheme-service-group");
        configProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");
        configProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer.class);
        configProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer.class);
        
        // Конфигурация для ErrorHandlingDeserializer
        configProps.put(ErrorHandlingDeserializer.KEY_DESERIALIZER_CLASS, org.apache.kafka.common.serialization.StringDeserializer.class);
        configProps.put(ErrorHandlingDeserializer.VALUE_DESERIALIZER_CLASS, JsonDeserializer.class);
        
        // Конфигурация для JsonDeserializer
        configProps.put(JsonDeserializer.TRUSTED_PACKAGES, "com.connection.auth.events.commands,com.connection.common.events,com.connection.device.events.commands,com.connection.auth.events.responses");
        configProps.put(JsonDeserializer.USE_TYPE_INFO_HEADERS, true);
        configProps.put(JsonDeserializer.REMOVE_TYPE_INFO_HEADERS, false);
        configProps.put(JsonDeserializer.VALUE_DEFAULT_TYPE, "com.connection.common.events.Command");
        
        return new DefaultKafkaConsumerFactory<>(configProps);
    }

    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, Object> kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory<String, Object> factory = 
            new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory());
        
        // Обработка ошибок десериализации - пропускаем некорректные сообщения
        DefaultErrorHandler errorHandler = new DefaultErrorHandler(
                (record, exception) -> {
                    org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger("KafkaErrorHandler");
                    logger.error("Skipping invalid message - Topic: {}, Partition: {}, Offset: {}, Key: {}, Error: {}",
                            record.topic(),
                            record.partition(),
                            record.offset(),
                            record.key(),
                            exception.getMessage());
                },
                new FixedBackOff(0L, 0L)
        );

        factory.setCommonErrorHandler(errorHandler);
        
        return factory;
    }

    // Конфигурация для Producer
    @Bean
    public ProducerFactory<String, Object> producerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, org.apache.kafka.common.serialization.StringSerializer.class);
        configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
        configProps.put(JsonSerializer.ADD_TYPE_INFO_HEADERS, true);
        return new DefaultKafkaProducerFactory<>(configProps);
    }

    @Bean
    public KafkaTemplate<String, Object> kafkaTemplate() {
        return new KafkaTemplate<>(producerFactory());
    }
}// ConnectionSchemeJDBCConfig.java
package com.service.connectionscheme.config;

import java.util.Properties;
import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.atomikos.jdbc.AtomikosDataSourceBean;

@Configuration
public class ConnectionSchemeJDBCConfig {
    
    @Value("${app.datasource.connection-scheme.xa-data-source-class-name:org.postgresql.xa.PGXADataSource}")
    private String xaDataSourceClassName;

    @Value("${app.datasource.connection-scheme.xa-properties.url}")
    private String jdbcUrl;

    @Value("${app.datasource.connection-scheme.xa-properties.user}")
    private String username;

    @Value("${app.datasource.connection-scheme.xa-properties.password}")
    private String password;

    @Value("${app.datasource.connection-scheme.unique-resource-name:connectionSchemeXADataSource}")
    private String uniqueResourceName;

    @Bean("ConnectionSchemeDataSource")
    DataSource connectionSchemeDataSource() {
        AtomikosDataSourceBean dataSource = new AtomikosDataSourceBean();
        dataSource.setUniqueResourceName(uniqueResourceName);
        dataSource.setXaDataSourceClassName(xaDataSourceClassName);
        
        Properties xaProperties = new Properties();
        xaProperties.setProperty("url", jdbcUrl);
        xaProperties.setProperty("user", username);
        xaProperties.setProperty("password", password);

        dataSource.setXaProperties(xaProperties);
        dataSource.setPoolSize(5);
        dataSource.setTestQuery("SELECT 1");

        return dataSource;
    }

    @Bean("ConnectionSchemeJdbcTemplate")
    NamedParameterJdbcTemplate connectionSchemeNamedParameterJdbcTemplate(
            @Qualifier("ConnectionSchemeDataSource") DataSource connectionSchemeDataSource) {
        return new NamedParameterJdbcTemplate(connectionSchemeDataSource);
    }
}package com.service.connectionscheme.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.jta.JtaTransactionManager;

import com.atomikos.icatch.jta.UserTransactionManager;

import jakarta.transaction.SystemException;

@Configuration
public class TransactionConfig {

    @Bean
    public UserTransactionManager userTransactionManager() throws SystemException{
        UserTransactionManager manager = new UserTransactionManager();
        manager.setTransactionTimeout(300);
        manager.setForceShutdown(true);
        return manager;
    }

    @Bean(name = "atomicosTransactionManager")
    public JtaTransactionManager jtaTransactionManager() throws SystemException {
        JtaTransactionManager jtaTransactionManager = new JtaTransactionManager();
        jtaTransactionManager.setTransactionManager(userTransactionManager());
        jtaTransactionManager.setUserTransaction(userTransactionManager());
        return jtaTransactionManager;
    }
}// SecurityConfig.java
package com.service.connectionscheme.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import com.service.connectionscheme.client.JwtKafkaAuthenticationFilter;

import lombok.RequiredArgsConstructor;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtKafkaAuthenticationFilter jwtKafkaAuthenticationFilter;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                .csrf(csrf -> csrf.disable()) // Отключаем CSRF для API
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/swagger-ui.html").permitAll()
                        .requestMatchers("/swagger-ui/**").permitAll()
                        .requestMatchers("/api-docs/**").permitAll()
                        .requestMatchers("/webjars/**").permitAll()
                        .requestMatchers("/v3/api-docs/**").permitAll()
                        .requestMatchers("/api/connection-scheme-service/health").permitAll()
                        .requestMatchers("/api/connection-scheme-service/**").authenticated()
                        .anyRequest().denyAll()
                )
                .addFilterBefore(jwtKafkaAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)
                .build();
    }
}// GlobalExceptionHandler.java
package com.service.connectionscheme.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import com.connection.scheme.exception.ConnectionSchemeNotFoundException;
import com.connection.scheme.exception.ConnectionSchemeValidateException;

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(SecurityException.class)
    public ResponseEntity<?> handleSecurityException(SecurityException e) {
        log.warn("Security exception: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(new ErrorResponse(
                "invalid_authorization",
                "Invalid or missing authorization header"));
    }

    @ExceptionHandler(ConnectionSchemeNotFoundException.class)
    public ResponseEntity<?> handleConnectionSchemeNotFoundException(
            ConnectionSchemeNotFoundException e) {
        log.warn("Connection scheme not found: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ErrorResponse(
                "connection_scheme_not_found",
                "Connection scheme not found"));
    }

    @ExceptionHandler(ConnectionSchemeValidateException.class)
    public ResponseEntity<?> handleConnectionSchemeValidationException(
            ConnectionSchemeValidateException e) {
        log.warn("Connection scheme validation failed: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(new ErrorResponse(
                "validation_failed",
                e.getMessage() != null ? e.getMessage() : "Invalid connection scheme data"));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<?> handleGenericException(Exception e) {
        log.error("Unexpected error occurred: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(new ErrorResponse(
                "internal_server_error",
                "An unexpected error occurred"));
    }
}// ErrorResponse.java
package com.service.connectionscheme.controller;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class ErrorResponse {
    private final String error;
    private final String message;
}// HealthResponse.java
package com.service.connectionscheme.controller;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class HealthResponse {
    private final String message;
}// ConnectionSchemeResponse.java
package com.service.connectionscheme.controller;

import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class ConnectionSchemeResponse {
    private final UUID schemeUid;
}// ConnectionSchemesListResponse.java
package com.service.connectionscheme.controller;

import com.connection.scheme.model.ConnectionSchemeDTO;

import lombok.AllArgsConstructor;
import lombok.Getter;

import java.util.List;

@AllArgsConstructor
@Getter
public class ConnectionSchemesListResponse {
    private final List<ConnectionSchemeDTO> schemes;
    private final PaginationInfo pagination;

    @AllArgsConstructor
    @Getter
    public static class PaginationInfo {
        private final int offset;
        private final int limit;
        private final int totalCount;
        private final boolean hasMore;
    }
}package com.service.connectionscheme.controller;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.connection.scheme.converter.ConnectionSchemeConverter;
import com.connection.scheme.model.ConnectionSchemeBLM;
import com.connection.scheme.model.ConnectionSchemeDTO;
import com.connection.scheme.validator.ConnectionSchemeValidator;
import com.service.connectionscheme.ConnectionSchemeService;
import com.service.connectionscheme.config.SecurityUtils;


import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/v1")
public class ConnectionSchemeController {
    @Qualifier("ApiConnectionSchemeService")
    private final ConnectionSchemeService connectionSchemeService;
    private final ConnectionSchemeValidator schemeValidator;
    private final ConnectionSchemeConverter schemeConverter;

    // Константы для пагинации по умолчанию
    private static final int DEFAULT_OFFSET = 0;
    private static final int DEFAULT_LIMIT = 50;
    private static final int MAX_LIMIT = 1000;

    @PostMapping("/schemes")
    public ResponseEntity<ConnectionSchemeResponse> createScheme(@RequestBody ConnectionSchemeDTO schemeDTO) {
        schemeValidator.validate(schemeDTO);
        ConnectionSchemeBLM scheme = connectionSchemeService.createScheme(schemeDTO);

        return ResponseEntity.ok(new ConnectionSchemeResponse(scheme.getUid()));
    }


    @GetMapping("/schemes")
    public ResponseEntity<ConnectionSchemesListResponse> getSchemes(
            @RequestParam(required = false) List<UUID> schemeUids,
            @RequestParam(defaultValue = "" + DEFAULT_OFFSET) int offset,
            @RequestParam(defaultValue = "" + DEFAULT_LIMIT) int limit) {
        
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        List<ConnectionSchemeBLM> schemes = null;

        if (schemeUids != null && !schemeUids.isEmpty()) {
            log.info("Getting specific connection schemes: {} with offset: {}, limit: {}", schemeUids, offset, limit);
            schemes = connectionSchemeService.getSchemeByUid(schemeUids);
        } else {
            // Получение всех схем клиента
            log.info("Getting all connection schemes for client with offset: {}, limit: {}", offset, limit);
            schemes = connectionSchemeService.getSchemesByClient(clientUid);
        }
        
        // Применяем пагинацию
        List<ConnectionSchemeBLM> paginatedSchemes = applyPagination(schemes, offset, limit);
        List<ConnectionSchemeDTO> schemeDTOs = paginatedSchemes.stream()
                .map(schemeConverter::toDTO)
                .collect(Collectors.toList());

        // Создаем информацию о пагинации
        ConnectionSchemesListResponse.PaginationInfo paginationInfo = 
            new ConnectionSchemesListResponse.PaginationInfo(
                offset, 
                limit, 
                schemes.size(), 
                (offset + limit) < schemes.size()
            );

        return ResponseEntity.ok(new ConnectionSchemesListResponse(schemeDTOs, paginationInfo));
    }

    @PutMapping("/schemes/{schemeUid}")
    public ResponseEntity<ConnectionSchemeResponse> updateScheme(
            @PathVariable UUID schemeUid,
            @RequestBody ConnectionSchemeDTO schemeDTO) {
        
        schemeValidator.validate(schemeDTO);
        ConnectionSchemeBLM scheme = connectionSchemeService.updateScheme(schemeUid, schemeDTO);

        return ResponseEntity.ok(new ConnectionSchemeResponse(scheme.getUid()));
    }

    @DeleteMapping("/schemes")
    public ResponseEntity<Void> deleteSchemes(
            @RequestParam(required = false) List<UUID> schemeUids) {
        
        if (schemeUids != null && !schemeUids.isEmpty()) {
            log.info("Deleting multiple connection schemes: {}", schemeUids);
            for (UUID uid : schemeUids) {
                connectionSchemeService.deleteScheme(uid);
            }
        } else {
            log.warn("No valid delete parameters provided");
            return ResponseEntity.badRequest().build();
        }

        return ResponseEntity.noContent().build();
    }

    @GetMapping("/health")
    public ResponseEntity<HealthResponse> healthCheck() {
        log.info("Health check: status: OK, service: connection-scheme-service, timestamp: {}", 
                System.currentTimeMillis());
                
        return ResponseEntity.ok().body(new HealthResponse(connectionSchemeService.getHealthStatus().toString()));
    }

    /**
     * Применяет пагинацию к списку схем подключения
     * 
     * @param schemes полный список схем подключения
     * @param offset смещение (начальная позиция)
     * @param limit максимальное количество элементов
     * @return пагинированный список схем подключения
     */
    private List<ConnectionSchemeBLM> applyPagination(List<ConnectionSchemeBLM> schemes, int offset, int limit) {
        // Валидация параметров пагинации
        if (offset < 0) {
            offset = DEFAULT_OFFSET;
        }
        
        if (limit <= 0 || limit > MAX_LIMIT) {
            limit = DEFAULT_LIMIT;
        }
        
        // Применяем пагинацию
        return schemes.stream()
                .skip(offset)
                .limit(limit)
                .collect(Collectors.toList());
    }
}package com.service.connectionscheme;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.connection.scheme.converter.ConnectionSchemeConverter;
import com.connection.scheme.exception.ConnectionSchemeAlreadyExistsException;
import com.connection.scheme.model.ConnectionSchemeBLM;
import com.connection.scheme.model.ConnectionSchemeDALM;
import com.connection.scheme.model.ConnectionSchemeDTO;
import com.connection.scheme.repository.ConnectionSchemeRepository;
import com.connection.scheme.validator.ConnectionSchemeValidator;
import com.service.connectionscheme.config.SecurityUtils;
import com.service.connectionscheme.kafka.TypedAuthKafkaClient;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RequiredArgsConstructor
@Service("ApiConnectionSchemeService")
@EnableAutoConfiguration(exclude = {
        JpaRepositoriesAutoConfiguration.class
})
@Transactional("atomicosTransactionManager")
public class ConnectionSchemeServiceImpl implements ConnectionSchemeService {

    private final ConnectionSchemeRepository schemeRepository;
    private final ConnectionSchemeConverter schemeConverter;
    private final ConnectionSchemeValidator schemeValidator;
    private final TypedAuthKafkaClient authKafkaClient;

    @Override
    public ConnectionSchemeBLM createScheme(ConnectionSchemeDTO schemeDTO) {
        schemeValidator.validate(schemeDTO);
        ConnectionSchemeBLM schemeBLM = schemeConverter.toBLM(schemeDTO);
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        if (!clientUid.equals(schemeBLM.getClientUid())) {
            throw new SecurityException("Client UID from token doesn't match scheme client UID");
        }

        if (schemeRepository.exists(schemeBLM.getUid())) {
            throw new ConnectionSchemeAlreadyExistsException(
                    "Scheme with UID '" + schemeBLM.getUid() + "' already exists");
        }

        ConnectionSchemeDALM schemeDALM = schemeConverter.toDALM(schemeBLM);
        schemeRepository.add(schemeDALM);

        log.info("Connection scheme created: {} for client: {}", schemeBLM.getUid(), clientUid);
        return schemeBLM;
    }

    @Override
    public ConnectionSchemeBLM getSchemeByUid(UUID schemeUid) {
        ConnectionSchemeDALM schemeDALM = schemeRepository.findByUid(schemeUid);
        UUID clientUid = SecurityUtils.getCurrentClientUid();

        if (!clientUid.equals(schemeDALM.getClientUid())) {
            throw new SecurityException("Scheme doesn't belong to the authenticated client");
        }

        return schemeConverter.toBLM(schemeDALM);
    }

    @Override
    public List<ConnectionSchemeBLM> getSchemeByUid(List<UUID> schemeUids) {
        Set<ConnectionSchemeBLM> connectionSchemeBLMs = new HashSet<>();
        for (UUID uuid : schemeUids) {
            connectionSchemeBLMs.add(getSchemeByUid(uuid));
        }
        return new ArrayList<ConnectionSchemeBLM>(connectionSchemeBLMs);
    }

    @Override
    public List<ConnectionSchemeBLM> getSchemesByClient(UUID clientUid) {
        List<ConnectionSchemeDALM> schemesDALM = schemeRepository.findByClientUid(clientUid);
        return schemesDALM.stream()
                .map(schemeConverter::toBLM)
                .collect(Collectors.toList());
    }

    @Override
    public ConnectionSchemeBLM updateScheme(UUID schemeUid, ConnectionSchemeDTO schemeDTO) {
        ConnectionSchemeDALM existingScheme = schemeRepository.findByUid(schemeUid);
        UUID clientUid = SecurityUtils.getCurrentClientUid();

        if (!clientUid.equals(existingScheme.getClientUid())) {
            throw new SecurityException("Scheme doesn't belong to the authenticated client");
        }

        schemeValidator.validate(schemeDTO);
        ConnectionSchemeBLM schemeBLM = schemeConverter.toBLM(schemeDTO);

        // Проверяем, что клиент из токена совпадает с клиентом схемы
        if (!clientUid.equals(schemeBLM.getClientUid())) {
            throw new SecurityException("Client UID from token doesn't match scheme client UID");
        }

        // Проверяем, что UID не изменяется
        if (!schemeUid.equals(schemeBLM.getUid())) {
            throw new IllegalArgumentException("Cannot change scheme UID");
        }

        ConnectionSchemeDALM schemeDALM = schemeConverter.toDALM(schemeBLM);
        schemeRepository.update(schemeDALM);

        log.info("Connection scheme updated: {} for client: {}", schemeUid, clientUid);
        return schemeBLM;
    }

    @Override
    public void deleteScheme(UUID schemeUid) {
        ConnectionSchemeDALM existingScheme = schemeRepository.findByUid(schemeUid);
        UUID clientUid = SecurityUtils.getCurrentClientUid();

        if (!clientUid.equals(existingScheme.getClientUid())) {
            throw new SecurityException("Scheme doesn't belong to the authenticated client");
        }

        schemeRepository.delete(schemeUid);
        log.info("Connection scheme deleted: {} for client: {}", schemeUid, clientUid);
    }

    @Override
    public boolean schemeExists(UUID schemeUid) {
        return schemeRepository.exists(schemeUid);
    }

    @Override
    public Map<String, Object> getHealthStatus() {
        try {
            var authHealth = authKafkaClient.healthCheck("connection-scheme-service")
                    .get(5, java.util.concurrent.TimeUnit.SECONDS);

            return Map.of(
                    "status", "OK",
                    "service", "connection-scheme-service",
                    "timestamp", System.currentTimeMillis(),
                    "auth-service", authHealth.isSuccess() ? authHealth.getHealthStatus() : "UNAVAILABLE");
        } catch (Exception e) {
            log.error("Kafka Client: ", e);
            return Map.of(
                    "status", "DEGRADED",
                    "service", "connection-scheme-service",
                    "timestamp", System.currentTimeMillis(),
                    "auth-service", "UNAVAILABLE",
                    "error", e.getMessage());
        }
    }

    @Override
    public List<ConnectionSchemeBLM> getSchemesByBuffer(UUID bufferUuid) {
        List<ConnectionSchemeDALM> schemesDALM = schemeRepository.findByBufferUid(bufferUuid);
        return schemesDALM.stream()
                .map(schemeConverter::toBLM)
                .collect(Collectors.toList());
    }

    @Override
    public List<ConnectionSchemeBLM> getSchemesByBuffer(List<UUID> bufferUuids) {
        Set<ConnectionSchemeBLM> connectionSchemeBLMs = new HashSet<>();
        for (UUID uuid : bufferUuids) {
            connectionSchemeBLMs.addAll(getSchemesByBuffer(uuid));
        }
        return new ArrayList<ConnectionSchemeBLM>(connectionSchemeBLMs);

    }
}package com.service.connectionscheme.kafka;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Component;

import com.connection.auth.events.responses.TokenValidationResponse;
import com.connection.common.events.CommandResponse;
import com.connection.auth.events.responses.ClientUidResponse;
import com.connection.auth.events.responses.HealthCheckResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class AuthResponseConsumer {

    private final TypedAuthKafkaClient authKafkaClient;

    @KafkaListener(topics = "${app.kafka.topics.auth-responses:auth.responses}")
    public void handleAuthResponse(ConsumerRecord<String, CommandResponse> record) {
        try {
            CommandResponse message = record.value();
            String correlationId = record.key();
            
            log.info("Received auth response: correlationId={}", correlationId);
                
            if (message instanceof TokenValidationResponse) {
                TokenValidationResponse typedResponse = (TokenValidationResponse) message;
                authKafkaClient.handleResponse(correlationId, typedResponse);
            } else if (message instanceof ClientUidResponse) {
                ClientUidResponse typedResponse = (ClientUidResponse) message;
                authKafkaClient.handleResponse(correlationId, typedResponse);
            } else if (message instanceof HealthCheckResponse) {
                HealthCheckResponse typedResponse = (HealthCheckResponse) message;
                authKafkaClient.handleResponse(correlationId, typedResponse);
            } else {
                log.warn("Unknown response type for correlationId: {}", correlationId);
            }
            
        } catch (Exception e) {
            log.error("Error processing auth response: correlationId={}", record.key(), e);
        }
    }
}package com.service.connectionscheme.kafka;

import java.util.Date;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

import com.connection.auth.events.AuthEventConstants;
import com.connection.auth.events.AuthEventUtils;
import com.connection.auth.events.commands.ExtractClientUidCommand;
import com.connection.auth.events.commands.HealthCheckCommand;
import com.connection.auth.events.commands.ValidateTokenCommand;
import com.connection.auth.events.responses.ClientUidResponse;
import com.connection.auth.events.responses.HealthCheckResponse;
import com.connection.auth.events.responses.TokenValidationResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class TypedAuthKafkaClient {

    private final KafkaTemplate<String, Object> kafkaTemplate;
    
    private final Map<String, PendingRequest<?>> pendingRequests = new ConcurrentHashMap<>();

    private static class PendingRequest<T> {
        final CompletableFuture<T> future;
        final Class<T> responseType;

        PendingRequest(CompletableFuture<T> future, Class<T> responseType) {
            this.future = future;
            this.responseType = responseType;
        }
    }

    public CompletableFuture<TokenValidationResponse> validateToken(String token, String sourceService) {
        return sendRequest(
            ValidateTokenCommand.builder()
                .token(token)
                .tokenType(ValidateTokenCommand.TokenType.ACCESS)
                .sourceService(sourceService)
                .replyTopic(AuthEventConstants.AUTH_RESPONSES_TOPIC)
                .correlationId(AuthEventUtils.generateCorrelationId())
                .build(),
            TokenValidationResponse.class
        );
    }

    public CompletableFuture<ClientUidResponse> getClientUid(String token, String sourceService) {
        return sendRequest(
            ExtractClientUidCommand.builder()
                .token(token)
                .tokenType(ExtractClientUidCommand.TokenType.ACCESS)
                .sourceService(sourceService)
                .replyTopic(AuthEventConstants.AUTH_RESPONSES_TOPIC)
                .correlationId(AuthEventUtils.generateCorrelationId())
                .build(),
            ClientUidResponse.class
        );
    }

    public CompletableFuture<HealthCheckResponse> healthCheck(String sourceService) {
        return sendRequest(
            HealthCheckCommand.builder()
                .eventId(UUID.randomUUID().toString())
                .sourceService(sourceService)
                .timestamp(new Date().toInstant())
                .replyTopic(AuthEventConstants.AUTH_RESPONSES_TOPIC)
                .correlationId(AuthEventUtils.generateCorrelationId())
                .commandType(AuthEventConstants.COMMAND_HEALTH_CHECK)
                .build(),
            HealthCheckResponse.class
        );
    }

    private <T> CompletableFuture<T> sendRequest(Object command, Class<T> responseType) {
        String correlationId;
        
        if (command instanceof ValidateTokenCommand) {
            correlationId = ((ValidateTokenCommand) command).getCorrelationId();
        } else if (command instanceof ExtractClientUidCommand) {
            correlationId = ((ExtractClientUidCommand) command).getCorrelationId();
        } else if (command instanceof HealthCheckCommand) {
            correlationId = ((HealthCheckCommand) command).getCorrelationId();
        } else {
            throw new IllegalArgumentException("Unsupported command type: " + command.getClass());
        }

        CompletableFuture<T> future = new CompletableFuture<>();
        pendingRequests.put(correlationId, new PendingRequest<>(future, responseType));

        kafkaTemplate.send(AuthEventConstants.AUTH_COMMANDS_TOPIC, correlationId, command)
                .whenComplete((result, ex) -> {
                    if (ex != null) {
                        future.completeExceptionally(ex);
                        pendingRequests.remove(correlationId);
                        log.error("Failed to send command: {}", ex.getMessage());
                    }
                });

        return future;
    }

    @SuppressWarnings("unchecked")
    public void handleResponse(String correlationId, Object response) {
        PendingRequest<?> pendingRequest = pendingRequests.remove(correlationId);
        if (pendingRequest != null) {
            try {
                if (pendingRequest.responseType.isInstance(response)) {
                    CompletableFuture<Object> future = (CompletableFuture<Object>) pendingRequest.future;
                    future.complete(response);
                } else {
                    log.warn("Type mismatch for correlationId: {}. Expected: {}, Got: {}", 
                            correlationId, pendingRequest.responseType, response.getClass());
                    pendingRequest.future.completeExceptionally(
                        new ClassCastException("Type mismatch in response")
                    );
                }
            } catch (Exception e) {
                pendingRequest.future.completeExceptionally(e);
            }
        } else {
            log.warn("Received response for unknown correlationId: {}", correlationId);
        }
    }
}package com.service.connectionscheme.kafka;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

import com.connection.scheme.events.commands.GetConnectionSchemeByUidCommand;
import com.connection.scheme.events.commands.GetConnectionSchemesByBufferUid;
import com.connection.scheme.events.commands.GetConnectionSchemesByClientUid;
import com.connection.scheme.events.commands.HealthCheckCommand;
import com.connection.scheme.events.responses.GetConnectionSchemeByUidResponse;
import com.connection.scheme.events.responses.GetConnectionSchemesByBufferResponse;
import com.connection.scheme.events.responses.GetConnectionSchemesByClientResponse;
import com.connection.scheme.events.responses.HealthCheckResponse;
import com.connection.common.events.Command;
import com.service.connectionscheme.ConnectionSchemeService;
import com.connection.scheme.converter.ConnectionSchemeConverter;
import com.connection.scheme.model.ConnectionSchemeBLM;
import com.connection.scheme.model.ConnectionSchemeDTO;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@Component
@RequiredArgsConstructor
public class ConnectionSchemeCommandConsumer {

    @Qualifier("KafkaConnectionSchemeService")
    private final ConnectionSchemeService connectionSchemeService;
    private final ConnectionSchemeConverter connectionSchemeConverter;
    private final KafkaTemplate<String, Object> kafkaTemplate;

    @KafkaListener(topics = "${app.kafka.topics.connection-scheme-commands:connection-scheme.commands}")
    public void handleConnectionSchemeCommand(ConsumerRecord<String, Command> record) {
        try {
            Command command = record.value();
            String key = record.key();

            log.info("Received connection scheme command: {} with key: {}", command.getClass().getSimpleName(), key);

            if (command instanceof GetConnectionSchemeByUidCommand) {
                GetConnectionSchemeByUidCommand getSchemeCommand = (GetConnectionSchemeByUidCommand) command;
                handleGetConnectionSchemeByUidCommand(getSchemeCommand, key);
            } else if (command instanceof GetConnectionSchemesByClientUid) {
                GetConnectionSchemesByClientUid getSchemesCommand = (GetConnectionSchemesByClientUid) command;
                handleGetConnectionSchemesByClientCommand(getSchemesCommand, key);
            } else if (command instanceof GetConnectionSchemesByBufferUid) {
                GetConnectionSchemesByBufferUid getSchemesCommand = (GetConnectionSchemesByBufferUid) command;
                handleGetConnectionSchemesByBufferUidCommand(getSchemesCommand, key);
            } else if (command instanceof HealthCheckCommand) {
                HealthCheckCommand healthCommand = (HealthCheckCommand) command;
                handleHealthCheckCommand(healthCommand, key);
            } else {
                log.warn("Unknown connection scheme command type: {}", command.getClass().getCanonicalName());
            }

        } catch (Exception e) {
            log.error("Error processing connection scheme command: key={}", record.key(), e);
        }
    }

    private void handleGetConnectionSchemeByUidCommand(GetConnectionSchemeByUidCommand command, String key) {
        try {
            log.info("Processing GetConnectionSchemeByUidCommand for scheme UID: {}", command.getConnectionSchemeUid());

            ConnectionSchemeBLM schemeBLM = connectionSchemeService.getSchemeByUid(command.getConnectionSchemeUid());
            ConnectionSchemeDTO schemeDTO = connectionSchemeConverter.toDTO(schemeBLM);

            GetConnectionSchemeByUidResponse response = GetConnectionSchemeByUidResponse.success(
                    command.getCorrelationId(),
                    schemeDTO);

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
            log.info("Successfully processed GetConnectionSchemeByUidCommand for scheme: {}", command.getConnectionSchemeUid());

        } catch (Exception e) {
            log.error("Error processing GetConnectionSchemeByUidCommand for scheme UID: {}", command.getConnectionSchemeUid(), e);

            GetConnectionSchemeByUidResponse response = GetConnectionSchemeByUidResponse.error(
                    command.getCorrelationId(),
                    e.getMessage());

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
        }
    }

    private void handleGetConnectionSchemesByClientCommand(GetConnectionSchemesByClientUid command, String key) {
        try {
            log.info("Processing GetConnectionSchemesByClientCommand for client UID: {}", command.getClientUid());

            List<ConnectionSchemeBLM> schemesBLM = connectionSchemeService.getSchemesByClient(command.getClientUid());
            List<ConnectionSchemeDTO> schemeDTOs = schemesBLM.stream()
                    .map(connectionSchemeConverter::toDTO)
                    .collect(Collectors.toList());

            GetConnectionSchemesByClientResponse response = GetConnectionSchemesByClientResponse.valid(
                    command.getCorrelationId(),
                    schemeDTOs);

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);

            log.info("Successfully processed GetConnectionSchemesByClientCommand for client: {}, found {} schemes",
                    command.getClientUid(), schemeDTOs.size());

        } catch (Exception e) {
            log.error("Error processing GetConnectionSchemesByClientCommand for client UID: {}", command.getClientUid(), e);

            GetConnectionSchemesByClientResponse response = GetConnectionSchemesByClientResponse.error(
                    command.getCorrelationId(),
                    e.getMessage());

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
        }
    }

    private void handleGetConnectionSchemesByBufferUidCommand(GetConnectionSchemesByBufferUid command, String key) {
        try {
            log.info("Processing GetConnectionSchemesByBufferCommand for Buffer UID: {}", command.getBufferUid());

            List<ConnectionSchemeBLM> schemesBLM = connectionSchemeService.getSchemesByBuffer(command.getBufferUid());
            List<ConnectionSchemeDTO> schemeDTOs = schemesBLM.stream()
                    .map(connectionSchemeConverter::toDTO)
                    .collect(Collectors.toList());

            GetConnectionSchemesByBufferResponse response = GetConnectionSchemesByBufferResponse.valid(
                    command.getCorrelationId(),
                    schemeDTOs);

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);

            log.info("Successfully processed GetConnectionSchemesByBufferCommand for Buffer: {}, found {} schemes",
                    command.getBufferUid(), schemeDTOs.size());

        } catch (Exception e) {
            log.error("Error processing GetConnectionSchemesByBufferCommand for Buffer UID: {}", command.getBufferUid(), e);

            GetConnectionSchemesByBufferResponse response = GetConnectionSchemesByBufferResponse.error(
                    command.getCorrelationId(),
                    e.getMessage());

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
        }
    }

    private void handleHealthCheckCommand(HealthCheckCommand command, String key) {
        try {
            log.info("Processing HealthCheckCommand");

            var healthStatus = connectionSchemeService.getHealthStatus();

            HealthCheckResponse response = HealthCheckResponse.success(
                    command.getCorrelationId(),
                    healthStatus);

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);

            log.info("Successfully processed HealthCheckCommand");

        } catch (Exception e) {
            log.error("Error processing HealthCheckCommand", e);

            HealthCheckResponse response = HealthCheckResponse.error(
                    command.getCorrelationId(),
                    e.getMessage());

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
        }
    }
}package com.service.connectionscheme.client;

import com.service.connectionscheme.kafka.TypedAuthKafkaClient;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import com.connection.auth.events.responses.TokenValidationResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Collections;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

@Slf4j
@Component
@RequiredArgsConstructor
public class JwtKafkaAuthenticationFilter extends OncePerRequestFilter {

    private final TypedAuthKafkaClient authKafkaClient;
    private static final String AUTH_HEADER = "Authorization";
    private static final String BEARER_PREFIX = "Bearer ";

    @Override
    protected void doFilterInternal(HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain) throws ServletException, IOException {

        String authHeader = request.getHeader(AUTH_HEADER);

        if (authHeader == null || !authHeader.startsWith(BEARER_PREFIX)) {
            filterChain.doFilter(request, response);
            return;
        }

        String jwtToken = authHeader.substring(BEARER_PREFIX.length());

        try {
            authenticateWithToken(jwtToken, request);
        } catch (Exception e) {
            log.error("Authentication failed for token: {}", e.getMessage());
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            return;
        }

        filterChain.doFilter(request, response);
    }

    private void authenticateWithToken(String token, HttpServletRequest request) {
        try {
            String cleanToken = token.trim();
            cleanToken = cleanToken.replace("Bearer ", "");

            log.info("Validating token: {}...", cleanToken);

            CompletableFuture<TokenValidationResponse> validationFuture = authKafkaClient.validateToken(cleanToken,
                    "connection-scheme-service");

            TokenValidationResponse validationResponse = validationFuture
                    .get(10, TimeUnit.SECONDS);

            if (!validationResponse.isValid()) {
                throw new SecurityException("Token validation failed: " + validationResponse.getError());
            }

            UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                    validationResponse.getClientUid(),
                    null,
                    Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER")));

            authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
            SecurityContextHolder.getContext().setAuthentication(authentication);

            log.info("Successfully authenticated client: {}", validationResponse.getClientUid());

        } catch (java.util.concurrent.TimeoutException e) {
            throw new SecurityException("Token validation timeout");
        } catch (java.util.concurrent.ExecutionException e) {
            throw new SecurityException("Token validation error: " + e.getCause().getMessage());
        } catch (Exception e) {
            throw new SecurityException("Authentication failed: " + e.getMessage());
        }
    }
}// ConnectionSchemeService.java
package com.service.connectionscheme;

import java.util.List;
import java.util.Map;
import java.util.UUID;

import com.connection.scheme.model.ConnectionSchemeBLM;
import com.connection.scheme.model.ConnectionSchemeDTO;

public interface ConnectionSchemeService {
    ConnectionSchemeBLM createScheme(ConnectionSchemeDTO schemeDTO);
    
    ConnectionSchemeBLM getSchemeByUid(UUID schemeUid);
    List<ConnectionSchemeBLM> getSchemeByUid(List<UUID> schemeUid);

    List<ConnectionSchemeBLM> getSchemesByClient(UUID clientUuid);

    List<ConnectionSchemeBLM> getSchemesByBuffer(UUID bufferUuid);
    List<ConnectionSchemeBLM> getSchemesByBuffer(List<UUID> bufferUuid);

    ConnectionSchemeBLM updateScheme(UUID schemeUid, ConnectionSchemeDTO schemeDTO);

    void deleteScheme(UUID schemeUid);
    boolean schemeExists(UUID schemeUid);
    Map<String, Object> getHealthStatus();
}package com.service.connectionscheme;

import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.connection.scheme.converter.ConnectionSchemeConverter;
import com.connection.scheme.exception.ConnectionSchemeAlreadyExistsException;
import com.connection.scheme.model.ConnectionSchemeBLM;
import com.connection.scheme.model.ConnectionSchemeDALM;
import com.connection.scheme.model.ConnectionSchemeDTO;
import com.connection.scheme.repository.ConnectionSchemeRepository;
import com.connection.scheme.validator.ConnectionSchemeValidator;
import com.service.connectionscheme.kafka.TypedAuthKafkaClient;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RequiredArgsConstructor
@Service("KafkaConnectionSchemeService")
@EnableAutoConfiguration(exclude = {
        JpaRepositoriesAutoConfiguration.class
})
@Transactional("atomicosTransactionManager")
public class KafkaConnectionSchemeServiceImpl implements ConnectionSchemeService {

    private final ConnectionSchemeRepository schemeRepository;
    private final ConnectionSchemeConverter schemeConverter;
    private final ConnectionSchemeValidator schemeValidator;

    private final TypedAuthKafkaClient authKafkaClient;

    @Override
    public ConnectionSchemeBLM createScheme(ConnectionSchemeDTO schemeDTO) {
        schemeValidator.validate(schemeDTO);
        ConnectionSchemeBLM schemeBLM = schemeConverter.toBLM(schemeDTO);

        if (schemeRepository.exists(schemeBLM.getUid())) {
            throw new ConnectionSchemeAlreadyExistsException(
                    "Scheme with UID '" + schemeBLM.getUid() + "' already exists");
        }

        ConnectionSchemeDALM schemeDALM = schemeConverter.toDALM(schemeBLM);
        schemeRepository.add(schemeDALM);

        log.info("Connection scheme created via Kafka: {}", schemeBLM.getUid());
        return schemeBLM;
    }

    @Override
    public ConnectionSchemeBLM getSchemeByUid(UUID schemeUid) {
        ConnectionSchemeDALM schemeDALM = schemeRepository.findByUid(schemeUid);
        return schemeConverter.toBLM(schemeDALM); // Без проверки безопасности
    }

    @Override
    public List<ConnectionSchemeBLM> getSchemeByUid(List<UUID> schemeUids) {
        return schemeUids.stream()
                .map(this::getSchemeByUid)
                .collect(Collectors.toList());
    }

    @Override
    public List<ConnectionSchemeBLM> getSchemesByClient(UUID clientUid) {
        List<ConnectionSchemeDALM> schemesDALM = schemeRepository.findByClientUid(clientUid);
        return schemesDALM.stream()
                .map(schemeConverter::toBLM)
                .collect(Collectors.toList());
    }

    @Override
    public ConnectionSchemeBLM updateScheme(UUID schemeUid, ConnectionSchemeDTO schemeDTO) {
        schemeRepository.findByUid(schemeUid);
        
        schemeValidator.validate(schemeDTO);
        ConnectionSchemeBLM schemeBLM = schemeConverter.toBLM(schemeDTO);

        // Проверяем, что UID не изменяется
        if (!schemeUid.equals(schemeBLM.getUid())) {
            throw new IllegalArgumentException("Cannot change scheme UID");
        }

        ConnectionSchemeDALM schemeDALM = schemeConverter.toDALM(schemeBLM);
        schemeRepository.update(schemeDALM);

        log.info("Connection scheme updated via Kafka: {}", schemeUid);
        return schemeBLM;
    }

    @Override
    public void deleteScheme(UUID schemeUid) {
        schemeRepository.delete(schemeUid);
        log.info("Connection scheme deleted via Kafka: {}", schemeUid);
    }

    @Override
    public boolean schemeExists(UUID schemeUid) {
        return schemeRepository.exists(schemeUid);
    }

     @Override
    public Map<String, Object> getHealthStatus() {
        try {
            var authHealth = authKafkaClient.healthCheck("connection-scheme-service")
                    .get(5, java.util.concurrent.TimeUnit.SECONDS);

            return Map.of(
                    "status", "OK",
                    "service", "connection-scheme-service",
                    "timestamp", System.currentTimeMillis(),
                    "auth-service", authHealth.isSuccess() ? authHealth.getHealthStatus() : "UNAVAILABLE");
        } catch (Exception e) {
            log.error("Kafka Client: ", e);
            return Map.of(
                    "status", "DEGRADED",
                    "service", "connection-scheme-service",
                    "timestamp", System.currentTimeMillis(),
                    "auth-service", "UNAVAILABLE",
                    "error", e.getMessage());
        }
    }
    @Override
    public List<ConnectionSchemeBLM> getSchemesByBuffer(UUID bufferUuid) {
        List<ConnectionSchemeDALM> schemesDALM = schemeRepository.findByBufferUid(bufferUuid);
        return schemesDALM.stream()
                .map(schemeConverter::toBLM)
                .collect(Collectors.toList());
    }

    @Override
    public List<ConnectionSchemeBLM> getSchemesByBuffer(List<UUID> bufferUuids) {
        return bufferUuids.stream()
                .flatMap(uuid -> getSchemesByBuffer(uuid).stream())
                .collect(Collectors.toList());
    }
}package com.service.connectionscheme.mother;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import com.connection.scheme.model.ConnectionSchemeBLM;
import com.connection.scheme.model.ConnectionSchemeDALM;
import com.connection.scheme.model.ConnectionSchemeDTO;

public class ConnectionSchemeObjectMother {

    public static final UUID CLIENT_UUID = UUID.fromString("123e4567-e89b-12d3-a456-426614174000");
    public static final UUID SCHEME_UUID = UUID.fromString("323e4567-e89b-12d3-a456-426614174003");
    public static final UUID BUFFER_UUID_1 = UUID.fromString("423e4567-e89b-12d3-a456-426614174004");
    public static final UUID BUFFER_UUID_2 = UUID.fromString("523e4567-e89b-12d3-a456-426614174005");
    public static final UUID BUFFER_UUID_3 = UUID.fromString("623e4567-e89b-12d3-a456-426614174006");
    
    public static final String VALID_TOKEN = "valid-token-123";
    public static final String INVALID_TOKEN = "invalid-token-456";
    
    // ИСПРАВЛЕНО: scheme_json содержит только transitions (без usedBuffers)
    public static final String SCHEME_JSON = "{" +
        "\"" + BUFFER_UUID_1 + "\":[\"" + BUFFER_UUID_2 + "\"]," +
        "\"" + BUFFER_UUID_2 + "\":[\"" + BUFFER_UUID_3 + "\"]" +
    "}";

    // ИСПРАВЛЕНО: Пустой JSON для transitions
    public static final String EMPTY_TRANSITIONS_JSON = "{}";

    public static ConnectionSchemeDTO createValidSchemeDTO() {
        return ConnectionSchemeDTO.builder()
            .uid(SCHEME_UUID.toString())
            .clientUid(CLIENT_UUID.toString())
            .schemeJson(SCHEME_JSON)
            .usedBuffers(Arrays.asList(BUFFER_UUID_1, BUFFER_UUID_2, BUFFER_UUID_3)) // Все буферы из transitions
            .build();
    }

    public static ConnectionSchemeDTO createInvalidSchemeDTO() {
        return ConnectionSchemeDTO.builder()
            .uid("invalid-uuid")
            .clientUid("invalid-client-uuid")
            .schemeJson("") // empty json
            .usedBuffers(Arrays.asList(BUFFER_UUID_1, BUFFER_UUID_2)) // Добавлен usedBuffers
            .build();
    }

    public static ConnectionSchemeDTO createInvalidJsonStructureSchemeDTO() {
        return ConnectionSchemeDTO.builder()
            .uid(SCHEME_UUID.toString())
            .clientUid(CLIENT_UUID.toString())
            .schemeJson("{\"invalid\": \"structure\"}") // missing required fields
            .usedBuffers(Arrays.asList(BUFFER_UUID_1)) // Добавлен usedBuffers
            .build();
    }

    public static ConnectionSchemeBLM createValidSchemeBLM() {
        Map<UUID, List<UUID>> bufferTransitions = new HashMap<>();
        bufferTransitions.put(BUFFER_UUID_1, Arrays.asList(BUFFER_UUID_2));
        bufferTransitions.put(BUFFER_UUID_2, Arrays.asList(BUFFER_UUID_3));
        
        return ConnectionSchemeBLM.builder()
            .uid(SCHEME_UUID)
            .clientUid(CLIENT_UUID)
            .schemeJson(SCHEME_JSON)
            .usedBuffers(Arrays.asList(BUFFER_UUID_1, BUFFER_UUID_2, BUFFER_UUID_3)) // Все буферы из transitions
            .bufferTransitions(bufferTransitions)
            .build();
    }

    public static ConnectionSchemeBLM createSchemeBLMWithEmptyTransitions() {
        return ConnectionSchemeBLM.builder()
            .uid(SCHEME_UUID)
            .clientUid(CLIENT_UUID)
            .schemeJson(EMPTY_TRANSITIONS_JSON) // Пустые transitions
            .usedBuffers(Arrays.asList()) // Нет used buffers при пустых transitions
            .bufferTransitions(new HashMap<>())
            .build();
    }

    public static ConnectionSchemeDALM createValidSchemeDALM() {
        return ConnectionSchemeDALM.builder()
            .uid(SCHEME_UUID)
            .clientUid(CLIENT_UUID)
            .schemeJson(SCHEME_JSON)
            .usedBuffers(Arrays.asList(BUFFER_UUID_1, BUFFER_UUID_2, BUFFER_UUID_3)) // Все буферы из transitions
            .build();
    }

    public static ConnectionSchemeDALM createSchemeDALMWithUsedBuffers(List<UUID> usedBuffers) {
        return ConnectionSchemeDALM.builder()
            .uid(SCHEME_UUID)
            .clientUid(CLIENT_UUID)
            .schemeJson(SCHEME_JSON)
            .usedBuffers(usedBuffers)
            .build();
    }

    public static ConnectionSchemeDTO createSchemeDTOWithDifferentClient() {
        return ConnectionSchemeDTO.builder()
            .uid(SCHEME_UUID.toString())
            .clientUid(UUID.randomUUID().toString()) // different client
            .schemeJson(SCHEME_JSON)
            .usedBuffers(Arrays.asList(BUFFER_UUID_1, BUFFER_UUID_2, BUFFER_UUID_3)) // Добавлен usedBuffers
            .build();
    }

    public static ConnectionSchemeDTO createSchemeDTOWithDifferentUid() {
        return ConnectionSchemeDTO.builder()
            .uid(UUID.randomUUID().toString()) // different UID
            .clientUid(CLIENT_UUID.toString())
            .schemeJson(SCHEME_JSON)
            .usedBuffers(Arrays.asList(BUFFER_UUID_1, BUFFER_UUID_2, BUFFER_UUID_3)) // Добавлен usedBuffers
            .build();
    }

    public static ConnectionSchemeDTO createSchemeDTOWithNullFields() {
        return ConnectionSchemeDTO.builder()
            .uid(null)
            .clientUid(null)
            .schemeJson(null)
            .usedBuffers(null) // Добавлен usedBuffers
            .build();
    }

    public static ConnectionSchemeBLM createSchemeBLMWithNullFields() {
        return ConnectionSchemeBLM.builder()
            .uid(null)
            .clientUid(null)
            .schemeJson(null)
            .usedBuffers(null)
            .bufferTransitions(null)
            .build();
    }

    public static ConnectionSchemeDALM createSchemeDALMWithNullFields() {
        return ConnectionSchemeDALM.builder()
            .uid(null)
            .clientUid(null)
            .schemeJson(null)
            .usedBuffers(null)
            .build();
    }

    // ИСПРАВЛЕНО: scheme_json содержит только transitions (без usedBuffers)
    public static ConnectionSchemeDTO createSchemeDTOForBufferTest(UUID bufferUid) {
        String bufferSpecificJson = "{" +
            "\"" + bufferUid + "\": []" + // Только transitions с пустым списком
        "}";
        
        return ConnectionSchemeDTO.builder()
            .uid(UUID.randomUUID().toString())
            .clientUid(CLIENT_UUID.toString())
            .schemeJson(bufferSpecificJson)
            .usedBuffers(Arrays.asList(bufferUid)) // Только указанный буфер
            .build();
    }

    // ДОБАВЛЕНО: Метод для создания схемы с пустыми transitions
    public static ConnectionSchemeDTO createSchemeDTOWithEmptyTransitions() {
        return ConnectionSchemeDTO.builder()
            .uid(SCHEME_UUID.toString())
            .clientUid(CLIENT_UUID.toString())
            .schemeJson(EMPTY_TRANSITIONS_JSON) // Пустые transitions
            .usedBuffers(Arrays.asList()) // Нет used buffers при пустых transitions
            .build();
    }

    // ДОБАВЛЕНО: Метод для создания схемы с конкретными transitions
    public static ConnectionSchemeDALM createSchemeDALMWithTransitions(Map<UUID, List<UUID>> transitions) {
        try {
            com.fasterxml.jackson.databind.ObjectMapper objectMapper = new com.fasterxml.jackson.databind.ObjectMapper();
            String schemeJson = objectMapper.writeValueAsString(transitions);
            
            // Вычисляем usedBuffers из transitions
            List<UUID> usedBuffers = transitions.entrySet().stream()
                    .flatMap(entry -> {
                        java.util.stream.Stream<UUID> keyStream = java.util.stream.Stream.of(entry.getKey());
                        java.util.stream.Stream<UUID> valueStream = entry.getValue().stream();
                        return java.util.stream.Stream.concat(keyStream, valueStream);
                    })
                    .distinct()
                    .collect(java.util.stream.Collectors.toList());
            
            return ConnectionSchemeDALM.builder()
                    .uid(UUID.randomUUID())
                    .clientUid(CLIENT_UUID)
                    .schemeJson(schemeJson)
                    .usedBuffers(usedBuffers)
                    .build();
        } catch (Exception e) {
            throw new RuntimeException("Failed to create ConnectionSchemeDALM with transitions", e);
        }
    }

    // ДОБАВЛЕНО: Метод для создания схемы без usedBuffers
    public static ConnectionSchemeDALM createSchemeDALMWithoutUsedBuffers() {
        return ConnectionSchemeDALM.builder()
                .uid(UUID.randomUUID())
                .clientUid(CLIENT_UUID)
                .schemeJson(SCHEME_JSON)
                .usedBuffers(null)
                .build();
    }

    // ДОБАВЛЕНО: Метод для создания схемы с пустыми usedBuffers
    public static ConnectionSchemeDALM createSchemeDALMWithEmptyUsedBuffers() {
        return ConnectionSchemeDALM.builder()
                .uid(UUID.randomUUID())
                .clientUid(CLIENT_UUID)
                .schemeJson(SCHEME_JSON)
                .usedBuffers(Arrays.asList())
                .build();
    }

    // ДОБАВЛЕНО: Метод для создания BLM с конкретными transitions
    public static ConnectionSchemeBLM createSchemeBLMWithTransitions(Map<UUID, List<UUID>> transitions) {
        try {
            com.fasterxml.jackson.databind.ObjectMapper objectMapper = new com.fasterxml.jackson.databind.ObjectMapper();
            String schemeJson = objectMapper.writeValueAsString(transitions);
            
            // Вычисляем usedBuffers из transitions
            List<UUID> usedBuffers = transitions.entrySet().stream()
                    .flatMap(entry -> {
                        java.util.stream.Stream<UUID> keyStream = java.util.stream.Stream.of(entry.getKey());
                        java.util.stream.Stream<UUID> valueStream = entry.getValue().stream();
                        return java.util.stream.Stream.concat(keyStream, valueStream);
                    })
                    .distinct()
                    .collect(java.util.stream.Collectors.toList());
            
            return ConnectionSchemeBLM.builder()
                    .uid(UUID.randomUUID())
                    .clientUid(CLIENT_UUID)
                    .schemeJson(schemeJson)
                    .usedBuffers(usedBuffers)
                    .bufferTransitions(transitions)
                    .build();
        } catch (Exception e) {
            throw new RuntimeException("Failed to create ConnectionSchemeBLM with transitions", e);
        }
    }
}