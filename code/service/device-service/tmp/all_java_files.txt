package com.connection.device;

import java.util.List;
import java.util.Map;
import java.util.UUID;

import com.connection.device.model.DeviceBLM;

public interface DeviceService {
    DeviceBLM createDevice(DeviceBLM deviceBLM);
    DeviceBLM getDevice(UUID deviceUid);
    List<DeviceBLM> getDevicesByClient(UUID clientUid);
    DeviceBLM updateDevice(DeviceBLM deviceBLM);
    void deleteDevice(UUID deviceUid);
    boolean deviceExists(UUID deviceUid);
    Map<String, Object> getHealthStatus();
}package com.connection.device.config;

import io.swagger.v3.oas.annotations.enums.SecuritySchemeType;
import io.swagger.v3.oas.annotations.security.SecurityScheme;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@SecurityScheme(
    name = "bearerAuth",
    type = SecuritySchemeType.HTTP,
    bearerFormat = "JWT",
    scheme = "bearer"
)
public class SwaggerConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("Device Service API")
                        .version("1.0")
                        .description("API для управления устройствами"))
                .addSecurityItem(new SecurityRequirement().addList("bearerAuth"))
                .components(new Components()
                        .addSecuritySchemes("bearerAuth", 
                            new io.swagger.v3.oas.models.security.SecurityScheme()
                                .type(io.swagger.v3.oas.models.security.SecurityScheme.Type.HTTP)
                                .scheme("bearer")
                                .bearerFormat("JWT")));
    }
}package com.connection.device.config;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.connection.device.repository.DeviceRepository;
import com.connection.device.repository.DeviceRepositorySQLImpl;

@Configuration
public class DeviceRepositoryConfig {
    @Bean("DeviceRepository")
    DeviceRepository deviceRepository(@Qualifier("DeviceJdbcTemplate") NamedParameterJdbcTemplate template){
        return new DeviceRepositorySQLImpl(template);
    }
}package com.connection.device.config;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

import java.util.UUID;

@Component
public class SecurityUtils {

    public static UUID getCurrentClientUid() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        
        if (authentication == null || !authentication.isAuthenticated()) {
            throw new SecurityException("User not authenticated");
        }

        Object principal = authentication.getPrincipal();
        
        if (principal instanceof UUID) {
            return (UUID) principal;
        } else if (principal instanceof String) {
            try {
                return UUID.fromString((String) principal);
            } catch (IllegalArgumentException e) {
                throw new SecurityException("Invalid client UID format in principal");
            }
        } else {
            throw new SecurityException("Unexpected principal type: " + principal.getClass());
        }
    }

    public static String getCurrentClientUidAsString() {
        return getCurrentClientUid().toString();
    }
}package com.connection.device.config;

import java.util.HashMap;
import java.util.Map;

import org.apache.kafka.clients.admin.NewTopic;
import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.clients.producer.ProducerConfig;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.config.TopicBuilder;
import org.springframework.kafka.core.ConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaProducerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.core.ProducerFactory;
import org.springframework.kafka.listener.CommonErrorHandler;
import org.springframework.kafka.listener.DefaultErrorHandler;
import org.springframework.kafka.support.serializer.ErrorHandlingDeserializer;
import org.springframework.kafka.support.serializer.JsonDeserializer;
import org.springframework.kafka.support.serializer.JsonSerializer;
import org.springframework.util.backoff.FixedBackOff;

import com.connection.auth.events.AuthEventConstants;
import com.connection.device.events.DeviceEventConstants;

@Configuration
public class DeviceKafkaConfig {
    @Value("${spring.kafka.bootstrap-servers:localhost:29092}")
    private String bootstrapServers;

    @Bean
    public NewTopic authResponsesTopic() {
        return TopicBuilder.name(AuthEventConstants.AUTH_RESPONSES_TOPIC)
                .partitions(3)
                .replicas(1)
                .build();
    }

    // Конфигурация топиков для device-service
    @Bean
    public NewTopic deviceCommandsTopic() {
        return TopicBuilder.name(DeviceEventConstants.DEVICE_COMMANDS_TOPIC)
                .partitions(3)
                .replicas(1)
                .build();
    }

    @Bean
    public NewTopic deviceResponsesTopic() {
        return TopicBuilder.name(DeviceEventConstants.DEVICE_RESPONSES_TOPIC)
                .partitions(3)
                .replicas(1)
                .build();
    }

    @Bean
    public NewTopic deviceEventsTopic() {
        return TopicBuilder.name(DeviceEventConstants.DEVICE_EVENTS_TOPIC)
                .partitions(3)
                .replicas(1)
                .build();
    }

    // Конфигурация для Consumer с обработкой ошибок десериализации
    @Bean
    public ConsumerFactory<String, Object> consumerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        configProps.put(ConsumerConfig.GROUP_ID_CONFIG, "device-service-group");
        configProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");
        configProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer.class);
        configProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer.class);
        
        // Конфигурация для ErrorHandlingDeserializer
        configProps.put(ErrorHandlingDeserializer.KEY_DESERIALIZER_CLASS, org.apache.kafka.common.serialization.StringDeserializer.class);
        configProps.put(ErrorHandlingDeserializer.VALUE_DESERIALIZER_CLASS, JsonDeserializer.class);
        
        // Конфигурация для JsonDeserializer
        configProps.put(JsonDeserializer.TRUSTED_PACKAGES, "com.connection.auth.events.commands,com.connection.common.events,com.connection.device.events.commands,com.connection.auth.events.responses");
        configProps.put(JsonDeserializer.USE_TYPE_INFO_HEADERS, true);
        configProps.put(JsonDeserializer.REMOVE_TYPE_INFO_HEADERS, false);
        configProps.put(JsonDeserializer.VALUE_DEFAULT_TYPE, "com.connection.common.events.Command");
        
        return new DefaultKafkaConsumerFactory<>(configProps);
    }

    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, Object> kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory<String, Object> factory = 
            new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory());
        
        // Обработка ошибок десериализации - пропускаем некорректные сообщения
                DefaultErrorHandler errorHandler = new DefaultErrorHandler(
                (record, exception) -> { // Логируем ошибку с помощью SLF4J
                    org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger("KafkaErrorHandler");
                    logger.error("Skipping invalid message - Topic: {}, Partition: {}, Offset: {}, Key: {}, Error: {}",
                            record.topic(),
                            record.partition(),
                            record.offset(),
                            record.key(),
                            exception.getMessage());
                },
                new FixedBackOff(0L, 0L) // Без повторных попыток
        );


        factory.setCommonErrorHandler(errorHandler);
        
        return factory;
    }

    // Конфигурация для Producer
    @Bean
    public ProducerFactory<String, Object> producerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, org.apache.kafka.common.serialization.StringSerializer.class);
        configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
        configProps.put(JsonSerializer.ADD_TYPE_INFO_HEADERS, true);
        return new DefaultKafkaProducerFactory<>(configProps);
    }

    @Bean
    public KafkaTemplate<String, Object> kafkaTemplate() {
        return new KafkaTemplate<>(producerFactory());
    }
}package com.connection.device.config;

import java.util.Properties;
import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.atomikos.jdbc.AtomikosDataSourceBean;

@Configuration
public class DeviceJDBCConfig {
    
    @Value("${app.datasource.device.xa-data-source-class-name:org.postgresql.xa.PGXADataSource}")
    private String xaDataSourceClassName;

    @Value("${app.datasource.device.xa-properties.url}")
    private String jdbcUrl;

    @Value("${app.datasource.device.xa-properties.user}")
    private String username;

    @Value("${app.datasource.device.xa-properties.password}")
    private String password;

    @Value("${app.datasource.device.unique-resource-name:deviceXADataSource}")
    private String uniqueResourceName;

    @Bean("DeviceDataSource")
    DataSource deviceDataSource() {
        AtomikosDataSourceBean dataSource = new AtomikosDataSourceBean();
        dataSource.setUniqueResourceName(uniqueResourceName);
        dataSource.setXaDataSourceClassName(xaDataSourceClassName);
        
        Properties xaProperties = new Properties();
        xaProperties.setProperty("url", jdbcUrl);
        xaProperties.setProperty("user", username);
        xaProperties.setProperty("password", password);

        dataSource.setXaProperties(xaProperties);
        dataSource.setPoolSize(5);
        dataSource.setTestQuery("SELECT 1");

        return dataSource;
    }

    @Bean("DeviceJdbcTemplate")
    NamedParameterJdbcTemplate deviceNamedParameterJdbcTemplate(
            @Qualifier("DeviceDataSource") DataSource deviceDataSource) {
        return new NamedParameterJdbcTemplate(deviceDataSource);
    }
}// DeviceExceptionHandler.java
package com.connection.device.config;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import com.connection.device.exception.BaseDeviceException;
import com.connection.device.exception.DeviceAddException;
import com.connection.device.exception.DeviceAlreadyExistsException;
import com.connection.device.exception.DeviceNotFoundException;
import com.connection.device.exception.DeviceValidateException;

import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
public class DeviceExceptionHandler {

    @ExceptionHandler(DeviceAddException.class)
    public ResponseEntity<Map<String, Object>> handleDeviceAddException(DeviceAddException ex) {
        return createErrorResponse(
            "DEVICE_ADD_ERROR",
            "Cannot add device",
            ex.getMessage(),
            HttpStatus.BAD_REQUEST
        );
    }

    @ExceptionHandler(DeviceAlreadyExistsException.class)
    public ResponseEntity<Map<String, Object>> handleDeviceAlreadyExistsException(DeviceAlreadyExistsException ex) {
        return createErrorResponse(
            "DEVICE_ALREADY_EXISTS",
            "Device already exists",
            ex.getMessage(),
            HttpStatus.CONFLICT
        );
    }

    @ExceptionHandler(DeviceNotFoundException.class)
    public ResponseEntity<Map<String, Object>> handleDeviceNotFoundException(DeviceNotFoundException ex) {
        return createErrorResponse(
            "DEVICE_NOT_FOUND",
            "Device not found",
            ex.getMessage(),
            HttpStatus.NOT_FOUND
        );
    }

    @ExceptionHandler(DeviceValidateException.class)
    public ResponseEntity<Map<String, Object>> handleDeviceValidateException(DeviceValidateException ex) {
        return createErrorResponse(
            "DEVICE_VALIDATION_ERROR",
            "Device validation failed",
            ex.getMessage(),
            HttpStatus.BAD_REQUEST
        );
    }

    @ExceptionHandler(BaseDeviceException.class)
    public ResponseEntity<Map<String, Object>> handleBaseDeviceException(BaseDeviceException ex) {
        return createErrorResponse(
            "DEVICE_ERROR",
            "Device operation failed",
            ex.getMessage(),
            HttpStatus.INTERNAL_SERVER_ERROR
        );
    }

    private ResponseEntity<Map<String, Object>> createErrorResponse(
            String errorCode, 
            String errorMessage, 
            String details, 
            HttpStatus status) {
        
        Map<String, Object> errorResponse = new HashMap<>();
        errorResponse.put("timestamp", System.currentTimeMillis());
        errorResponse.put("status", status.value());
        errorResponse.put("error", status.getReasonPhrase());
        errorResponse.put("code", errorCode);
        errorResponse.put("message", errorMessage);
        errorResponse.put("details", details);
        
        return new ResponseEntity<>(errorResponse, status);
    }
}package com.connection.device.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.connection.device.converter.DeviceConverter;
import com.connection.device.validator.DeviceValidator;

@Configuration
public class DeviceUtilsConfig {
    @Bean("DeviceConverter")
    DeviceConverter deviceConverter(){
        return new DeviceConverter();
    }

    @Bean("DeviceValidator")
    DeviceValidator deviceValidator(){
        return new DeviceValidator();
    }
}package com.connection.device.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.jta.JtaTransactionManager;

import com.atomikos.icatch.jta.UserTransactionManager;

import jakarta.transaction.SystemException;

@Configuration
@ConditionalOnProperty(name = "app.transaction.mode", havingValue = "atomikos")
public class TransactionConfig {

    @Bean
    public UserTransactionManager userTransactionManager() throws SystemException{
        UserTransactionManager manager = new UserTransactionManager();
        manager.setTransactionTimeout(300);
        manager.setForceShutdown(true);
        return manager;
    }

    @Bean(name = "atomicosTransactionManager")
    public JtaTransactionManager jtaTransactionManager() throws SystemException {
        JtaTransactionManager jtaTransactionManager = new JtaTransactionManager();
        jtaTransactionManager.setTransactionManager(userTransactionManager());
        jtaTransactionManager.setUserTransaction(userTransactionManager());
        return jtaTransactionManager;
    }
}package com.connection.device.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import com.connection.device.client.JwtKafkaAuthenticationFilter;
import com.connection.device.kafka.TypedAuthKafkaClient;

import lombok.RequiredArgsConstructor;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
@RequiredArgsConstructor
public class SecurityConfig {

    private final TypedAuthKafkaClient authKafkaClient;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                .csrf(csrf -> csrf.disable())
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/swagger-ui.html").permitAll()
                        .requestMatchers("/swagger-ui/**").permitAll()
                        .requestMatchers("/api-docs/**").permitAll()
                        .requestMatchers("/webjars/**").permitAll()
                        .requestMatchers("/v3/api-docs/**").permitAll()
                        .requestMatchers("/api/v1/health").permitAll()
                        .requestMatchers("/api/v1/**").authenticated()
                        .anyRequest().denyAll()
                )
                .addFilterBefore(jwtAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class)
                .build();
    }

    @Bean
    public JwtKafkaAuthenticationFilter jwtAuthenticationFilter() {
        return new JwtKafkaAuthenticationFilter(authKafkaClient);
    }
}   // GlobalExceptionHandler.java
package com.connection.device.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import com.connection.device.exception.DeviceNotFoundException;
import com.connection.device.exception.DeviceValidateException;

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(SecurityException.class)
    public ResponseEntity<?> handleSecurityException(SecurityException e) {
        log.warn("Security exception: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(new ErrorResponse(
                "invalid_authorization",
                "Invalid or missing authorization header"));
    }

    @ExceptionHandler(DeviceNotFoundException.class)
    public ResponseEntity<?> handleDeviceNotFoundException(
            DeviceNotFoundException e) {
        log.warn("Device not found: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ErrorResponse(
                "device_not_found",
                "Device not found"));
    }

    @ExceptionHandler(DeviceValidateException.class)
    public ResponseEntity<?> handleDeviceValidationException(
            DeviceValidateException e) {
        log.warn("Device validation failed: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(new ErrorResponse(
                "validation_failed",
                e.getMessage() != null ? e.getMessage() : "Invalid device data"));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<?> handleGenericException(Exception e) {
        log.error("Unexpected error occurred: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(new ErrorResponse(
                "internal_server_error",
                "An unexpected error occurred"));
    }
}// ErrorResponse.java
package com.connection.device.controller;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class ErrorResponse {
    private final String error;
    private final String message;
}// DeviceResponse.java
package com.connection.device.controller;

import java.util.UUID;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class DeviceResponse {
    private final UUID deviceUid;
}// HealthResponse.java
package com.connection.device.controller;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class HealthResponse {
    private final String message;
}// DeviceController.java
package com.connection.device.controller;

import java.util.ArrayList;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.connection.device.DeviceService;
import com.connection.device.config.SecurityUtils;
import com.connection.device.converter.DeviceConverter;
import com.connection.device.model.DeviceBLM;
import com.connection.device.model.DeviceDTO;
import com.connection.device.validator.DeviceValidator;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@RestController
@RequestMapping("/api/v1")
public class DeviceController {
    
    @Qualifier("DeviceServiceApiImpl")
    private final DeviceService deviceService;
    
    private final DeviceValidator deviceValidator;
    private final DeviceConverter deviceConverter;

    // Константы для пагинации по умолчанию
    private static final int DEFAULT_OFFSET = 0;
    private static final int DEFAULT_LIMIT = 50;
    private static final int MAX_LIMIT = 1000;

    public DeviceController(
            @Qualifier("DeviceServiceApiImpl") DeviceService deviceService,
            DeviceValidator deviceValidator,
            DeviceConverter deviceConverter) {
        this.deviceService = deviceService;
        this.deviceValidator = deviceValidator;
        this.deviceConverter = deviceConverter;
    }

    @PostMapping("/devices")
    public ResponseEntity<DeviceResponse> createDevice(@RequestBody DeviceDTO deviceDTO) {
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        log.info("Creating device for client {}", clientUid);

        deviceValidator.validate(deviceDTO);
        DeviceBLM deviceBLM = deviceConverter.toBLM(deviceDTO);
        DeviceBLM device = deviceService.createDevice(deviceBLM);

        return ResponseEntity.ok(new DeviceResponse(device.getUid()));
    }

    @GetMapping("/devices")
    public ResponseEntity<DevicesListResponse> getDevicesByClient(
            @RequestParam(required = false) List<UUID> deviceUids,
            @RequestParam(defaultValue = "" + DEFAULT_OFFSET) int offset,
            @RequestParam(defaultValue = "" + DEFAULT_LIMIT) int limit) {
        
        log.info("Getting devices for client with offset: {}, limit: {}", offset, limit);
        
        List<DeviceBLM> allDevices = new ArrayList<>();
        if (deviceUids != null && !deviceUids.isEmpty()){
            for (UUID devUuid : deviceUids){
                allDevices.add(deviceService.getDevice(devUuid));
            }
        }
        else{
            UUID clientUid = SecurityUtils.getCurrentClientUid();
            allDevices.addAll(deviceService.getDevicesByClient(clientUid));
        }
        
        List<DeviceBLM> paginatedDevices = applyPagination(allDevices, offset, limit);
        List<DeviceDTO> deviceDTOs = paginatedDevices.stream()
                .map(deviceConverter::toDTO)
                .collect(Collectors.toList());

        DevicesListResponse.PaginationInfo paginationInfo = 
            new DevicesListResponse.PaginationInfo(
                offset, 
                limit, 
                allDevices.size(), 
                (offset + limit) < allDevices.size()
            );

        return ResponseEntity.ok(new DevicesListResponse(deviceDTOs, paginationInfo));
    }

    @PutMapping("/devices/{deviceUid}")
    public ResponseEntity<DeviceResponse> updateDevice(
            @PathVariable UUID deviceUid,
            @RequestBody DeviceDTO deviceDTO) {
        
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        log.info("Updating device: {} for client: {}", deviceUid, clientUid);

        deviceValidator.validate(deviceDTO);
        DeviceBLM deviceBLM = deviceConverter.toBLM(deviceDTO);
        DeviceBLM device = deviceService.updateDevice(deviceBLM);

        return ResponseEntity.ok(new DeviceResponse(device.getUid()));
    }

    @DeleteMapping("/devices/{deviceUid}")
    public ResponseEntity<Void> deleteDevice(@PathVariable UUID deviceUid) {
        log.info("Deleting device: {}", deviceUid);

        deviceService.deleteDevice(deviceUid);

        return ResponseEntity.noContent().build();
    }

    @GetMapping("/health")
    public ResponseEntity<HealthResponse> healthCheck() {
        log.info("Health check: status: OK, service: device-service, timestamp: {}", 
                System.currentTimeMillis());

        return ResponseEntity.ok().body(new HealthResponse(deviceService.getHealthStatus().toString()));
    }

    /**
     * Применяет пагинацию к списку устройств
     * 
     * @param devices полный список устройств
     * @param offset смещение (начальная позиция)
     * @param limit максимальное количество элементов
     * @return пагинированный список устройств
     */
    private List<DeviceBLM> applyPagination(List<DeviceBLM> devices, int offset, int limit) {
        // Валидация параметров пагинации
        if (offset < 0) {
            offset = DEFAULT_OFFSET;
        }
        
        if (limit <= 0 || limit > MAX_LIMIT) {
            limit = DEFAULT_LIMIT;
        }
        
        // Применяем пагинацию
        return devices.stream()
                .skip(offset)
                .limit(limit)
                .collect(Collectors.toList());
    }
}// DevicesListResponse.java
package com.connection.device.controller;

import com.connection.device.model.DeviceDTO;

import lombok.AllArgsConstructor;
import lombok.Getter;

import java.util.List;

@AllArgsConstructor
@Getter
public class DevicesListResponse {
    private final List<DeviceDTO> devices;
    private final PaginationInfo pagination;

    @AllArgsConstructor
    @Getter
    public static class PaginationInfo {
        private final int offset;
        private final int limit;
        private final int totalCount;
        private final boolean hasMore;
    }
}package com.connection.device.kafka;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

import com.connection.device.events.commands.GetDeviceByUidCommand;
import com.connection.device.events.commands.GetDevicesByClientUid;
import com.connection.device.events.commands.HealthCheckCommand;
import com.connection.device.events.responses.GetDeviceByUidResponse;
import com.connection.device.events.responses.GetDevicesByClientResponse;
import com.connection.device.events.responses.HealthCheckResponse;
import com.connection.common.events.Command;
import com.connection.device.DeviceService;
import com.connection.device.converter.DeviceConverter;
import com.connection.device.model.DeviceBLM;
import com.connection.device.model.DeviceDTO;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@Component
@RequiredArgsConstructor
public class DeviceCommandConsumer {
    
    @Qualifier("DeviceServiceKafkaImpl")
    private final DeviceService deviceService;

    private final DeviceConverter deviceConverter;
    private final KafkaTemplate<String, Object> kafkaTemplate;
    
    @KafkaListener(topics = "${app.kafka.topics.device-commands:device.commands}")
    public void handleDeviceCommand(ConsumerRecord<String, Command> record) {
        try {
            Command command = record.value();
            String key = record.key();

            log.info("Received device command: {} with key: {}", command.getClass().getSimpleName(), key);

            if (command instanceof GetDeviceByUidCommand) {
                GetDeviceByUidCommand getDeviceCommand = (GetDeviceByUidCommand) command;
                handleGetDeviceByUidCommand(getDeviceCommand, key);
            } else if (command instanceof GetDevicesByClientUid) {
                GetDevicesByClientUid getDevicesCommand = (GetDevicesByClientUid) command;
                handleGetDevicesByClientCommand(getDevicesCommand, key);
            } else if (command instanceof HealthCheckCommand) {
                HealthCheckCommand healthCommand = (HealthCheckCommand) command;
                handleHealthCheckCommand(healthCommand, key);
            } else {
                log.warn("Unknown device command type: {}", command.getClass().getCanonicalName());
            }

        } catch (Exception e) {
            log.error("Error processing device command: key={}", record.key(), e);
        }
    }

    private void handleGetDeviceByUidCommand(GetDeviceByUidCommand command, String key) {
        try {
            log.info("Processing GetDeviceByUidCommand for device UID: {}", command.getDeviceUid());

            DeviceBLM deviceBLM = deviceService.getDevice(command.getDeviceUid());
            DeviceDTO deviceDTO = deviceConverter.toDTO(deviceBLM);

            GetDeviceByUidResponse response = GetDeviceByUidResponse.success(
                    command.getCorrelationId(),
                    deviceDTO);

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
            log.info("Successfully processed GetDeviceByUidCommand for device: {}", command.getDeviceUid());

        } catch (Exception e) {
            log.error("Error processing GetDeviceByUidCommand for device UID: {}", command.getDeviceUid(), e);

            GetDeviceByUidResponse response = GetDeviceByUidResponse.error(
                    command.getCorrelationId(),
                    e.getMessage());

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
        }
    }

    private void handleGetDevicesByClientCommand(GetDevicesByClientUid command, String key) {
        try {
            log.info("Processing GetDevicesByClientCommand for client UID: {}", command.getClientUid());

            List<DeviceBLM> devicesBLM = deviceService.getDevicesByClient(command.getClientUid());
            List<DeviceDTO> deviceDTOs = devicesBLM.stream()
                    .map(deviceConverter::toDTO)
                    .collect(Collectors.toList());

            GetDevicesByClientResponse response = GetDevicesByClientResponse.valid(
                    command.getCorrelationId(),
                    deviceDTOs);

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);

            log.info("Successfully processed GetDevicesByClientCommand for client: {}, found {} devices",
                    command.getClientUid(), deviceDTOs.size());

        } catch (Exception e) {
            log.error("Error processing GetDevicesByClientCommand for client UID: {}", command.getClientUid(), e);

            GetDevicesByClientResponse response = GetDevicesByClientResponse.error(
                    command.getCorrelationId(),
                    e.getMessage());

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
        }
    }

    private void handleHealthCheckCommand(HealthCheckCommand command, String key) {
        try {
            log.info("Processing HealthCheckCommand");

            var healthStatus = deviceService.getHealthStatus();

            HealthCheckResponse response = HealthCheckResponse.success(
                    command.getCorrelationId(),
                    healthStatus);

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);

            log.info("Successfully processed HealthCheckCommand");

        } catch (Exception e) {
            log.error("Error processing HealthCheckCommand", e);

            HealthCheckResponse response = HealthCheckResponse.error(
                    command.getCorrelationId(),
                    e.getMessage());

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
        }
    }
}package com.connection.device.kafka;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.config.KafkaListenerEndpointRegistry;
import org.springframework.kafka.listener.MessageListenerContainer;
import org.springframework.stereotype.Component;

import com.connection.auth.events.responses.TokenValidationResponse;
import com.connection.common.events.CommandResponse;
import com.connection.auth.events.responses.ClientUidResponse;
import com.connection.auth.events.responses.HealthCheckResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class AuthResponseConsumer implements ApplicationListener<ApplicationReadyEvent> {

    private final TypedAuthKafkaClient authKafkaClient;
    private final KafkaListenerEndpointRegistry registry;

    @KafkaListener(id = "dynamicAuthListener", topics = "#{@typedAuthKafkaClient.getInstanceReplyTopic()}")
    public void handleAuthResponse(ConsumerRecord<String, CommandResponse> record) {
        try {
            CommandResponse message = record.value();
            String correlationId = record.key();

            log.info("Received auth response from instance topic: correlationId={}, topic={}",
                    correlationId, record.topic());

            if (message instanceof TokenValidationResponse) {
                TokenValidationResponse typedResponse = (TokenValidationResponse) message;
                authKafkaClient.handleResponse(correlationId, typedResponse);
            } else if (message instanceof ClientUidResponse) {
                ClientUidResponse typedResponse = (ClientUidResponse) message;
                authKafkaClient.handleResponse(correlationId, typedResponse);
            } else if (message instanceof HealthCheckResponse) {
                HealthCheckResponse typedResponse = (HealthCheckResponse) message;
                authKafkaClient.handleResponse(correlationId, typedResponse);
            } else {
                log.warn("Unknown response type for correlationId: {}, type: {}",
                        correlationId, message.getClass().getSimpleName());
            }

        } catch (Exception e) {
            log.error("Error processing auth response: correlationId={}", record.key(), e);
        }
    }

    @Override
    public void onApplicationEvent(ApplicationReadyEvent event) {

        try {
            MessageListenerContainer container = registry.getListenerContainer("dynamicAuthListener");
            if (container != null && !container.isRunning()) {
                container.start();
                log.info("Dynamic auth response listener started for topic: {}",
                        authKafkaClient.getInstanceReplyTopic());
            }
        } catch (Exception e) {
            log.error("Failed to start dynamic auth listener", e);
        }
    }
}package com.connection.device.kafka;

import java.util.Date;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

import com.connection.auth.events.AuthEventConstants;
import com.connection.auth.events.AuthEventUtils;
import com.connection.auth.events.commands.ExtractClientUidCommand;
import com.connection.auth.events.commands.HealthCheckCommand;
import com.connection.auth.events.commands.ValidateTokenCommand;
import com.connection.auth.events.responses.ClientUidResponse;
import com.connection.auth.events.responses.HealthCheckResponse;
import com.connection.auth.events.responses.TokenValidationResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class TypedAuthKafkaClient {

    private final KafkaTemplate<String, Object> kafkaTemplate;

    private final Map<String, PendingRequest<?>> pendingRequests = new ConcurrentHashMap<>();

    private final String instanceReplyTopic = "auth.responses." + UUID.randomUUID().toString();

    private static class PendingRequest<T> {
        final CompletableFuture<T> future;
        final Class<T> responseType;

        PendingRequest(CompletableFuture<T> future, Class<T> responseType) {
            this.future = future;
            this.responseType = responseType;
        }
    }

    public CompletableFuture<TokenValidationResponse> validateToken(String token, String sourceService) {
        return sendRequest(
                ValidateTokenCommand.builder()
                        .token(token)
                        .tokenType(ValidateTokenCommand.TokenType.ACCESS)
                        .sourceService(sourceService)
                        .replyTopic(instanceReplyTopic)
                        .correlationId(AuthEventUtils.generateCorrelationId())
                        .build(),
                TokenValidationResponse.class);
    }

    public CompletableFuture<ClientUidResponse> getClientUid(String token, String sourceService) {
        return sendRequest(
                ExtractClientUidCommand.builder()
                        .token(token)
                        .tokenType(ExtractClientUidCommand.TokenType.ACCESS)
                        .sourceService(sourceService)
                        .replyTopic(instanceReplyTopic)
                        .correlationId(AuthEventUtils.generateCorrelationId())
                        .build(),
                ClientUidResponse.class);
    }

    public CompletableFuture<HealthCheckResponse> healthCheck(String sourceService) {
        return sendRequest(
                HealthCheckCommand.builder()
                        .eventId(UUID.randomUUID().toString())
                        .sourceService(sourceService)
                        .timestamp(new Date().toInstant())
                        .replyTopic(instanceReplyTopic)
                        .correlationId(AuthEventUtils.generateCorrelationId())
                        .commandType(AuthEventConstants.COMMAND_HEALTH_CHECK)
                        .build(),
                HealthCheckResponse.class);
    }

    private <T> CompletableFuture<T> sendRequest(Object command, Class<T> responseType) {
        String correlationId;

        if (command instanceof ValidateTokenCommand) {
            correlationId = ((ValidateTokenCommand) command).getCorrelationId();
        } else if (command instanceof ExtractClientUidCommand) {
            correlationId = ((ExtractClientUidCommand) command).getCorrelationId();
        } else if (command instanceof HealthCheckCommand) {
            correlationId = ((HealthCheckCommand) command).getCorrelationId();
        } else {
            throw new IllegalArgumentException("Unsupported command type: " + command.getClass());
        }

        CompletableFuture<T> future = new CompletableFuture<>();
        pendingRequests.put(correlationId, new PendingRequest<>(future, responseType));

        future.orTimeout(30, TimeUnit.SECONDS).whenComplete((result, ex) -> {
            if (ex != null) {
                pendingRequests.remove(correlationId);
                log.warn("Request timeout or error for correlationId: {}", correlationId);
            }
        });

        kafkaTemplate.send(AuthEventConstants.AUTH_COMMANDS_TOPIC, correlationId, command)
                .whenComplete((result, ex) -> {
                    if (ex != null) {
                        future.completeExceptionally(ex);
                        pendingRequests.remove(correlationId);
                        log.error("Failed to send command: {}", ex.getMessage());
                    } else {
                        log.info("Command sent successfully: correlationId={}, topic={}",
                                correlationId, AuthEventConstants.AUTH_COMMANDS_TOPIC);
                    }
                });

        return future;
    }

    @SuppressWarnings("unchecked")
    public void handleResponse(String correlationId, Object response) {
        PendingRequest<?> pendingRequest = pendingRequests.remove(correlationId);
        if (pendingRequest != null) {
            try {
                if (pendingRequest.responseType.isInstance(response)) {
                    CompletableFuture<Object> future = (CompletableFuture<Object>) pendingRequest.future;
                    future.complete(response);
                    log.info("Response handled successfully: correlationId={}", correlationId);
                } else {
                    log.warn("Type mismatch for correlationId: {}. Expected: {}, Got: {}",
                            correlationId, pendingRequest.responseType, response.getClass());
                    pendingRequest.future.completeExceptionally(
                            new ClassCastException("Type mismatch in response"));
                }
            } catch (Exception e) {
                pendingRequest.future.completeExceptionally(e);
                log.error("Error handling response: correlationId={}", correlationId, e);
            }
        } else {
            log.warn("Received response for unknown correlationId: {}", correlationId);
        }
    }

    public String getInstanceReplyTopic() {
        return instanceReplyTopic;
    }
}package com.connection.device;

import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.connection.auth.events.responses.HealthCheckResponse;
import com.connection.device.config.SecurityUtils;
import com.connection.device.converter.DeviceConverter;
import com.connection.device.exception.DeviceAlreadyExistsException;
import com.connection.device.kafka.TypedAuthKafkaClient;
import com.connection.device.model.DeviceBLM;
import com.connection.device.model.DeviceDALM;
import com.connection.device.repository.DeviceRepository;
import com.connection.device.validator.DeviceValidator;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RequiredArgsConstructor
@Service("DeviceServiceApiImpl")
@EnableAutoConfiguration(exclude = {
        JpaRepositoriesAutoConfiguration.class
})
//@Transaction("atomicosTransactionManager")
public class DeviceServiceApiImpl implements DeviceService {

    private final DeviceRepository deviceRepository;
    private final DeviceConverter deviceConverter;
    private final DeviceValidator deviceValidator;
    private final TypedAuthKafkaClient authKafkaClient;

    @Override
    public DeviceBLM createDevice(DeviceBLM deviceBLM) {
        deviceValidator.validate(deviceBLM);
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        if (!clientUid.equals(deviceBLM.getClientUuid())) {
            throw new SecurityException("Client UID from token doesn't match device client UID");
        }

        if (deviceRepository.existsByClientAndName(clientUid, deviceBLM.getDeviceName())) {
            throw new DeviceAlreadyExistsException(
                    "Device with name '" + deviceBLM.getDeviceName() + "' already exists for this client");
        }

        DeviceDALM deviceDALM = deviceConverter.toDALM(deviceBLM);
        deviceRepository.add(deviceDALM);

        log.info("Device created: {} for client: {}", deviceBLM.getUid(), clientUid);
        return deviceBLM;
    }

    @Override
    public DeviceBLM getDevice(UUID deviceUid) {
        DeviceDALM deviceDALM = deviceRepository.findByUid(deviceUid);
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        if (!clientUid.equals(deviceDALM.getClientUuid())) {
            throw new SecurityException("Device doesn't belong to the authenticated client");
        }

        return deviceConverter.toBLM(deviceDALM);
    }

    @Override
    public List<DeviceBLM> getDevicesByClient(UUID clientUid) {
        UUID authClientUid = SecurityUtils.getCurrentClientUid();
        if (!clientUid.equals(authClientUid)) {
            throw new SecurityException("Client uid is not authorized client uid");
        }
        
        List<DeviceDALM> devicesDALM = deviceRepository.findByClientUuid(clientUid);
        return devicesDALM.stream()
                .map(deviceConverter::toBLM)
                .collect(Collectors.toList());
    }

    @Override
    public DeviceBLM updateDevice(DeviceBLM deviceBLM) {
        deviceValidator.validate(deviceBLM);
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        DeviceDALM existingDevice = deviceRepository.findByUid(deviceBLM.getUid());

        if (!clientUid.equals(existingDevice.getClientUuid())) {
            throw new SecurityException("Device doesn't belong to the authenticated client");
        }

        if (!clientUid.equals(deviceBLM.getClientUuid())) {
            throw new SecurityException("Client UID from token doesn't match device client UID");
        }

        DeviceDALM deviceDALM = deviceConverter.toDALM(deviceBLM);
        deviceRepository.update(deviceDALM);

        log.info("Device updated: {} for client: {}", deviceBLM.getUid(), clientUid);
        return deviceBLM;
    }

    @Override
    public void deleteDevice(UUID deviceUid) {
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        
        DeviceDALM existingDevice = deviceRepository.findByUid(deviceUid);
        if (!clientUid.equals(existingDevice.getClientUuid())) {
            throw new SecurityException("Device doesn't belong to the authenticated client");
        }

        deviceRepository.delete(deviceUid);
        log.info("Device deleted: {} for client: {}", deviceUid, clientUid);
    }

    @Override
    public boolean deviceExists(UUID deviceUid) {
        // Просто проверяем существование устройства без проверки принадлежности
        return deviceRepository.exists(deviceUid);
    }

    @Override
    public Map<String, Object> getHealthStatus() {
        try {
            HealthCheckResponse authHealth = authKafkaClient.healthCheck("device-service")
                    .get(5, java.util.concurrent.TimeUnit.SECONDS);

            return Map.of(
                    "status", "OK",
                    "service", "device-service",
                    "timestamp", System.currentTimeMillis(),
                    "auth-service", authHealth.isSuccess() ? authHealth.getHealthStatus() : "UNAVAILABLE");
        } catch (Exception e) {
            log.error("Kafka Client: ", e);
            return Map.of(
                    "status", "DEGRADED",
                    "service", "device-service",
                    "timestamp", System.currentTimeMillis(),
                    "auth-service", "UNAVAILABLE",
                    "error", e.getMessage());
        }
    }
}package com.connection.device;

import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.connection.auth.events.responses.HealthCheckResponse;
import com.connection.device.converter.DeviceConverter;
import com.connection.device.kafka.TypedAuthKafkaClient;
import com.connection.device.model.DeviceBLM;
import com.connection.device.model.DeviceDALM;
import com.connection.device.repository.DeviceRepository;
import com.connection.device.validator.DeviceValidator;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RequiredArgsConstructor
@Service("DeviceServiceKafkaImpl")
@EnableAutoConfiguration(exclude = {
        JpaRepositoriesAutoConfiguration.class
})
//@Transaction("atomicosTransactionManager")
public class DeviceServiceKafkaImpl implements DeviceService {

    private final DeviceRepository deviceRepository;
    private final DeviceConverter deviceConverter;
    private final DeviceValidator deviceValidator;
    private final TypedAuthKafkaClient authKafkaClient;

    @Override
    public DeviceBLM createDevice(DeviceBLM deviceBLM) {
        deviceValidator.validate(deviceBLM);
        DeviceDALM deviceDALM = deviceConverter.toDALM(deviceBLM);
        deviceRepository.add(deviceDALM);

        log.info("Kafka: Device created: {}", deviceBLM.getUid());
        return deviceBLM;
    }

    @Override
    public DeviceBLM getDevice(UUID deviceUid) {
        DeviceDALM deviceDALM = deviceRepository.findByUid(deviceUid);
        return deviceConverter.toBLM(deviceDALM);
    }

    @Override
    public List<DeviceBLM> getDevicesByClient(UUID clientUid) {
        List<DeviceDALM> devicesDALM = deviceRepository.findByClientUuid(clientUid);
        return devicesDALM.stream()
                .map(deviceConverter::toBLM)
                .collect(Collectors.toList());
    }

    @Override
    public DeviceBLM updateDevice(DeviceBLM deviceBLM) {
        deviceValidator.validate(deviceBLM);
        DeviceDALM existingDevice = deviceRepository.findByUid(deviceBLM.getUid());

        DeviceDALM deviceDALM = deviceConverter.toDALM(deviceBLM);
        deviceRepository.update(deviceDALM);

        log.info("Kafka: Device updated: {}", deviceBLM.getUid());
        return deviceBLM;
    }

    @Override
    public void deleteDevice(UUID deviceUid) {
        deviceRepository.delete(deviceUid);
        log.info("Kafka: Device deleted: {}", deviceUid);
    }

    @Override
    public boolean deviceExists(UUID deviceUid) {
        return deviceRepository.exists(deviceUid);
    }

    @Override
    public Map<String, Object> getHealthStatus() {
        try {
            HealthCheckResponse authHealth = authKafkaClient.healthCheck("device-service")
                    .get(5, java.util.concurrent.TimeUnit.SECONDS);

            return Map.of(
                    "status", "OK",
                    "service", "device-service",
                    "timestamp", System.currentTimeMillis(),
                    "auth-service", authHealth.isSuccess() ? authHealth.getHealthStatus() : "UNAVAILABLE");
        } catch (Exception e) {
            log.error("Kafka Client: ", e);
            return Map.of(
                    "status", "DEGRADED",
                    "service", "device-service",
                    "timestamp", System.curren