package com.service.buffer.integration;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;
import org.springframework.test.context.ActiveProfiles;

import com.connection.scheme.events.commands.GetConnectionSchemeByUidCommand;
import com.connection.scheme.events.commands.GetConnectionSchemesByBufferUid;
import com.connection.scheme.events.commands.GetConnectionSchemesByClientUid;
import com.connection.scheme.events.commands.HealthCheckCommand;
import com.connection.scheme.events.responses.GetConnectionSchemeByUidResponse;
import com.connection.scheme.events.responses.GetConnectionSchemesByBufferResponse;
import com.connection.scheme.events.responses.GetConnectionSchemesByClientResponse;
import com.connection.scheme.events.responses.HealthCheckResponse;
import com.connection.scheme.model.ConnectionSchemeDTO;

import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
@Component
@RequiredArgsConstructor
@ActiveProfiles("integrationtest")
public class TestConnectionSchemeServiceResponder {

    private final KafkaTemplate<String, Object> kafkaTemplate;

    // –•—Ä–∞–Ω–∏–ª–∏—â–µ —Ç–µ—Å—Ç–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    private final Map<UUID, ConnectionSchemeDTO> testSchemes = new ConcurrentHashMap<>();
    private final Map<UUID, List<ConnectionSchemeDTO>> clientSchemes = new ConcurrentHashMap<>();
    private final Map<UUID, List<ConnectionSchemeDTO>> bufferSchemes = new ConcurrentHashMap<>();

    @Value("${app.kafka.topics.connection-scheme-commands:connection.scheme.commands}")
    private String connectionSchemeCommandsTopic;
    @PostConstruct
    public void logKafkaConfiguration() {
        log.info("""
            üß™ Test Connection Scheme Responder Kafka Configuration:
               üì® Listening Topic: {}
            """, connectionSchemeCommandsTopic);
    }


    @KafkaListener(topics = "${app.kafka.topics.connection-scheme-commands:connection.scheme.commands}", groupId = "test-connection-scheme-responder")
    public void handleConnectionSchemeCommand(ConsumerRecord<String, Object> record) {
        try {
            Object command = record.value();
            if (command instanceof GetConnectionSchemeByUidCommand) {
                handleGetConnectionSchemeByUid((GetConnectionSchemeByUidCommand) command);
            } else if (command instanceof GetConnectionSchemesByClientUid) {
                handleGetConnectionSchemesByClient((GetConnectionSchemesByClientUid) command);
            } else if (command instanceof GetConnectionSchemesByBufferUid) {
                handleGetConnectionSchemesByBuffer((GetConnectionSchemesByBufferUid) command);
            } else if (command instanceof HealthCheckCommand) {
                handleHealthCheck((HealthCheckCommand) command);
            }

        } catch (Exception e) {
            log.error("‚ùå Error in test connection scheme responder", e);
        }
    }

    private void handleGetConnectionSchemeByUid(GetConnectionSchemeByUidCommand command) {
        try {
            UUID schemeUid = command.getConnectionSchemeUid();
            ConnectionSchemeDTO scheme = testSchemes.get(schemeUid);

            GetConnectionSchemeByUidResponse response;
            if (scheme != null) {
                response = GetConnectionSchemeByUidResponse.success(
                        command.getCorrelationId(),
                        scheme);
                log.info("‚úÖ Test Responder: Connection Scheme {} found", schemeUid);
            } else {
                response = GetConnectionSchemeByUidResponse.error(
                        command.getCorrelationId(),
                        "Connection scheme not found in test data");
                log.warn("‚ö†Ô∏è Test Responder: Connection Scheme {} not found", schemeUid);
            }

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);

        } catch (Exception e) {
            log.error("‚ùå Error handling GetConnectionSchemeByUid", e);
        }
    }

    private void handleGetConnectionSchemesByClient(GetConnectionSchemesByClientUid command) {
        try {
            UUID clientUid = command.getClientUid();
            List<ConnectionSchemeDTO> schemes = clientSchemes.get(clientUid);

            GetConnectionSchemesByClientResponse response;
            if (schemes != null && !schemes.isEmpty()) {
                response = GetConnectionSchemesByClientResponse.valid(
                        command.getCorrelationId(),
                        schemes);
                log.info("‚úÖ Test Responder: Found {} connection schemes for client {}", schemes.size(), clientUid);
            } else {
                response = GetConnectionSchemesByClientResponse.valid(
                        command.getCorrelationId(),
                        List.of());
                log.info("‚ÑπÔ∏è Test Responder: No connection schemes found for client {}", clientUid);
            }

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);

        } catch (Exception e) {
            log.error("‚ùå Error handling GetConnectionSchemesByClient", e);
        }
    }

    private void handleGetConnectionSchemesByBuffer(GetConnectionSchemesByBufferUid command) {
        try {
            UUID bufferUid = command.getBufferUid();
            List<ConnectionSchemeDTO> schemes = bufferSchemes.get(bufferUid);

            GetConnectionSchemesByBufferResponse response;
            if (schemes != null && !schemes.isEmpty()) {
                response = GetConnectionSchemesByBufferResponse.valid(
                        command.getCorrelationId(),
                        schemes);
                log.info("‚úÖ Test Responder: Found {} connection schemes for buffer {}", schemes.size(), bufferUid);
            } else {
                response = GetConnectionSchemesByBufferResponse.valid(
                        command.getCorrelationId(),
                        List.of());
                log.info("‚ÑπÔ∏è Test Responder: No connection schemes found for buffer {}", bufferUid);
            }

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);

        } catch (Exception e) {
            log.error("‚ùå Error handling GetConnectionSchemesByBuffer", e);
        }
    }

    private void handleHealthCheck(HealthCheckCommand command) {
        try {
            HealthCheckResponse response = HealthCheckResponse.success(
                    command.getCorrelationId(),
                    Map.of("status", "OK", "service", "test-connection-scheme-responder"));

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
            log.info("‚úÖ Test Responder: Health check responded");

        } catch (Exception e) {
            log.error("‚ùå Error handling HealthCheck", e);
        }
    }

    // –ú–µ—Ç–æ–¥—ã –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ç–µ—Å—Ç–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏

    public void addTestConnectionScheme(UUID schemeUid, UUID clientUid, List<UUID> usedBuffers) {
        ConnectionSchemeDTO scheme = createTestConnectionSchemeDTO(schemeUid, clientUid, usedBuffers);
        addTestConnectionScheme(scheme);
    }

    public void addTestConnectionScheme(ConnectionSchemeDTO scheme) {
        UUID schemeUid = UUID.fromString(scheme.getUid());
        UUID clientUid = UUID.fromString(scheme.getClientUid());

        testSchemes.put(schemeUid, scheme);

        // –î–æ–±–∞–≤–ª—è–µ–º –≤ —Å–ø–∏—Å–æ–∫ —Å—Ö–µ–º –∫–ª–∏–µ–Ω—Ç–∞
        List<ConnectionSchemeDTO> clientSchemeList = clientSchemes.computeIfAbsent(
                clientUid, k -> new ArrayList<>());
        clientSchemeList.add(scheme);

        // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–∑–¥–∞–µ–º —Å–≤—è–∑–∏ —Å –±—É—Ñ–µ—Ä–∞–º–∏ –∏–∑ usedBuffers
        if (scheme.getUsedBuffers() != null) {
            for (UUID bufferUid : scheme.getUsedBuffers()) {
                linkSchemeToBuffer(schemeUid, bufferUid);
            }
        }

        log.info("üìù Test Responder: Added connection scheme {} for client {} with {} used buffers",
                schemeUid, clientUid,
                scheme.getUsedBuffers() != null ? scheme.getUsedBuffers().size() : 0);
    }

    public void linkSchemeToBuffer(UUID schemeUid, UUID bufferUid) {
        ConnectionSchemeDTO scheme = testSchemes.get(schemeUid);
        if (scheme != null) {
            List<ConnectionSchemeDTO> bufferSchemeList = bufferSchemes.computeIfAbsent(
                    bufferUid, k -> new ArrayList<>());
            if (!bufferSchemeList.contains(scheme)) {
                bufferSchemeList.add(scheme);
            }
            log.info("üîó Test Responder: Linked scheme {} to buffer {}", schemeUid, bufferUid);
        } else {
            log.warn("‚ö†Ô∏è Test Responder: Cannot link - scheme {} not found", schemeUid);
        }
    }

    public void removeTestConnectionScheme(UUID schemeUid) {
        ConnectionSchemeDTO scheme = testSchemes.remove(schemeUid);
        if (scheme != null) {
            UUID clientUid = UUID.fromString(scheme.getClientUid());

            // –£–¥–∞–ª—è–µ–º –∏–∑ —Å–ø–∏—Å–∫–∞ –∫–ª–∏–µ–Ω—Ç–∞
            List<ConnectionSchemeDTO> clientSchemesList = clientSchemes.get(clientUid);
            if (clientSchemesList != null) {
                clientSchemesList.removeIf(s -> s.getUid().equals(schemeUid.toString()));
            }

            // –£–¥–∞–ª—è–µ–º –∏–∑ –≤—Å–µ—Ö —Å–≤—è–∑–µ–π —Å –±—É—Ñ–µ—Ä–∞–º–∏
            bufferSchemes.values()
                    .forEach(schemeList -> schemeList.removeIf(s -> s.getUid().equals(schemeUid.toString())));
        }
    }

    public void clearTestData() {
        testSchemes.clear();
        clientSchemes.clear();
        bufferSchemes.clear();
        log.info("üßπ Test Responder: All connection scheme test data cleared");
    }

    public boolean hasConnectionScheme(UUID schemeUid) {
        return testSchemes.containsKey(schemeUid);
    }

    public boolean connectionSchemeBelongsToClient(UUID schemeUid, UUID clientUid) {
        ConnectionSchemeDTO scheme = testSchemes.get(schemeUid);
        return scheme != null && scheme.getClientUid().equals(clientUid.toString());
    }

    private ConnectionSchemeDTO createTestConnectionSchemeDTO(UUID schemeUid, UUID clientUid, List<UUID> usedBuffers) {
        return ConnectionSchemeDTO.builder()
                .uid(schemeUid.toString())
                .clientUid(clientUid.toString())
                .usedBuffers(usedBuffers != null ? usedBuffers : new ArrayList<>())
                .schemeJson("{\"test\": true, \"schemeType\": \"integration-test\", \"buffers\": " +
                        (usedBuffers != null ? usedBuffers.toString() : "[]") + "}")
                .build();
    }

    // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞

    public void addTestConnectionSchemeWithBuffers(UUID schemeUid, UUID clientUid, UUID... bufferUids) {
        List<UUID> usedBuffers = bufferUids != null ? Arrays.asList(bufferUids) : new ArrayList<>();
        addTestConnectionScheme(schemeUid, clientUid, usedBuffers);
    }

    public void addBufferToScheme(UUID schemeUid, UUID bufferUid) {
        ConnectionSchemeDTO scheme = testSchemes.get(schemeUid);
        if (scheme != null) {
            List<UUID> usedBuffers = scheme.getUsedBuffers();
            if (usedBuffers == null) {
                usedBuffers = new ArrayList<>();
                scheme.setUsedBuffers(usedBuffers);
            }
            if (!usedBuffers.contains(bufferUid)) {
                usedBuffers.add(bufferUid);
            }
            linkSchemeToBuffer(schemeUid, bufferUid);
            log.info("‚ûï Test Responder: Added buffer {} to scheme {}", bufferUid, schemeUid);
        }
    }

    public void removeBufferFromScheme(UUID schemeUid, UUID bufferUid) {
        ConnectionSchemeDTO scheme = testSchemes.get(schemeUid);
        if (scheme != null && scheme.getUsedBuffers() != null) {
            scheme.getUsedBuffers().remove(bufferUid);

            // –£–¥–∞–ª—è–µ–º —Å–≤—è–∑—å
            List<ConnectionSchemeDTO> bufferSchemesList = bufferSchemes.get(bufferUid);
            if (bufferSchemesList != null) {
                bufferSchemesList.removeIf(s -> s.getUid().equals(schemeUid.toString()));
            }
            log.info("‚ûñ Test Responder: Removed buffer {} from scheme {}", bufferUid, schemeUid);
        }
    }
}package com.service.buffer.integration;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;
import org.springframework.test.context.ActiveProfiles;

import com.connection.device.events.commands.GetDeviceByUidCommand;
import com.connection.device.events.commands.GetDevicesByClientUid;
import com.connection.device.events.commands.HealthCheckCommand;
import com.connection.device.events.responses.GetDeviceByUidResponse;
import com.connection.device.events.responses.GetDevicesByClientResponse;
import com.connection.device.events.responses.HealthCheckResponse;
import com.connection.device.model.DeviceDTO;

import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
@Component
@RequiredArgsConstructor
@ActiveProfiles("integrationtest")
public class TestDeviceServiceResponder {
    
    private final KafkaTemplate<String, Object> kafkaTemplate;
    
    
    // –•—Ä–∞–Ω–∏–ª–∏—â–µ —Ç–µ—Å—Ç–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    private final Map<UUID, DeviceDTO> testDevices = new ConcurrentHashMap<>();
    private final Map<UUID, List<DeviceDTO>> clientDevices = new ConcurrentHashMap<>();
    
    @Value("${app.kafka.topics.device-commands:device.commands}")
    private String connectionSchemeCommandsTopic;
    @PostConstruct
    public void logKafkaConfiguration() {
        log.info("""
            üß™ Test Device Responder Kafka Configuration:
               üì® Listening Topic: {}
            """, connectionSchemeCommandsTopic);
    }

    @KafkaListener(
        topics = "${app.kafka.topics.device-commands:device.commands}",
        groupId = "test-device-responder"
    )
    public void handleDeviceCommand(ConsumerRecord<String, Object> record) {
        try {
            Object command = record.value();
            if (command instanceof GetDeviceByUidCommand) {
                handleGetDeviceByUid((GetDeviceByUidCommand) command);
            } else if (command instanceof GetDevicesByClientUid) {
                handleGetDevicesByClient((GetDevicesByClientUid) command);
            } else if (command instanceof HealthCheckCommand) {
                handleHealthCheck((HealthCheckCommand) command);
            }
            
        } catch (Exception e) {
            log.error("‚ùå Error in test device responder", e);
        }
    }
    
        private void handleGetDeviceByUid(GetDeviceByUidCommand command) {
        try {
            UUID deviceUid = command.getDeviceUid();
            DeviceDTO device = testDevices.get(deviceUid);
            
            GetDeviceByUidResponse response;
            if (device != null) {
                response = GetDeviceByUidResponse.success(
                    command.getCorrelationId(),
                    device
                );
                log.info("‚úÖ Test Responder: Device {} found", deviceUid);
            } else {
                response = GetDeviceByUidResponse.error(
                    command.getCorrelationId(),
                    "Device not found in test data"
                );
                log.warn("‚ö†Ô∏è Test Responder: Device {} not found", deviceUid);
            }
            
            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
            log.info("Test Responder: send response to {}", command.getReplyTopic());
            
        } catch (Exception e) {
            log.error("‚ùå Error handling GetDeviceByUid", e);
        }
    }
    
    private void handleGetDevicesByClient(GetDevicesByClientUid command) {
        try {
            UUID clientUid = command.getClientUid();
            List<DeviceDTO> devices = clientDevices.get(clientUid);
            
            GetDevicesByClientResponse response;
            if (devices != null && !devices.isEmpty()) {
                response = GetDevicesByClientResponse.valid(
                    command.getCorrelationId(),
                    devices
                );
                log.info("‚úÖ Test Responder: Found {} devices for client {}", devices.size(), clientUid);
            } else {
                response = GetDevicesByClientResponse.valid(
                    command.getCorrelationId(),
                    List.of()
                );
                log.info("‚ÑπÔ∏è Test Responder: No devices found for client {}", clientUid);
            }
            
            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
            log.info("‚ÑπÔ∏è Test Responder: send response to {}", command.getReplyTopic());
            
        } catch (Exception e) {
            log.error("‚ùå Error handling GetDevicesByClient", e);
        }
    }
    
    private void handleHealthCheck(HealthCheckCommand command) {
        try {
            HealthCheckResponse response = HealthCheckResponse.success(
                command.getCorrelationId(),
                Map.of("status", "OK", "service", "test-device-responder")
            );
            
            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
            log.info("‚úÖ Test Responder: Health check responded");
            
        } catch (Exception e) {
            log.error("‚ùå Error handling HealthCheck", e);
        }
    }
    
    // –ú–µ—Ç–æ–¥—ã –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ç–µ—Å—Ç–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
    
    public void addTestDevice(UUID deviceUid, UUID clientUid, String deviceName) {
        DeviceDTO device = new DeviceDTO();
        device.setUid(deviceUid.toString());
        device.setClientUuid(clientUid.toString());
        device.setDeviceName(deviceName);
        device.setDeviceDescription("Test device for integration tests");
        
        testDevices.put(deviceUid, device);
        
        // –¢–∞–∫–∂–µ –¥–æ–±–∞–≤–ª—è–µ–º –≤ —Å–ø–∏—Å–æ–∫ —É—Å—Ç—Ä–æ–π—Å—Ç–≤ –∫–ª–∏–µ–Ω—Ç–∞
        List<DeviceDTO> clientDeviceList = clientDevices.computeIfAbsent(
            clientUid, k -> new java.util.ArrayList<>()
        );
        clientDeviceList.add(device);
        
        log.info("üìù Test Responder: Added test device {} for client {}", deviceUid, clientUid);
    }
    
    public void addTestDevice(DeviceDTO device) {
        UUID deviceUid = UUID.fromString(device.getUid());
        UUID clientUid = UUID.fromString(device.getClientUuid());
        
        testDevices.put(deviceUid, device);
        
        List<DeviceDTO> clientDeviceList = clientDevices.computeIfAbsent(
            clientUid, k -> new java.util.ArrayList<>()
        );
        clientDeviceList.add(device);
    }
    
    public void removeTestDevice(UUID deviceUid) {
        DeviceDTO device = testDevices.remove(deviceUid);
        if (device != null) {
            UUID clientUid = UUID.fromString(device.getClientUuid());
            List<DeviceDTO> clientDevicesList = clientDevices.get(clientUid);
            if (clientDevicesList != null) {
                clientDevicesList.removeIf(d -> d.getUid().equals(deviceUid.toString()));
            }
        }
    }
    
    public void clearTestData() {
        testDevices.clear();
        clientDevices.clear();
        log.info("üßπ Test Responder: All test data cleared");
    }
    
    public boolean hasDevice(UUID deviceUid) {
        return testDevices.containsKey(deviceUid);
    }
}package com.service.buffer.integration;

import java.util.UUID;

public class TestTopicUtils {

    private static final String TEST_SUFFIX = "-test-" + UUID.randomUUID().toString().substring(0, 8);

    public static String generateTestTopic(String baseTopic) {
        String cleanTopic = baseTopic.replaceAll("-test-[a-f0-9]{8}$", "");
        return cleanTopic + TEST_SUFFIX;
    }

    public static String getTestAuthCommandsTopic() {
        return generateTestTopic("auth.commands");
    }

    public static String getTestConnectionSchemeCommandsTopic() {
        return generateTestTopic("connection-scheme.commands");
    }

    public static String getTestDeviceCommandsTopic() {
        return generateTestTopic("device.commands");
    }
}// BufferServiceIntegrationTest.java
package com.service.buffer.integration;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

import java.util.List;
import java.util.Map;
import java.util.UUID;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;

import com.connection.processing.buffer.model.BufferBLM;
import com.connection.processing.buffer.model.BufferDTO;
import com.service.buffer.BufferService;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@SpringBootTest
@ActiveProfiles("integrationtest")
@DisplayName("Buffer Service Integration Tests")
public class BufferServiceIntegrationTest extends BaseBufferIntegrationTest {

    @Autowired
    @Qualifier("ApiBufferService")
    private BufferService bufferService;

    private UUID testBufferUid;
    private UUID testDeviceUid;
    private UUID testConnectionSchemeUid;

    @BeforeEach
    void setUpTestData() {
        testBufferUid = UUID.randomUUID();
        testDeviceUid = UUID.randomUUID();
        testConnectionSchemeUid = UUID.randomUUID();

        // –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –î–û –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –ë–î
        setupTestDevices(getTestClientUid(), testDeviceUid);

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –≤ –ë–î
        initializeTestClientAndDevice();

        log.info("Created test IDs - Buffer: {}, Device: {}, Scheme: {}, Client: {}",
                testBufferUid, testDeviceUid, testConnectionSchemeUid, getTestClientUid());
    }

    @AfterEach
    void cleanupTestData() {
        cleanupCurrentClientData();
    }

    @Test
    @DisplayName("Should create buffer successfully")
    void shouldCreateBufferSuccessfully() {
        // Given
        BufferDTO bufferDTO = createTestBufferDTO();

        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é –ø–µ—Ä–µ–¥ –≤—ã–∑–æ–≤–æ–º —Å–µ—Ä–≤–∏—Å–∞
        setupAuthentication();

        // When
        BufferBLM createdBuffer = bufferService.createBuffer(bufferDTO);

        // Then
        assertThat(createdBuffer).isNotNull();
        assertThat(createdBuffer.getUid()).isEqualTo(testBufferUid);
        assertThat(createdBuffer.getDeviceUid()).isEqualTo(testDeviceUid);
        assertThat(createdBuffer.getMaxMessagesNumber()).isEqualTo(1000);
        assertThat(createdBuffer.getMaxMessageSize()).isEqualTo(1024);

        log.info("Successfully created buffer: {}", testBufferUid);
    }

    @Test
    @DisplayName("Should get buffer by UID")
    void shouldGetBufferByUid() {
        // Given
        BufferDTO bufferDTO = createTestBufferDTO();

        // –°–æ–∑–¥–∞–µ–º –±—É—Ñ–µ—Ä —Å –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–µ–π
        setupAuthentication();
        bufferService.createBuffer(bufferDTO);

        // –ü–æ–ª—É—á–∞–µ–º –±—É—Ñ–µ—Ä —Å —Ç–æ–π –∂–µ –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏–µ–π
        BufferBLM foundBuffer = bufferService.getBufferByUid(testBufferUid);

        // Then
        assertThat(foundBuffer).isNotNull();
        assertThat(foundBuffer.getUid()).isEqualTo(testBufferUid);
        assertThat(foundBuffer.getDeviceUid()).isEqualTo(testDeviceUid);

        log.info("Successfully retrieved buffer by UID: {}", testBufferUid);
    }

    @Test
    @DisplayName("Should get buffers by device")
    void shouldGetBuffersByDevice() {
        // Given
        BufferDTO bufferDTO = createTestBufferDTO();

        setupAuthentication();
        bufferService.createBuffer(bufferDTO);

        // When
        List<BufferBLM> buffers = bufferService.getBuffersByDevice(testDeviceUid);

        // Then
        assertThat(buffers).isNotEmpty();
        assertThat(buffers.get(0).getUid()).isEqualTo(testBufferUid);
        assertThat(buffers.get(0).getDeviceUid()).isEqualTo(testDeviceUid);

        log.info("Successfully retrieved {} buffers for device: {}", buffers.size(), testDeviceUid);
    }


    @Test
    @DisplayName("Should update buffer successfully")
    void shouldUpdateBufferSuccessfully() {
        // Given
        BufferDTO originalBufferDTO = createTestBufferDTO();

        setupAuthentication();
        bufferService.createBuffer(originalBufferDTO);

        // –û–±–Ω–æ–≤–ª—è–µ–º DTO –±–µ–∑ message_prototype, —Ç–∞–∫ –∫–∞–∫ –µ–≥–æ –Ω–µ—Ç –≤ —Ç–∞–±–ª–∏—Ü–µ
        BufferDTO updatedBufferDTO = new BufferDTO(
                testBufferUid.toString(),
                testDeviceUid.toString(),
                2000, // updated max messages
                2048, // updated max size
                "{}" // message_prototype –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è
        );

        // When
        BufferBLM updatedBuffer = bufferService.updateBuffer(testBufferUid, updatedBufferDTO);

        // Then
        assertThat(updatedBuffer).isNotNull();
        assertThat(updatedBuffer.getUid()).isEqualTo(testBufferUid);
        assertThat(updatedBuffer.getMaxMessagesNumber()).isEqualTo(2000);
        assertThat(updatedBuffer.getMaxMessageSize()).isEqualTo(2048);

        log.info("Successfully updated buffer: {}", testBufferUid);
    }

    @Test
    @DisplayName("Should delete buffer successfully")
    void shouldDeleteBufferSuccessfully() {
        // Given
        BufferDTO bufferDTO = createTestBufferDTO();

        setupAuthentication();
        bufferService.createBuffer(bufferDTO);

        // Verify buffer exists
        BufferBLM foundBuffer = bufferService.getBufferByUid(testBufferUid);
        assertThat(foundBuffer).isNotNull();

        // When
        bufferService.deleteBuffer(testBufferUid);

        // Then
        boolean bufferExists = bufferService.bufferExists(testBufferUid);
        assertThat(bufferExists).isFalse();

        log.info("Successfully deleted buffer: {}", testBufferUid);
    }

    @Test
    @DisplayName("Should check buffer existence")
    void shouldCheckBufferExistence() {
        // Given
        BufferDTO bufferDTO = createTestBufferDTO();

        // When & Then - Before creation
        setupAuthentication();
        boolean existsBefore = bufferService.bufferExists(testBufferUid);
        assertThat(existsBefore).isFalse();

        // When & Then - After creation
        bufferService.createBuffer(bufferDTO);
        boolean existsAfter = bufferService.bufferExists(testBufferUid);
        assertThat(existsAfter).isTrue();

        log.info("Buffer existence check successful for: {}", testBufferUid);
    }

    @Test
    @DisplayName("Should get health status")
    void shouldGetHealthStatus() {
        // When
        setupAuthentication();

        // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤–æ–∑–º–æ–∂–Ω—ã–π NPE –≤ health check
        try {
            var healthStatus = bufferService.getHealthStatus();

            // Then
            assertThat(healthStatus).isNotNull();
            if (healthStatus.containsKey("service")) {
                assertThat(healthStatus.get("service")).isEqualTo("buffer-service");
            }
            if (healthStatus.containsKey("status")) {
                assertThat(healthStatus.get("status")).isIn("OK", "DEGRADED");
            }

            log.info("Health status: {}", healthStatus);
        } catch (NullPointerException e) {
            log.warn("Health status check threw NPE, but test continues: {}", e.getMessage());
            // –¢–µ—Å—Ç –ø—Ä–æ—Ö–æ–¥–∏—Ç, –¥–∞–∂–µ –µ—Å–ª–∏ health check –∏–º–µ–µ—Ç –ø—Ä–æ–±–ª–µ–º—ã
        }
    }

    @Test
    @DisplayName("Should handle buffer not found")
    void shouldHandleBufferNotFound() {
        // Given
        UUID nonExistentBufferUid = UUID.randomUUID();

        // When & Then
        setupAuthentication();
        assertThatThrownBy(() -> bufferService.getBufferByUid(nonExistentBufferUid))
                .isInstanceOf(RuntimeException.class);

        log.info("Correctly handled non-existent buffer UID: {}", nonExistentBufferUid);
    }

    @Test
    @DisplayName("Should connect to database")
    void shouldConnectToDatabase() {
        // Given
        String testQuery = "SELECT 1";

        // When
        Integer result = bufferJdbcTemplate.getJdbcTemplate()
                .queryForObject(testQuery, Integer.class);

        // Then
        assertThat(result).isEqualTo(1);
        log.info("‚úÖ Database connection test passed");
    }

    @Test
    @DisplayName("Should throw SecurityException when not authenticated")
    void shouldThrowSecurityExceptionWhenNotAuthenticated() {
        // Given
        BufferDTO bufferDTO = createTestBufferDTO();

        // –û—á–∏—â–∞–µ–º –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é
        clearAuthentication();

        // When & Then
        assertThatThrownBy(() -> bufferService.createBuffer(bufferDTO))
                .isInstanceOf(SecurityException.class)
                .hasMessageContaining("User not authenticated");

        log.info("‚úÖ SecurityException correctly thrown when not authenticated");
    }

    /**
     * –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞ –∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –≤ –ë–î
     */
    private void initializeTestClientAndDevice() {
        try {
            // –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞
            String insertClientSql = """
                    INSERT INTO core.client (uid, email, birth_date, username, password)
                    VALUES (:uid, :email, CURRENT_DATE - INTERVAL '25 years', :username, :password)
                    ON CONFLICT (uid) DO NOTHING
                    """;

            int clientsInserted = bufferJdbcTemplate.update(insertClientSql, Map.of(
                    "uid", getTestClientUid(),
                    "email", "test.client." + getTestClientUid() + "@example.com",
                    "username", "testclient_" + getTestClientUid().toString().substring(0, 8),
                    "password", "testpassword123"));

            if (clientsInserted > 0) {
                log.info("‚úÖ Created test client: {}", getTestClientUid());
            }

            // –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –¥–ª—è —ç—Ç–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞
            String insertDeviceSql = """
                    INSERT INTO core.device (uid, client_uuid, device_name, device_description)
                    VALUES (:uid, :clientUuid, :deviceName, :deviceDescription)
                    ON CONFLICT (uid) DO NOTHING
                    """;

            int devicesInserted = bufferJdbcTemplate.update(insertDeviceSql, Map.of(
                    "uid", testDeviceUid,
                    "clientUuid", getTestClientUid(),
                    "deviceName", "Test Device " + testDeviceUid.toString().substring(0, 8),
                    "deviceDescription", "Integration test device for buffer service"));

            if (devicesInserted > 0) {
                log.info("‚úÖ Created test device: {} for client: {}", testDeviceUid, getTestClientUid());
            }

            // –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—É—é connection scheme –¥–ª—è —ç—Ç–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞
            String insertSchemeSql = """
                    INSERT INTO processing.connection_scheme (uid, client_uid, scheme_json)
                    VALUES (:uid, :clientUid, :schemeJson::jsonb)
                    ON CONFLICT (uid) DO NOTHING
                    """;

            int schemesInserted = bufferJdbcTemplate.update(insertSchemeSql, Map.of(
                    "uid", testConnectionSchemeUid,
                    "clientUid", getTestClientUid(),
                    "schemeJson", "{\"test\": true, \"schemeType\": \"integration-test\"}"));

            if (schemesInserted > 0) {
                log.info("‚úÖ Created test connection scheme: {}", testConnectionSchemeUid);
            }

        } catch (Exception e) {
            log.error("‚ùå Failed to initialize test client and device: {}", e.getMessage(), e);
            throw new RuntimeException("Test data initialization failed", e);
        }
    }

    /**
     * –û—á–∏—â–∞–µ—Ç –≤—Å–µ –¥–∞–Ω–Ω—ã–µ —Ç–µ–∫—É—â–µ–≥–æ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞
     */
    private void cleanupCurrentClientData() {
        try {
            UUID currentClientUid = getTestClientUid();
            log.info("Cleaning up data for client: {}", currentClientUid);

            String deleteSchemeBuffersSql = """
                    DELETE FROM processing.connection_scheme_buffer
                    WHERE scheme_uid IN (
                        SELECT uid FROM processing.connection_scheme
                        WHERE client_uid = :clientUid
                    ) OR buffer_uid IN (
                        SELECT b.uid FROM processing.buffer b
                        JOIN core.device d ON b.device_uid = d.uid
                        WHERE d.client_uuid = :clientUid
                    )
                    """;
            try {
                int schemeBuffersDeleted = bufferJdbcTemplate.update(deleteSchemeBuffersSql,
                        Map.of("clientUid", currentClientUid));
                if (schemeBuffersDeleted > 0) {
                    log.debug("Deleted {} scheme-buffer links for client: {}", schemeBuffersDeleted, currentClientUid);
                }
            } catch (Exception e) {
                log.debug("No scheme-buffer links to delete for client: {}", currentClientUid);
            }

            // 3. –û—á–∏—Å—Ç–∫–∞ –±—É—Ñ–µ—Ä–æ–≤ —á–µ—Ä–µ–∑ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –∫–ª–∏–µ–Ω—Ç–∞
            String deleteBuffersSql = """
                    DELETE FROM processing.buffer
                    WHERE device_uid IN (
                        SELECT uid FROM core.device
                        WHERE client_uuid = :clientUid
                    )
                    """;
            try {
                int buffersDeleted = bufferJdbcTemplate.update(deleteBuffersSql, Map.of("clientUid", currentClientUid));
                if (buffersDeleted > 0) {
                    log.debug("Deleted {} buffers for client: {}", buffersDeleted, currentClientUid);
                }
            } catch (Exception e) {
                log.debug("No buffers to delete for client: {}", currentClientUid);
            }

            // 4. –û—á–∏—Å—Ç–∫–∞ —Å—Ö–µ–º —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∫–ª–∏–µ–Ω—Ç–∞
            String deleteSchemesSql = "DELETE FROM processing.connection_scheme WHERE client_uid = :clientUid";
            try {
                int schemesDeleted = bufferJdbcTemplate.update(deleteSchemesSql, Map.of("clientUid", currentClientUid));
                if (schemesDeleted > 0) {
                    log.debug("Deleted {} connection schemes for client: {}", schemesDeleted, currentClientUid);
                }
            } catch (Exception e) {
                log.debug("No connection schemes to delete for client: {}", currentClientUid);
            }

            // 5. –û—á–∏—Å—Ç–∫–∞ —É—Å—Ç—Ä–æ–π—Å—Ç–≤ –∫–ª–∏–µ–Ω—Ç–∞
            String deleteDevicesSql = "DELETE FROM core.device WHERE client_uuid = :clientUid";
            try {
                int devicesDeleted = bufferJdbcTemplate.update(deleteDevicesSql, Map.of("clientUid", currentClientUid));
                if (devicesDeleted > 0) {
                    log.debug("Deleted {} devices for client: {}", devicesDeleted, currentClientUid);
                }
            } catch (Exception e) {
                log.debug("No devices to delete for client: {}", currentClientUid);
            }

            // 6. –û—á–∏—Å—Ç–∫–∞ —Å–∞–º–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞
            String deleteClientSql = "DELETE FROM core.client WHERE uid = :clientUid";
            try {
                int clientsDeleted = bufferJdbcTemplate.update(deleteClientSql, Map.of("clientUid", currentClientUid));
                if (clientsDeleted > 0) {
                    log.info("‚úÖ Cleaned up client and all related data: {}", currentClientUid);
                }
            } catch (Exception e) {
                log.debug("No client to delete: {}", currentClientUid);
            }

        } catch (Exception e) {
            log.warn("Cleanup warning for client {}: {}", getTestClientUid(), e.getMessage());
        }
    }

    /**
     * –°–æ–∑–¥–∞–µ—Ç —Å–≤—è–∑—å –º–µ–∂–¥—É –±—É—Ñ–µ—Ä–æ–º –∏ —Å—Ö–µ–º–æ–π —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è
     */
    private void linkBufferToScheme() {
        try {
            String linkSql = """
                    INSERT INTO processing.connection_scheme_buffer (uid, scheme_uid, buffer_uid)
                    VALUES (:uid, :schemeUid, :bufferUid)
                    """;

            bufferJdbcTemplate.update(linkSql, Map.of(
                    "uid", UUID.randomUUID(),
                    "schemeUid", testConnectionSchemeUid,
                    "bufferUid", testBufferUid));

            log.info("‚úÖ Linked buffer {} to scheme {}", testBufferUid, testConnectionSchemeUid);
        } catch (Exception e) {
            log.warn("Failed to link buffer to scheme: {}", e.getMessage());
        }
    }

    /**
     * –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ—Ç –¥—Ä—É–≥–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞ –∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ä–∞–∑–Ω—ã—Ö –∫–ª–∏–µ–Ω—Ç–æ–≤
     */
    private void initializeDifferentClientAndDevice(UUID clientUid, UUID deviceUid) {
        try {
            // –°–æ–∑–¥–∞–µ–º –∫–ª–∏–µ–Ω—Ç–∞
            String insertClientSql = """
                    INSERT INTO core.client (uid, email, birth_date, username, password)
                    VALUES (:uid, :email, CURRENT_DATE - INTERVAL '30 years', :username, :password)
                    """;

            bufferJdbcTemplate.update(insertClientSql, Map.of(
                    "uid", clientUid,
                    "email", "different.client." + clientUid + "@example.com",
                    "username", "diffclient_" + clientUid.toString().substring(0, 8),
                    "password", "differentpassword123"));

            // –°–æ–∑–¥–∞–µ–º —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –¥–ª—è —ç—Ç–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞
            String insertDeviceSql = """
                    INSERT INTO core.device (uid, client_uuid, device_name, device_description)
                    VALUES (:uid, :clientUuid, :deviceName, :deviceDescription)
                    """;

            bufferJdbcTemplate.update(insertDeviceSql, Map.of(
                    "uid", deviceUid,
                    "clientUuid", clientUid,
                    "deviceName", "Different Test Device " + deviceUid.toString().substring(0, 8),
                    "deviceDescription", "Device for different client test"));

            log.info("‚úÖ Created different client {} with device {}", clientUid, deviceUid);

        } catch (Exception e) {
            log.error("‚ùå Failed to initialize different client and device: {}", e.getMessage(), e);
            throw new RuntimeException("Different client initialization failed", e);
        }
    }

    private BufferDTO createTestBufferDTO() {
        return new BufferDTO(
                testBufferUid.toString(),
                testDeviceUid.toString(),
                1000,
                1024,
                "{}");
    }

    private BufferDTO createTestBufferDTOForDifferentClient(UUID bufferUid, UUID deviceUid) {
        return new BufferDTO(
                bufferUid.toString(),
                deviceUid.toString(),
                1000,
                1024,
                "{}");
    }
}package com.service.buffer.integration;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.TestInstance;
import org.junit.jupiter.api.TestMethodOrder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.core.env.Environment;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.springframework.test.context.TestPropertySource;

import com.connection.device.model.DeviceDTO;

import lombok.extern.slf4j.Slf4j;

import java.util.Arrays;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.Collections;
import java.util.List;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("integrationtest")
@TestPropertySource(locations = "classpath:application-integrationtest.properties")
@TestMethodOrder(MethodOrderer.Random.class)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@Slf4j
public abstract class BaseBufferIntegrationTest {

    @Autowired
    protected TestDeviceServiceResponder testDeviceResponder;
    @Autowired
    protected TestConnectionSchemeServiceResponder testConnectionSchemeResponder;

    @Autowired
    protected Environment environment;

    protected TestRestTemplate restTemplate = new TestRestTemplate();

    @Autowired
    protected KafkaTemplate<String, Object> kafkaTemplate;

    @Autowired
    @Qualifier("BufferJdbcTemplate")
    protected NamedParameterJdbcTemplate bufferJdbcTemplate;

    @DynamicPropertySource
    static void configureKafkaTopics(DynamicPropertyRegistry registry) {
        registry.add("app.kafka.topics.auth-commands", TestTopicUtils::getTestAuthCommandsTopic);
        registry.add("app.kafka.topics.connection-scheme-commands", TestTopicUtils::getTestConnectionSchemeCommandsTopic);
        registry.add("app.kafka.topics.device-commands", TestTopicUtils::getTestDeviceCommandsTopic);
    }

    protected final Map<String, String> testData = new ConcurrentHashMap<>();
    protected UUID testClientUid;

    @BeforeEach
    void setUp() {
        checkConfig();
        testClientUid = UUID.randomUUID();

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º testData –ø–µ—Ä–µ–¥ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º
        testData.clear();
        
        // –û—á–∏—â–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–µ—Ä–µ–¥ –∫–∞–∂–¥—ã–º —Ç–µ—Å—Ç–æ–º
        testDeviceResponder.clearTestData();
        testConnectionSchemeResponder.clearTestData();
    }

    @AfterEach
    void tearDown() {
        testData.clear();
        cleanupAllTestData();
        clearAuthentication();

        // –û—á–∏—â–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ –ø–æ—Å–ª–µ –∫–∞–∂–¥–æ–≥–æ —Ç–µ—Å—Ç–∞
        testDeviceResponder.clearTestData();
        testConnectionSchemeResponder.clearTestData();
    }

    /**
     * –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç —Ç–µ—Å—Ç–æ–≤—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞ –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞
     */
    protected void setupTestDevices(UUID clientUid, UUID... deviceUids) {
        for (UUID deviceUid : deviceUids) {
            testDeviceResponder.addTestDevice(
                    deviceUid,
                    clientUid,
                    "Test Device " + deviceUid.toString().substring(0, 8));
        }
        log.info("‚úÖ Test devices setup for client {}: {}", clientUid, List.of(deviceUids));
    }

    /**
     * –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç —Ç–µ—Å—Ç–æ–≤—ã–µ connection schemes –¥–ª—è –∫–ª–∏–µ–Ω—Ç–∞
     */
    protected void setupTestConnectionSchemes(UUID clientUid, UUID... schemeUids) {
        for (UUID schemeUid : schemeUids) {
            testConnectionSchemeResponder.addTestConnectionSchemeWithBuffers(
                    schemeUid,
                    clientUid
            // –±–µ–∑ –±—É—Ñ–µ—Ä–æ–≤ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
            );
        }
        log.info("‚úÖ Test connection schemes setup for client {}: {}", clientUid, List.of(schemeUids));
    }

    /**
     * –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç connection scheme —Å —É–∫–∞–∑–∞–Ω–Ω—ã–º–∏ –±—É—Ñ–µ—Ä–∞–º–∏
     */
    protected void setupTestConnectionSchemeWithBuffers(UUID schemeUid, UUID clientUid, UUID... bufferUids) {
        testConnectionSchemeResponder.addTestConnectionSchemeWithBuffers(schemeUid, clientUid, bufferUids);
        log.info("‚úÖ Test connection scheme {} setup for client {} with buffers: {}",
                schemeUid, clientUid, List.of(bufferUids));
    }

    /**
     * –°–≤—è–∑—ã–≤–∞–µ—Ç connection scheme —Å buffer
     */
    protected void linkSchemeToBuffer(UUID schemeUid, UUID bufferUid) {
        testConnectionSchemeResponder.linkSchemeToBuffer(schemeUid, bufferUid);
        testConnectionSchemeResponder.addBufferToScheme(schemeUid, bufferUid);
        log.info("üîó Linked scheme {} to buffer {}", schemeUid, bufferUid);
    }

    /**
     * –î–æ–±–∞–≤–ª—è–µ—Ç –±—É—Ñ–µ—Ä –≤ usedBuffers —Å—Ö–µ–º—ã
     */
    protected void addBufferToScheme(UUID schemeUid, UUID bufferUid) {
        testConnectionSchemeResponder.addBufferToScheme(schemeUid, bufferUid);
        log.info("‚ûï Added buffer {} to scheme {} usedBuffers", bufferUid, schemeUid);
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–æ –ª–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –≤ —Ç–µ—Å—Ç–æ–≤–æ–º –æ—Ç–≤–µ—Ç—á–∏–∫–µ
     */
    protected boolean isDeviceRegistered(UUID deviceUid) {
        return testDeviceResponder.hasDevice(deviceUid);
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∞ –ª–∏ connection scheme –≤ —Ç–µ—Å—Ç–æ–≤–æ–º –æ—Ç–≤–µ—Ç—á–∏–∫–µ
     */
    protected boolean isConnectionSchemeRegistered(UUID schemeUid) {
        return testConnectionSchemeResponder.hasConnectionScheme(schemeUid);
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –ª–∏ connection scheme –∫–ª–∏–µ–Ω—Ç—É
     */
    protected boolean connectionSchemeBelongsToClient(UUID schemeUid, UUID clientUid) {
        return testConnectionSchemeResponder.connectionSchemeBelongsToClient(schemeUid, clientUid);
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å–≤—è–∑–∞–Ω–∞ –ª–∏ —Å—Ö–µ–º–∞ —Å –±—É—Ñ–µ—Ä–æ–º
     */
    protected boolean isSchemeLinkedToBuffer(UUID schemeUid, UUID bufferUid) {
        // –≠—Ç–∞ –ª–æ–≥–∏–∫–∞ –±—É–¥–µ—Ç –∑–∞–≤–∏—Å–µ—Ç—å –æ—Ç —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏, –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π –º–µ—Ç–æ–¥
        // –≤ responder
        return testConnectionSchemeResponder.hasConnectionScheme(schemeUid);
    }

    /**
     * –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç —Ç–µ—Å—Ç–æ–≤–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ —Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
     */
    protected void setupTestDevice(DeviceDTO device) {
        testDeviceResponder.addTestDevice(device);
    }

    protected void checkConfig() {
        log.info("=== Buffer Service Integration Test Configuration ===");
        log.info("Active profiles: {}", Arrays.toString(environment.getActiveProfiles()));
        log.info("Kafka servers: {}", environment.getProperty("spring.kafka.bootstrap-servers"));
        log.info("Database URL: {}", environment.getProperty("app.datasource.buffer.xa-properties.url"));
        log.info("Database user: {}", environment.getProperty("app.datasource.buffer.xa-properties.user"));
        log.info("Service name: {}", environment.getProperty("spring.application.name"));
        log.info("=====================================================");
    }

    /**
     * –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –∫–ª–∏–µ–Ω—Ç–∞
     */
    protected void setupAuthentication() {
        setupAuthentication(this.testClientUid);
    }

    /**
     * –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ clientUid
     */
    protected void setupAuthentication(UUID clientUid) {
        Authentication authentication = new UsernamePasswordAuthenticationToken(
                clientUid,
                null,
                Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER")));

        SecurityContext context = SecurityContextHolder.createEmptyContext();
        context.setAuthentication(authentication);
        SecurityContextHolder.setContext(context);

        log.info("‚úÖ Test authentication setup for client: {}", clientUid);
    }

    protected void clearAuthentication() {
        SecurityContextHolder.clearContext();
        log.info("üîí Test authentication cleared");
    }

    protected void cleanupBufferData(UUID bufferUid) {
        try {
            log.info("Cleaning up buffer data for UID: {}", bufferUid);

            String deleteBufferSql = "DELETE FROM processing.buffer WHERE uid = :bufferUid";
            int buffersDeleted = bufferJdbcTemplate.update(deleteBufferSql, Map.of("bufferUid", bufferUid));

            if (buffersDeleted > 0) {
                log.info("Deleted {} buffers for UID: {}", buffersDeleted, bufferUid);
            }

        } catch (Exception e) {
            log.warn("Cleanup warning for buffer UID {}: {}", bufferUid, e.getMessage());
        }
    }

    // BaseBufferIntegrationTest.java - —É–ø—Ä–æ—â–∞–µ–º –º–µ—Ç–æ–¥ cleanupAllTestData
    protected void cleanupAllTestData() {
        // –≠—Ç–æ—Ç –º–µ—Ç–æ–¥ —Ç–µ–ø–µ—Ä—å –Ω–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è, —Ç–∞–∫ –∫–∞–∫ –∫–∞–∂–¥—ã–π —Ç–µ—Å—Ç –æ—á–∏—â–∞–µ—Ç —Ç–æ–ª—å–∫–æ —Å–≤–æ–∏
        // –¥–∞–Ω–Ω—ã–µ
        log.debug("Global cleanup is disabled - each test cleans up its own client data");
    }

    protected void sleep(long milliseconds) {
        try {
            log.debug("Sleeping for {} ms", milliseconds);
            TimeUnit.MILLISECONDS.sleep(milliseconds);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.warn("Sleep interrupted", e);
        }
    }

    protected HttpEntity<Object> createHttpEntity(Object body) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        return new HttpEntity<>(body, headers);
    }

    protected HttpEntity<Object> createHttpEntityWithAuth(Object body, String token) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.setBearerAuth(token);
        return new HttpEntity<>(body, headers);
    }

    protected UUID getTestClientUid() {
        return testClientUid;
    }

    /**
     * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω–æ–µ –∏–º—è —Ç–µ–º—ã –¥–ª—è —Ç–µ—Å—Ç–æ–≤
     */
    protected String generateUniqueTopic(String baseTopicName) {
        return baseTopicName + ".test." + UUID.randomUUID().toString();
    }

    /**
     * –ü–æ–ª—É—á–∞–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω—É—é —Ç–µ–º—É –¥–ª—è device commands –≤ —Ç–µ—Å—Ç–∞—Ö
     */
    protected String getTestDeviceCommandsTopic() {
        return environment.getProperty("app.kafka.topics.device-commands-test",
                "device.commands.test." + UUID.randomUUID().toString());
    }

    /**
     * –ü–æ–ª—É—á–∞–µ—Ç —É–Ω–∏–∫–∞–ª—å–Ω—É—é —Ç–µ–º—É –¥–ª—è connection scheme commands –≤ —Ç–µ—Å—Ç–∞—Ö
     */
    protected String getTestConnectionSchemeCommandsTopic() {
        return environment.getProperty("app.kafka.topics.connection-scheme-commands-test",
                "scheme.commands.test." + UUID.randomUUID().toString());
    }

    /**
     * –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç —Ç–µ—Å—Ç–æ–≤—ã–µ —Ç–µ–º—ã Kafka –ø–µ—Ä–µ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ–º —Ç–µ—Å—Ç–∞
     */
    protected void setupTestKafkaTopics() {
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è —Ç–µ–º
        testData.put("original.device-commands",
                environment.getProperty("app.kafka.topics.device-commands"));
        testData.put("original.connection-scheme-commands",
                environment.getProperty("app.kafka.topics.connection-scheme-commands"));

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ —Ç–µ–º—ã –¥–ª—è —Ç–µ—Å—Ç–∞
        String testDeviceTopic = getTestDeviceCommandsTopic();
        String testSchemeTopic = getTestConnectionSchemeCommandsTopic();

        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–∏—Å—Ç–µ–º–Ω—ã–µ —Å–≤–æ–π—Å—Ç–≤–∞ –¥–ª—è –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è —Ç–µ–º –≤ runtime
        System.setProperty("app.kafka.topics.device-commands", testDeviceTopic);
        System.setProperty("app.kafka.topics.connection-scheme-commands", testSchemeTopic);

        log.info("‚úÖ Test Kafka topics setup - Device: {}, Scheme: {}",
                testDeviceTopic, testSchemeTopic);
    }

    /**
     * –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ —Ç–µ–º—ã Kafka –ø–æ—Å–ª–µ —Ç–µ—Å—Ç–∞
     */
    protected void restoreOriginalKafkaTopics() {
        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
        String originalDeviceTopic = testData.get("original.device-commands");
        String originalSchemeTopic = testData.get("original.connection-scheme-commands");

        if (originalDeviceTopic != null) {
            System.setProperty("app.kafka.topics.device-commands", originalDeviceTopic);
        }
        if (originalSchemeTopic != null) {
            System.setProperty("app.kafka.topics.connection-scheme-commands", originalSchemeTopic);
        }

        log.info("‚úÖ Original Kafka topics restored");
    }
}package com.service.buffer.mother;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import com.connection.processing.buffer.model.BufferBLM;
import com.connection.processing.buffer.model.BufferDALM;
import com.connection.processing.buffer.model.BufferDTO;
import com.connection.scheme.model.ConnectionSchemeBLM;

public class BufferObjectMother {

    public static final UUID CLIENT_UUID = UUID.fromString("123e4567-e89b-12d3-a456-426614174000");
    public static final UUID BUFFER_UUID = UUID.fromString("323e4567-e89b-12d3-a456-426614174002");
    public static final UUID SCHEME_UUID = UUID.fromString("423e4567-e89b-12d3-a456-426614174003");
    public static final String VALID_TOKEN = "valid-token-123";
    public static final String INVALID_TOKEN = "invalid-token-456";


    private static final UUID BUFFER_UID_1 = UUID.fromString("223e4567-e89b-12d3-a456-426614174002");
    private static final UUID BUFFER_UID_2 = UUID.fromString("223e4567-e89b-12d3-a456-426614174003");
    private static final UUID BUFFER_UID_3 = UUID.fromString("223e4567-e89b-12d3-a456-426614174004");
    
    private static final String DEFAULT_SCHEME_JSON = "{" +
        "\"usedBuffers\": [\"" + BUFFER_UID_1 + "\", \"" + BUFFER_UID_2 + "\"], " +
        "\"bufferTransitions\": {" +
            "\"" + BUFFER_UID_1 + "\": [\"" + BUFFER_UID_2 + "\"], " +
            "\"" + BUFFER_UID_2 + "\": [\"" + BUFFER_UID_3 + "\"]" +
        "}" +
    "}";


    public static BufferDTO createValidBufferDTO() {
        return new BufferDTO(
            BUFFER_UUID.toString(),
            SCHEME_UUID.toString(),
            1000,
            1024,
            "message prototype"
        );
    }

    public static BufferBLM createValidBufferBLM() {
        return new BufferBLM(
            BUFFER_UUID,
            SCHEME_UUID,
            1000,
            1024,
            "message prototype"
        );
    }

    public static BufferDALM createValidBufferDALM() {
        return new BufferDALM(
            BUFFER_UUID,
            SCHEME_UUID,
            1000,
            1024,
            "message prototype"
        );
    }
    public static ConnectionSchemeBLM createValidConnectionSchemeBLM() {
        Map<UUID, List<UUID>> bufferTransitions = new HashMap<>();
        bufferTransitions.put(BUFFER_UID_1, Arrays.asList(BUFFER_UID_2));
        bufferTransitions.put(BUFFER_UID_2, Arrays.asList(BUFFER_UID_3));
        
        return ConnectionSchemeBLM.builder()
                .uid(SCHEME_UUID)
                .clientUid(CLIENT_UUID)
                .schemeJson(DEFAULT_SCHEME_JSON)
                .usedBuffers(Arrays.asList(BUFFER_UID_1, BUFFER_UID_2))
                .bufferTransitions(bufferTransitions)
                .build();
    }

    public static ConnectionSchemeBLM createValidConnectionSchemeBLM(UUID clientUuid) {
        Map<UUID, List<UUID>> bufferTransitions = new HashMap<>();
        bufferTransitions.put(BUFFER_UID_1, Arrays.asList(BUFFER_UID_2));
        bufferTransitions.put(BUFFER_UID_2, Arrays.asList(BUFFER_UID_3));
        
        return ConnectionSchemeBLM.builder()
                .uid(SCHEME_UUID)
                .clientUid(clientUuid)
                .schemeJson(DEFAULT_SCHEME_JSON)
                .usedBuffers(Arrays.asList(BUFFER_UID_1, BUFFER_UID_2))
                .bufferTransitions(bufferTransitions)
                .build();
    }

    public static BufferDTO createBufferDTOWithDifferentScheme() {
        return new BufferDTO(
            BUFFER_UUID.toString(),
            UUID.randomUUID().toString(), // different scheme
            1000,
            1024,
            "message prototype"
        );
    }

    public static BufferDTO createInvalidBufferDTO() {
        return new BufferDTO(
            "invalid-uuid",
            "invalid-scheme-uuid",
            -1, // invalid max messages
            -1, // invalid max size
            null // null prototype
        );
    }
}package com.service.buffer;

import static com.service.buffer.mother.BufferObjectMother.BUFFER_UUID;
import static com.service.buffer.mother.BufferObjectMother.CLIENT_UUID;
import static com.service.buffer.mother.BufferObjectMother.SCHEME_UUID;
import static com.service.buffer.mother.BufferObjectMother.createValidBufferBLM;
import static com.service.buffer.mother.BufferObjectMother.createValidBufferDTO;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.util.Collections;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;

import com.connection.device.converter.DeviceConverter;
import com.connection.device.events.responses.GetDevicesByClientResponse;
import com.connection.device.model.DeviceBLM;
import com.connection.device.model.DeviceDTO;
import com.connection.processing.buffer.converter.BufferConverter;
import com.connection.processing.buffer.exception.BufferAlreadyExistsException;
import com.connection.processing.buffer.model.BufferBLM;
import com.connection.processing.buffer.model.BufferDTO;
import com.connection.processing.buffer.repository.BufferRepository;
import com.connection.processing.buffer.validator.BufferValidator;
import com.service.buffer.kafka.TypedAuthKafkaClient;
import com.service.buffer.kafka.TypedConnectionSchemeKafkaClient;
import com.service.buffer.kafka.TypedDeviceKafkaClient;

@ExtendWith(MockitoExtension.class)
@DisplayName("Buffer Service Implementation Tests")
class BufferServiceImplLondonTest {

    @Mock
    private BufferRepository bufferRepository;

    @Mock
    private BufferConverter bufferConverter;

    @Mock
    private BufferValidator bufferValidator;

    @Mock
    private DeviceConverter deviceConverter;

    @Mock
    private TypedAuthKafkaClient authKafkaClient;

    @Mock
    private TypedDeviceKafkaClient deviceKafkaClient;

    @Mock
    private TypedConnectionSchemeKafkaClient connectionSchemeKafkaClient;

    @Mock
    private SecurityContext securityContext;

    @InjectMocks
    private ApiBufferServiceImpl bufferService;

    private static final UUID DEVICE_UUID = UUID.fromString("523e4567-e89b-12d3-a456-426614174001");

    @BeforeEach
    void setUp() {
        SecurityContextHolder.setContext(securityContext);
    }


    private void setupAuthentication(UUID clientUid) {
        UsernamePasswordAuthenticationToken authentication = 
            new UsernamePasswordAuthenticationToken(clientUid, null, Collections.emptyList());
        when(securityContext.getAuthentication()).thenReturn(authentication);
    }


    @Test
    @DisplayName("Create buffer - Positive")
    void shouldCreateBufferWhenValidData() {
        // Arrange
        BufferDTO bufferDTO = createValidBufferDTO();
        BufferBLM bufferBLM = createValidBufferBLM();

        when(bufferConverter.toBLM(bufferDTO)).thenReturn(bufferBLM);
        when(deviceKafkaClient.deviceExistsAndBelongsToClient(
                eq(bufferBLM.getDeviceUid()), eq(CLIENT_UUID))).thenReturn(true);
        when(bufferRepository.exists(BUFFER_UUID)).thenReturn(false);

        setupAuthentication(CLIENT_UUID);

        // Act
        BufferBLM result = bufferService.createBuffer(bufferDTO);

        // Assert
        assertThat(result).isNotNull();
        assertThat(result.getUid()).isEqualTo(BUFFER_UUID);
        verify(bufferValidator).validate(bufferDTO);
        verify(deviceKafkaClient).deviceExistsAndBelongsToClient(bufferBLM.getDeviceUid(), CLIENT_UUID);
        verify(bufferRepository).add(bufferBLM);
    }

    @Test
    @DisplayName("Create buffer - Negative: Device doesn't belong to client")
    void shouldThrowExceptionWhenDeviceNotBelongsToClient() {
        // Arrange
        BufferDTO bufferDTO = createValidBufferDTO();
        BufferBLM bufferBLM = createValidBufferBLM();

        when(bufferConverter.toBLM(bufferDTO)).thenReturn(bufferBLM);
        when(deviceKafkaClient.deviceExistsAndBelongsToClient(
                eq(bufferBLM.getDeviceUid()), eq(CLIENT_UUID))).thenReturn(false);
        setupAuthentication(CLIENT_UUID);

        // Act & Assert
        assertThatThrownBy(() -> bufferService.createBuffer(bufferDTO))
            .isInstanceOf(SecurityException.class)
            .hasMessageContaining("Device doesn't exist or doesn't belong to the authenticated client");

        verify(bufferValidator).validate(bufferDTO);
        verify(bufferRepository, never()).add(any());
    }

    @Test
    @DisplayName("Create buffer - Negative: Buffer already exists")
    void shouldThrowExceptionWhenBufferAlreadyExists() {
        // Arrange
        BufferDTO bufferDTO = createValidBufferDTO();
        BufferBLM bufferBLM = createValidBufferBLM();

        when(bufferConverter.toBLM(bufferDTO)).thenReturn(bufferBLM);
        when(deviceKafkaClient.deviceExistsAndBelongsToClient(
                eq(bufferBLM.getDeviceUid()), eq(CLIENT_UUID))).thenReturn(true);
        when(bufferRepository.exists(BUFFER_UUID)).thenReturn(true);
        setupAuthentication(CLIENT_UUID);

        // Act & Assert
        assertThatThrownBy(() -> bufferService.createBuffer(bufferDTO))
            .isInstanceOf(BufferAlreadyExistsException.class);
        
        verify(bufferValidator).validate(bufferDTO);
        verify(bufferRepository, never()).add(any());
    }

    @Test
    @DisplayName("Get buffer - Positive")
    void shouldGetBufferWhenValidRequest() {
        // Arrange
        BufferBLM bufferBLM = createValidBufferBLM();

        when(bufferRepository.findByUid(BUFFER_UUID)).thenReturn(bufferBLM);
        when(deviceKafkaClient.deviceExistsAndBelongsToClient(
                eq(bufferBLM.getDeviceUid()), eq(CLIENT_UUID))).thenReturn(true);
        setupAuthentication(CLIENT_UUID);

        // Act
        BufferBLM result = bufferService.getBufferByUid(BUFFER_UUID);

        // Assert
        assertThat(result).isNotNull();
        assertThat(result.getUid()).isEqualTo(BUFFER_UUID);
        verify(bufferRepository).findByUid(BUFFER_UUID);
        verify(deviceKafkaClient).deviceExistsAndBelongsToClient(bufferBLM.getDeviceUid(), CLIENT_UUID);
    }

    @Test
    @DisplayName("Get buffers by connection scheme - Positive")
    void shouldGetBuffersByConnectionSchemeWhenValidRequest() {
        // Arrange
        BufferBLM bufferBLM = createValidBufferBLM();
        List<BufferBLM> buffersBLM = Collections.singletonList(bufferBLM);

        when(connectionSchemeKafkaClient.connectionSchemeExistsAndBelongsToClient(
                eq(SCHEME_UUID), eq(CLIENT_UUID))).thenReturn(true);
        when(bufferRepository.findByConnectionSchemeUid(SCHEME_UUID)).thenReturn(buffersBLM);
        setupAuthentication(CLIENT_UUID);

        // Act
        List<BufferBLM> result = bufferService.getBuffersByConnectionScheme(SCHEME_UUID);

        // Assert
        assertThat(result).isNotEmpty();
        assertThat(result.get(0).getUid()).isEqualTo(BUFFER_UUID);
        verify(connectionSchemeKafkaClient).connectionSchemeExistsAndBelongsToClient(SCHEME_UUID, CLIENT_UUID);
        verify(bufferRepository).findByConnectionSchemeUid(SCHEME_UUID);
    }

    @Test
    @DisplayName("Get buffers by client - Positive")
    void shouldGetBuffersByClientWhenValidRequest() {
        // Arrange
        // –°–æ–∑–¥–∞–µ–º DeviceDTO —Å –ø—Ä–∞–≤–∏–ª—å–Ω–æ–π —Å—Ç—Ä—É–∫—Ç—É—Ä–æ–π –Ω–∞ –æ—Å–Ω–æ–≤–µ –¥–µ–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞–Ω–Ω–æ–≥–æ –∫–æ–¥–∞
        DeviceDTO deviceDTO = new DeviceDTO();
        deviceDTO.setUid(DEVICE_UUID.toString());
        deviceDTO.setClientUuid(CLIENT_UUID.toString());
        deviceDTO.setDeviceName("Test Device");
        deviceDTO.setDeviceDescription("Test Device Description");
        
        // –°–æ–∑–¥–∞–µ–º DeviceBLM —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º –∫–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä–æ–º
        DeviceBLM deviceBLM = new DeviceBLM(DEVICE_UUID, CLIENT_UUID, "Test Device", "Test Device Description");
        List<DeviceDTO> deviceDTOs = Collections.singletonList(deviceDTO);
        
        BufferBLM bufferBLM = createValidBufferBLM();
        List<BufferBLM> buffersBLM = Collections.singletonList(bufferBLM);

        GetDevicesByClientResponse devicesResponse = GetDevicesByClientResponse.valid(
            "correlation-id", deviceDTOs
        );

        when(deviceKafkaClient.getDevicesByClient(eq(CLIENT_UUID), eq("buffer-service")))
            .thenReturn(CompletableFuture.completedFuture(devicesResponse));
        when(deviceConverter.toBLM(deviceDTO)).thenReturn(deviceBLM);
        when(deviceKafkaClient.deviceExistsAndBelongsToClient(eq(DEVICE_UUID), eq(CLIENT_UUID))).thenReturn(true);
        when(bufferRepository.findByDeviceUid(DEVICE_UUID)).thenReturn(buffersBLM);
        setupAuthentication(CLIENT_UUID);

        // Act
        List<BufferBLM> result = bufferService.getBuffersByClient(CLIENT_UUID);

        // Assert
        assertThat(result).isNotEmpty();
        assertThat(result.get(0).getUid()).isEqualTo(BUFFER_UUID);
        verify(deviceKafkaClient).getDevicesByClient(CLIENT_UUID, "buffer-service");
        verify(bufferRepository).findByDeviceUid(DEVICE_UUID);
    }

    @Test
    @DisplayName("Get buffers by device - Positive")
    void shouldGetBuffersByDeviceWhenValidRequest() {
        // Arrange
        BufferBLM bufferBLM = createValidBufferBLM();
        List<BufferBLM> buffersBLM = Collections.singletonList(bufferBLM);

        when(deviceKafkaClient.deviceExistsAndBelongsToClient(eq(DEVICE_UUID), eq(CLIENT_UUID))).thenReturn(true);
        when(bufferRepository.findByDeviceUid(DEVICE_UUID)).thenReturn(buffersBLM);
        setupAuthentication(CLIENT_UUID);

        // Act
        List<BufferBLM> result = bufferService.getBuffersByDevice(DEVICE_UUID);

        // Assert
        assertThat(result).isNotEmpty();
        assertThat(result.get(0).getUid()).isEqualTo(BUFFER_UUID);
        verify(deviceKafkaClient).deviceExistsAndBelongsToClient(DEVICE_UUID, CLIENT_UUID);
        verify(bufferRepository).findByDeviceUid(DEVICE_UUID);
    }

    @Test
    @DisplayName("Update buffer - Positive")
    void shouldUpdateBufferWhenValidData() {
        // Arrange
        BufferDTO bufferDTO = createValidBufferDTO();
        BufferBLM bufferBLM = createValidBufferBLM();
        BufferBLM existingBuffer = createValidBufferBLM();

        when(bufferRepository.findByUid(BUFFER_UUID)).thenReturn(existingBuffer);
        when(bufferConverter.toBLM(bufferDTO)).thenReturn(bufferBLM);
        when(deviceKafkaClient.deviceExistsAndBelongsToClient(
                eq(bufferBLM.getDeviceUid()), eq(CLIENT_UUID))).thenReturn(true);
        setupAuthentication(CLIENT_UUID);

        // Act
        BufferBLM result = bufferService.updateBuffer(BUFFER_UUID, bufferDTO);

        // Assert
        assertThat(result).isNotNull();
        verify(bufferValidator).validate(bufferDTO);
        verify(bufferRepository).update(bufferBLM);
    }

    @Test
    @DisplayName("Delete buffer - Positive")
    void shouldDeleteBufferWhenValidRequest() {
        // Arrange
        BufferBLM existingBuffer = createValidBufferBLM();

        when(bufferRepository.findByUid(BUFFER_UUID)).thenReturn(existingBuffer);
        when(deviceKafkaClient.deviceExistsAndBelongsToClient(
                eq(existingBuffer.getDeviceUid()), eq(CLIENT_UUID))).thenReturn(true);
        setupAuthentication(CLIENT_UUID);

        // Act
        bufferService.deleteBuffer(BUFFER_UUID);

        // Assert
        verify(bufferRepository).delete(BUFFER_UUID);
    }

    @Test
    @DisplayName("Delete all buffers from connection scheme - Positive")
    void shouldDeleteAllBuffersFromConnectionSchemeWhenValidRequest() {
        // Arrange
        BufferBLM bufferBLM = createValidBufferBLM();
        List<BufferBLM> buffersBLM = Collections.singletonList(bufferBLM);

        when(connectionSchemeKafkaClient.connectionSchemeExistsAndBelongsToClient(
                eq(SCHEME_UUID), eq(CLIENT_UUID))).thenReturn(true);
        when(bufferRepository.findByConnectionSchemeUid(SCHEME_UUID)).thenReturn(buffersBLM);
        setupAuthentication(CLIENT_UUID);

        // Act
        bufferService.deleteAllBuffersFromConnectionScheme(SCHEME_UUID);

        // Assert
        verify(bufferRepository).findByConnectionSchemeUid(SCHEME_UUID);
        verify(bufferRepository).removeBufferFromConnectionScheme(BUFFER_UUID, SCHEME_UUID);
    }

    @Test
    @DisplayName("Delete buffer from connection scheme - Positive")
    void shouldDeleteBufferFromConnectionSchemeWhenValidRequest() {
        // Arrange
        BufferBLM bufferBLM = createValidBufferBLM();
        List<BufferBLM> buffersBLM = Collections.singletonList(bufferBLM);

        when(connectionSchemeKafkaClient.connectionSchemeExistsAndBelongsToClient(
                eq(SCHEME_UUID), eq(CLIENT_UUID))).thenReturn(true);
        when(bufferRepository.findByConnectionSchemeUid(SCHEME_UUID)).thenReturn(buffersBLM);
        setupAuthentication(CLIENT_UUID);

        // Act
        bufferService.deleteBufferFromConnectionScheme(SCHEME_UUID, BUFFER_UUID);

        // Assert
        verify(bufferRepository).findByConnectionSchemeUid(SCHEME_UUID);
        verify(bufferRepository).removeBufferFromConnectionScheme(BUFFER_UUID, SCHEME_UUID);
    }

    @Test
    @DisplayName("Buffer exists - Positive")
    void shouldReturnTrueWhenBufferExists() {
        // Arrange
        BufferBLM bufferBLM = createValidBufferBLM();

        when(bufferRepository.exists(BUFFER_UUID)).thenReturn(true);
        when(bufferRepository.findByUid(BUFFER_UUID)).thenReturn(bufferBLM);
        when(deviceKafkaClient.deviceExistsAndBelongsToClient(
                eq(bufferBLM.getDeviceUid()), eq(CLIENT_UUID))).thenReturn(true);
        setupAuthentication(CLIENT_UUID);

        // Act
        boolean result = bufferService.bufferExists(BUFFER_UUID);

        // Assert
        assertThat(result).isTrue();
        verify(bufferRepository).exists(BUFFER_UUID);
        verify(deviceKafkaClient).deviceExistsAndBelongsToClient(bufferBLM.getDeviceUid(), CLIENT_UUID);
    }

    @Test
    @DisplayName("Buffer exists - Negative: Buffer not found")
    void shouldReturnFalseWhenBufferNotExists() {
        // Arrange
        when(bufferRepository.exists(BUFFER_UUID)).thenReturn(false);
        setupAuthentication(CLIENT_UUID);

        // Act
        boolean result = bufferService.bufferExists(BUFFER_UUID);

        // Assert
        assertThat(result).isFalse();
        verify(bufferRepository).exists(BUFFER_UUID);
    }

    @Test
    @DisplayName("Buffer exists - Negative: Device doesn't belong to client")
    void shouldReturnFalseWhenDeviceNotBelongsToClient() {
        // Arrange
        BufferBLM bufferBLM = createValidBufferBLM();

        when(bufferRepository.exists(BUFFER_UUID)).thenReturn(true);
        when(bufferRepository.findByUid(BUFFER_UUID)).thenReturn(bufferBLM);
        when(deviceKafkaClient.deviceExistsAndBelongsToClient(
                eq(bufferBLM.getDeviceUid()), eq(CLIENT_UUID))).thenReturn(false);
        setupAuthentication(CLIENT_UUID);

        // Act
        boolean result = bufferService.bufferExists(BUFFER_UUID);

        // Assert
        assertThat(result).isFalse();
        verify(bufferRepository).exists(BUFFER_UUID);
        verify(deviceKafkaClient).deviceExistsAndBelongsToClient(bufferBLM.getDeviceUid(), CLIENT_UUID);
    }

    @Test
    @DisplayName("Update buffer - Negative: Cannot change buffer UID")
    void shouldThrowExceptionWhenTryingToChangeBufferUid() {
        // Arrange
        BufferDTO bufferDTO = createValidBufferDTO();
        BufferBLM existingBuffer = createValidBufferBLM();
        // –°–æ–∑–¥–∞–µ–º BLM —Å –¥—Ä—É–≥–∏–º UID
        BufferBLM bufferBLM = new BufferBLM(
            UUID.randomUUID(), // –¥—Ä—É–≥–æ–π UID
            SCHEME_UUID,
            1000,
            1024,
            "message prototype"
        );

        when(bufferRepository.findByUid(BUFFER_UUID)).thenReturn(existingBuffer);
        when(deviceKafkaClient.deviceExistsAndBelongsToClient(
                eq(existingBuffer.getDeviceUid()), eq(CLIENT_UUID))).thenReturn(true);
        when(bufferConverter.toBLM(bufferDTO)).thenReturn(bufferBLM);
        setupAuthentication(CLIENT_UUID);

        // Act & Assert
        assertThatThrownBy(() -> bufferService.updateBuffer(BUFFER_UUID, bufferDTO))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessageContaining("Cannot change buffer UID");

        verify(bufferValidator).validate(bufferDTO);
        verify(bufferRepository, never()).update(any());
    }

    @Test
    @DisplayName("Get buffers by client - Negative: Device service returns error")
    void shouldReturnEmptyListWhenDeviceServiceFails() throws Exception {
        // Arrange
        GetDevicesByClientResponse devicesResponse = GetDevicesByClientResponse.error(
            "correlation-id", "Service unavailable"
        );

        when(deviceKafkaClient.getDevicesByClient(eq(CLIENT_UUID), eq("buffer-service")))
            .thenReturn(CompletableFuture.completedFuture(devicesResponse));
        setupAuthentication(CLIENT_UUID);

        // Act
        List<BufferBLM> result = bufferService.getBuffersByClient(CLIENT_UUID);

        // Assert
        assertThat(result).isEmpty();
        verify(deviceKafkaClient).getDevicesByClient(CLIENT_UUID, "buffer-service");
    }

    @Test
    @DisplayName("Get buffers by client - Negative: Device service timeout")
    void shouldThrowExceptionWhenDeviceServiceTimeout() throws Exception {
        // Arrange
        CompletableFuture<GetDevicesByClientResponse> timeoutFuture = new CompletableFuture<>();
        timeoutFuture.completeExceptionally(new java.util.concurrent.TimeoutException("Timeout"));

        when(deviceKafkaClient.getDevicesByClient(eq(CLIENT_UUID), eq("buffer-service")))
            .thenReturn(timeoutFuture);
        setupAuthentication(CLIENT_UUID);

        // Act & Assert
        assertThatThrownBy(() -> bufferService.getBuffersByClient(CLIENT_UUID))
            .isInstanceOf(RuntimeException.class)
            .hasMessageContaining("Device service error");

        verify(deviceKafkaClient).getDevicesByClient(CLIENT_UUID, "buffer-service");
    }
}