package com.service.buffer;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.connection.device.DeviceService;
import com.connection.device.model.DeviceBLM;
import com.connection.processing.buffer.exception.BufferAlreadyExistsException;
import com.connection.processing.buffer.model.BufferBLM;
import com.connection.processing.buffer.repository.BufferRepository;
import com.connection.processing.buffer.validator.BufferValidator;
import com.connection.service.auth.AuthService;
import com.service.buffer.config.SecurityUtils;
import com.service.connectionscheme.ConnectionSchemeService;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RequiredArgsConstructor
@Service("ApiBufferService")
@EnableAutoConfiguration(exclude = {
        JpaRepositoriesAutoConfiguration.class
})
@Transactional("atomicosTransactionManager")
public class ApiBufferServiceImpl implements BufferService {

    private final BufferRepository bufferRepository;
    private final BufferValidator bufferValidator;

    private final AuthService authClient;
    private final DeviceService deviceClient;
    private final ConnectionSchemeService connectionSchemeClient;

    @Override
    public BufferBLM createBuffer(BufferBLM bufferBLM) {
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        bufferValidator.validate(bufferBLM);

        if (!deviceExistsAndBelongsToClient(bufferBLM.getDeviceUid(), clientUid)) {
            throw new SecurityException("Device doesn't exist or doesn't belong to the authenticated client");
        }

        if (bufferRepository.exists(bufferBLM.getUid())) {
            throw new BufferAlreadyExistsException(
                    "Buffer with UID '" + bufferBLM.getUid() + "' already exists");
        }
        bufferRepository.add(bufferBLM);

        log.info("Buffer created: {} for device: {}", bufferBLM.getUid(), bufferBLM.getDeviceUid());
        return bufferBLM;
    }

    @Override
    public BufferBLM getBufferByUid(UUID bufferUid) {
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        BufferBLM bufferBLM = bufferRepository.findByUid(bufferUid);

        if (!deviceExistsAndBelongsToClient(bufferBLM.getDeviceUid(), clientUid)) {
            throw new SecurityException("Buffer doesn't exist or doesn't belong to the authenticated client");
        }

        return bufferBLM;
    }

    @Override
    public List<BufferBLM> getBuffersByClient(UUID clientUid) {
        UUID currentClientUid = SecurityUtils.getCurrentClientUid();
        if (!currentClientUid.equals(clientUid)) {
            throw new SecurityException("Access denied to client buffers");
        }

        try {

            List<DeviceBLM> deviceBLMs = deviceClient.getDevicesByClient(currentClientUid);
            List<BufferBLM> bufferBlms = new ArrayList<>();
            for (DeviceBLM device : deviceBLMs) {
                try {
                    List<BufferBLM> deviceBuffers = getBuffersByDevice(device.getUid());
                    bufferBlms.addAll(deviceBuffers);
                } catch (Exception e) {
                    log.error("Error getting buffers for device: {}", device.getUid(), e);
                }
            }
            return bufferBlms;

        } catch (Exception e) {
            log.error("Unexpected error getting buffers for client: {}", clientUid, e);
            throw new RuntimeException("Unexpected error", e);
        }
    }

    @Override
    public List<BufferBLM> getBuffersByDevice(UUID deviceUid) {
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        if (!deviceExistsAndBelongsToClient(deviceUid, clientUid)) {
            throw new SecurityException("Device doesn't belong to the authenticated client");
        }

        List<BufferBLM> bufferBLMs = bufferRepository.findByDeviceUid(deviceUid);
        return bufferBLMs;
    }

    @Override
    public List<BufferBLM> getBuffersByConnectionScheme(UUID connectionSchemeUid) {
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        if (!connectionSchemeExistsAndBelongsToClient(connectionSchemeUid, clientUid)) {
            throw new SecurityException("Connection scheme doesn't belong to the authenticated client");
        }

        List<BufferBLM> buffersBLM = bufferRepository.findByConnectionSchemeUid(connectionSchemeUid);
        return buffersBLM;
    }

    @Override
    public BufferBLM updateBuffer(UUID bufferUid, BufferBLM bufferBLM) {
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        bufferValidator.validate(bufferBLM);

        BufferBLM existingBuffer = bufferRepository.findByUid(bufferUid);

        if (!deviceExistsAndBelongsToClient(existingBuffer.getDeviceUid(), clientUid)) {
            throw new SecurityException("Buffer doesn't exist or doesn't belong to the authenticated client");
        }

        if (!deviceExistsAndBelongsToClient(bufferBLM.getDeviceUid(), clientUid)) {
            throw new SecurityException("New device doesn't belong to the authenticated client");
        }

        if (!bufferUid.equals(bufferBLM.getUid())) {
            throw new IllegalArgumentException("Cannot change buffer UID");
        }

        bufferRepository.update(bufferBLM);

        log.info("Buffer updated: {} for device: {}", bufferUid, bufferBLM.getDeviceUid());
        return bufferBLM;
    }

    @Override
    public void deleteBuffer(UUID bufferUid) {
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        BufferBLM existingBuffer = bufferRepository.findByUid(bufferUid);

        if (!deviceExistsAndBelongsToClient(existingBuffer.getDeviceUid(), clientUid)) {
            throw new SecurityException("Buffer doesn't exist or doesn't belong to the authenticated client");
        }

        bufferRepository.delete(bufferUid);
        log.info("Buffer deleted: {} for client: {}, device: {}", bufferUid, clientUid, existingBuffer.getDeviceUid());
    }

    @Override
    public boolean bufferExists(UUID bufferUid) {
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        if (!bufferRepository.exists(bufferUid)) {
            return false;
        }

        try {
            BufferBLM buffer = bufferRepository.findByUid(bufferUid);
            return deviceExistsAndBelongsToClient(buffer.getDeviceUid(), clientUid);
        } catch (Exception e) {
            return false;
        }
    }

    @Override
    public Map<String, Object> getHealthStatus() {
        try {
            var authHealth = authClient.getHealthStatus();

            var deviceHealth = deviceClient.getHealthStatus();

            var connectionSchemeHealth = connectionSchemeClient.getHealthStatus();

            return Map.of(
                    "status", "OK",
                    "service", "buffer-service",
                    "timestamp", System.currentTimeMillis(),
                    "auth-service", authHealth != null ? "AVAILABLE" : "UNAVAILABLE",
                    "device-service", deviceHealth != null ? "AVAILABLE" : "UNAVAILABLE",
                    "connection-scheme-service", connectionSchemeHealth != null ? "AVAILABLE" : "UNAVAILABLE",
                    "database", "CONNECTED");

        } catch (Exception e) {
            log.error("Health check error: ", e);
            return Map.of(
                    "status", "DEGRADED",
                    "service", "buffer-service",
                    "timestamp", System.currentTimeMillis(),
                    "auth-service", "UNAVAILABLE",
                    "device-service", "UNAVAILABLE",
                    "connection-scheme-service", "UNAVAILABLE",
                    "database", "CONNECTED",
                    "error", e.getMessage());
        }
    }

    @Override
    public void deleteBufferFromConnectionScheme(UUID connectionSchemeUid, UUID bufferUid) {
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        if (!connectionSchemeExistsAndBelongsToClient(connectionSchemeUid, clientUid)) {
            throw new SecurityException("Connection scheme doesn't belong to the authenticated client");
        }

        List<BufferBLM> buffers = getBuffersByConnectionScheme(connectionSchemeUid);
        for (BufferBLM b : buffers) {
            bufferRepository.removeBufferFromConnectionScheme(b.getUid(), connectionSchemeUid);
        }

        log.info("Deleted buffers for connection scheme: {}", connectionSchemeUid);
    }

    @Override
    public void deleteAllBuffersFromConnectionScheme(UUID connectionSchemeUid) {
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        if (!connectionSchemeExistsAndBelongsToClient(connectionSchemeUid, clientUid)) {
            throw new SecurityException("Connection scheme doesn't belong to the authenticated client");
        }

        List<BufferBLM> buffers = getBuffersByConnectionScheme(connectionSchemeUid);
        for (BufferBLM b : buffers) {
            bufferRepository.removeBufferFromConnectionScheme(b.getUid(), connectionSchemeUid);
        }

        log.info("Deleted buffers for connection scheme: {}", connectionSchemeUid);
    }

    protected boolean deviceExistsAndBelongsToClient(UUID deviceUuid, UUID clientUuid){
        return deviceClient.getDevice(deviceUuid).getClientUuid().equals(clientUuid);
    }
    protected boolean connectionSchemeExistsAndBelongsToClient(UUID connectionSchemeUid, UUID clientUid){
        return connectionSchemeClient.schemeExists(connectionSchemeUid) &&
            connectionSchemeClient.getSchemeByUid(connectionSchemeUid).getClientUid().equals(clientUid);
    }
}package com.service.buffer;

import java.util.List;
import java.util.Map;
import java.util.UUID;

import com.connection.processing.buffer.model.BufferBLM;

public interface BufferService {
    BufferBLM createBuffer(BufferBLM bufferBLM);
    BufferBLM getBufferByUid(UUID bufferUid);
    List<BufferBLM> getBuffersByClient(UUID clientUid);
    List<BufferBLM> getBuffersByDevice(UUID deviceUid);
    List<BufferBLM> getBuffersByConnectionScheme(UUID connectionSchemeUid);
    BufferBLM updateBuffer(UUID bufferUid, BufferBLM bufferBLM);
    void deleteBuffer(UUID bufferUid);
    void deleteBufferFromConnectionScheme(UUID connectionSchemeUid, UUID bufferUid);
    void deleteAllBuffersFromConnectionScheme(UUID connectionSchemeUid);
    boolean bufferExists(UUID bufferUid);
    Map<String, Object> getHealthStatus();
}package com.service.buffer.config;

import io.swagger.v3.oas.annotations.enums.SecuritySchemeType;
import io.swagger.v3.oas.annotations.security.SecurityScheme;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@SecurityScheme(
    name = "bearerAuth",
    type = SecuritySchemeType.HTTP,
    bearerFormat = "JWT",
    scheme = "bearer"
)
public class SwaggerConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("Buffer Service API")
                        .version("1.0")
                        .description("API для управления буферами"))
                .addSecurityItem(new SecurityRequirement().addList("bearerAuth"))
                .components(new Components()
                        .addSecuritySchemes("bearerAuth", 
                            new io.swagger.v3.oas.models.security.SecurityScheme()
                                .type(io.swagger.v3.oas.models.security.SecurityScheme.Type.HTTP)
                                .scheme("bearer")
                                .bearerFormat("JWT")));
    }
}package com.service.buffer.config;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

import java.util.UUID;

@Component
public class SecurityUtils {

    public static UUID getCurrentClientUid() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        
        if (authentication == null || !authentication.isAuthenticated()) {
            throw new SecurityException("User not authenticated");
        }

        Object principal = authentication.getPrincipal();
        
        if (principal instanceof UUID) {
            return (UUID) principal;
        } else if (principal instanceof String) {
            try {
                return UUID.fromString((String) principal);
            } catch (IllegalArgumentException e) {
                throw new SecurityException("Invalid client UID format in principal");
            }
        } else {
            throw new SecurityException("Unexpected principal type: " + principal.getClass());
        }
    }

    public static String getCurrentClientUidAsString() {
        return getCurrentClientUid().toString();
    }
}// BufferJDBCConfig.java
package com.service.buffer.config;

import java.util.Properties;
import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.atomikos.jdbc.AtomikosDataSourceBean;

import lombok.extern.slf4j.Slf4j;

@Configuration
@Slf4j
public class BufferJDBCConfig {
    
    @Value("${app.datasource.buffer.xa-data-source-class-name:org.postgresql.xa.PGXADataSource}")
    private String xaDataSourceClassName;

    @Value("${app.datasource.buffer.xa-properties.url}")
    private String jdbcUrl;

    @Value("${app.datasource.buffer.xa-properties.user}")
    private String username;

    @Value("${app.datasource.buffer.xa-properties.password}")
    private String password;

    @Value("${app.datasource.buffer.unique-resource-name:bufferXADataSource}")
    private String uniqueResourceName;

    @Bean("BufferDataSource")
    DataSource bufferDataSource() {
        log.info("url: " + jdbcUrl);
        log.info("user: " + username);
        log.info("password: " + password);

        AtomikosDataSourceBean dataSource = new AtomikosDataSourceBean();
        dataSource.setUniqueResourceName(uniqueResourceName);
        dataSource.setXaDataSourceClassName(xaDataSourceClassName);
        
        Properties xaProperties = new Properties();
        xaProperties.setProperty("url", jdbcUrl);
        xaProperties.setProperty("user", username);
        xaProperties.setProperty("password", password);

        dataSource.setXaProperties(xaProperties);
        dataSource.setPoolSize(5);
        dataSource.setTestQuery("SELECT 1");

        return dataSource;
    }

    @Bean("BufferJdbcTemplate")
    NamedParameterJdbcTemplate bufferNamedParameterJdbcTemplate(
            @Qualifier("BufferDataSource") DataSource bufferDataSource) {
        return new NamedParameterJdbcTemplate(bufferDataSource);
    }
}// // BufferKafkaConfig.java
// package com.service.buffer.config;

// import java.util.HashMap;
// import java.util.Map;

// import org.apache.kafka.clients.consumer.ConsumerConfig;
// import org.apache.kafka.clients.producer.ProducerConfig;
// import org.springframework.beans.factory.annotation.Value;
// import org.springframework.context.annotation.Bean;
// import org.springframework.context.annotation.Configuration;
// import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
// import org.springframework.kafka.core.ConsumerFactory;
// import org.springframework.kafka.core.DefaultKafkaConsumerFactory;
// import org.springframework.kafka.core.DefaultKafkaProducerFactory;
// import org.springframework.kafka.core.KafkaTemplate;
// import org.springframework.kafka.core.ProducerFactory;
// import org.springframework.kafka.listener.DefaultErrorHandler;
// import org.springframework.kafka.support.serializer.ErrorHandlingDeserializer;
// import org.springframework.kafka.support.serializer.JsonDeserializer;
// import org.springframework.kafka.support.serializer.JsonSerializer;
// import org.springframework.util.backoff.FixedBackOff;

// @Configuration
// public class BufferKafkaConfig {
//     @Value("${spring.kafka.bootstrap-servers:localhost:29092}")
//     private String bootstrapServers;

//     // Конфигурация для Consumer с обработкой ошибок десериализации
//     @Bean
//     public ConsumerFactory<String, Object> consumerFactory() {
//         Map<String, Object> configProps = new HashMap<>();
//         configProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
//         configProps.put(ConsumerConfig.GROUP_ID_CONFIG, "buffer-service-group");
//         configProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");
//         configProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer.class);
//         configProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer.class);
//         // Конфигурация для JsonDeserializer
//         configProps.put(JsonDeserializer.TRUSTED_PACKAGES,
//                 "com.connection.auth.events.commands," +
//                         "com.connection.auth.events.responses," +
//                         "com.connection.common.events," +
//                         "com.connection.buffer.events.commands," +
//                         "com.connection.buffer.events.responses," +
//                         "com.connection.device.events.commands," +
//                         "com.connection.device.events.responses," +
//                         "com.connection.scheme.events.commands," +
//                         "com.connection.scheme.events.responses");
//         // Конфигурация для ErrorHandlingDeserializer
//         configProps.put(ErrorHandlingDeserializer.KEY_DESERIALIZER_CLASS,
//                 org.apache.kafka.common.serialization.StringDeserializer.class);
//         configProps.put(ErrorHandlingDeserializer.VALUE_DESERIALIZER_CLASS, JsonDeserializer.class);


//         configProps.put(JsonDeserializer.USE_TYPE_INFO_HEADERS, true);
//         configProps.put(JsonDeserializer.REMOVE_TYPE_INFO_HEADERS, false);
//         configProps.put(JsonDeserializer.VALUE_DEFAULT_TYPE, "com.connection.common.events.Command");

//         return new DefaultKafkaConsumerFactory<>(configProps);
//     }

//     @Bean
//     public ConcurrentKafkaListenerContainerFactory<String, Object> kafkaListenerContainerFactory() {
//         ConcurrentKafkaListenerContainerFactory<String, Object> factory = new ConcurrentKafkaListenerContainerFactory<>();
//         factory.setConsumerFactory(consumerFactory());

//         // Обработка ошибок десериализации - пропускаем некорректные сообщения
//         DefaultErrorHandler errorHandler = new DefaultErrorHandler(
//                 (record, exception) -> {
//                     org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger("KafkaErrorHandler");
//                     logger.error(
//                             "Skipping invalid message - Topic: {}, Partition: {}, Offset: {}, Key: {}, Error: {}, {}",
//                             record.topic(),
//                             record.partition(),
//                             record.offset(),
//                             record.key(),
//                             exception.getMessage(),
//                             exception.toString());
//                 },
//                 new FixedBackOff(0L, 0L));

//         factory.setCommonErrorHandler(errorHandler);

//         return factory;
//     }

//     // Конфигурация для Producer
//     @Bean
//     public ProducerFactory<String, Object> producerFactory() {
//         Map<String, Object> configProps = new HashMap<>();
//         configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
//         configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,
//                 org.apache.kafka.common.serialization.StringSerializer.class);
//         configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
//         configProps.put(JsonSerializer.ADD_TYPE_INFO_HEADERS, true);
//         return new DefaultKafkaProducerFactory<>(configProps);
//     }

//     @Bean
//     public KafkaTemplate<String, Object> kafkaTemplate() {
//         return new KafkaTemplate<>(producerFactory());
//     }
// }package com.service.buffer.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.connection.device.converter.DeviceConverter;

@Configuration
public class DeviceUtilsConfig {
    @Bean
    DeviceConverter deviceConverter(){
        return new DeviceConverter();
    }
}
// TransactionConfig.java
package com.service.buffer.config;

import java.util.UUID;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.jta.JtaTransactionManager;

import com.atomikos.icatch.jta.UserTransactionManager;

import jakarta.transaction.SystemException;

@Configuration
public class TransactionConfig {

    @Bean
    public UserTransactionManager userTransactionManager() throws SystemException{
        UserTransactionManager manager = new UserTransactionManager();
        setPropertyIfNotExists("com.atomikos.icatch.log_base_name", "atomikos-tm-" + UUID.randomUUID().toString().substring(0, 8));
        setPropertyIfNotExists("com.atomikos.icatch.log_base_dir", "./logs");
        setPropertyIfNotExists("com.atomikos.icatch.tm_unique_name", "tm-" + UUID.randomUUID().toString().substring(0, 8));

        manager.setTransactionTimeout(300);
        manager.setForceShutdown(true);
        return manager;
    }

    @Bean(name = "atomicosTransactionManager")
    public JtaTransactionManager jtaTransactionManager() throws SystemException {
        JtaTransactionManager jtaTransactionManager = new JtaTransactionManager();
        jtaTransactionManager.setTransactionManager(userTransactionManager());
        jtaTransactionManager.setUserTransaction(userTransactionManager());
        return jtaTransactionManager;
    }
    /**
     * Устанавливает системное свойство только если оно еще не было установлено
     * @param key ключ свойства
     * @param value значение свойства
     */
    private void setPropertyIfNotExists(String key, String value) {
        if (System.getProperty(key) == null) {
            System.setProperty(key, value);
            System.out.println("Set property: " + key + " = " + value);
        } else {
            System.out.println("Property already set: " + key + " = " + System.getProperty(key));
        }
    }
}// BufferRepositoryConfig.java
package com.service.buffer.config;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.connection.processing.buffer.repository.BufferRepository;
import com.connection.processing.buffer.repository.BufferRepositorySQLImpl;

@Configuration
public class BufferRepositoryConfig {
    @Bean("BufferRepository")
    BufferRepository bufferRepository(@Qualifier("BufferJdbcTemplate") NamedParameterJdbcTemplate template){
        return new BufferRepositorySQLImpl(template);
    }
}// SecurityConfig.java
package com.service.buffer.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import com.service.buffer.client.AuthenticationFilter;

import lombok.RequiredArgsConstructor;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
@RequiredArgsConstructor
public class SecurityConfig {

    private final AuthenticationFilter jwtKafkaAuthenticationFilter;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                .csrf(csrf -> csrf.disable()) // Отключаем CSRF для API
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/swagger-ui.html").permitAll()
                        .requestMatchers("/swagger-ui/**").permitAll()
                        .requestMatchers("/api-docs/**").permitAll()
                        .requestMatchers("/webjars/**").permitAll()
                        .requestMatchers("/v3/api-docs/**").permitAll()
                        .requestMatchers("/api/v1/health").permitAll()
                        .requestMatchers("/api/v1/**").authenticated()
                        .anyRequest().denyAll()
                )
                .addFilterBefore(jwtKafkaAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)
                .build();
    }
}// BufferUtilsConfig.java
package com.service.buffer.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.connection.processing.buffer.converter.BufferConverter;
import com.connection.processing.buffer.validator.BufferValidator;

@Configuration
public class BufferUtilsConfig {
    @Bean("BufferConverter")
    BufferConverter bufferConverter(){
        return new BufferConverter();
    }

    @Bean("BufferValidator")
    BufferValidator bufferValidator(){
        return new BufferValidator();
    }
}// BuffersListResponse.java
package com.service.buffer.controller;

import com.connection.processing.buffer.model.BufferDTO;

import lombok.AllArgsConstructor;
import lombok.Getter;

import java.util.List;

@AllArgsConstructor
@Getter
public class BuffersListResponse {
    private final List<BufferDTO> buffers;
    private final PaginationInfo pagination;

    @AllArgsConstructor
    @Getter
    public static class PaginationInfo {
        private final int offset;
        private final int limit;
        private final int totalCount;
        private final boolean hasMore;
    }

    // Конструктор для обратной совместимости
    public BuffersListResponse(List<BufferDTO> buffers) {
        this.buffers = buffers;
        this.pagination = null;
    }
}// GlobalExceptionHandler.java
package com.service.buffer.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import com.connection.processing.buffer.exception.BufferNotFoundException;
import com.connection.processing.buffer.exception.BufferValidateException;

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(SecurityException.class)
    public ResponseEntity<?> handleSecurityException(SecurityException e) {
        log.warn("Security exception: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(new ErrorResponse(
                "invalid_authorization",
                "Invalid or missing authorization header"));
    }

    @ExceptionHandler(BufferNotFoundException.class)
    public ResponseEntity<?> handleBufferNotFoundException(
            BufferNotFoundException e) {
        log.warn("Buffer not found: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ErrorResponse(
                "buffer_not_found",
                "Buffer not found"));
    }

    @ExceptionHandler(BufferValidateException.class)
    public ResponseEntity<?> handleBufferValidationException(
            BufferValidateException e) {
        log.warn("Buffer validation failed: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(new ErrorResponse(
                "validation_failed",
                e.getMessage() != null ? e.getMessage() : "Invalid buffer data"));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<?> handleGenericException(Exception e) {
        log.error("Unexpected error occurred: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(new ErrorResponse(
                "internal_server_error",
                "An unexpected error occurred"));
    }
}// ErrorResponse.java
package com.service.buffer.controller;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class ErrorResponse {
    private final String error;
    private final String message;
}// HealthResponse.java
package com.service.buffer.controller;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class HealthResponse {
    private final String messaege;
}// BufferResponse.java
package com.service.buffer.controller;

import java.util.UUID;


import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class BufferResponse {
    private final UUID bufferUuid;
}package com.service.buffer.controller;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.connection.processing.buffer.converter.BufferConverter;
import com.connection.processing.buffer.model.BufferBLM;
import com.connection.processing.buffer.model.BufferDTO;
import com.connection.processing.buffer.validator.BufferValidator;
import com.service.buffer.BufferService;
import com.service.buffer.config.SecurityUtils;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/v1")
public class BufferController {

    @Qualifier("ApiBufferService")
    private final BufferService bufferService;
    private final BufferValidator bufferValidator;
    private final BufferConverter bufferConverter;

    // Константы для пагинации по умолчанию
    private static final int DEFAULT_OFFSET = 0;
    private static final int DEFAULT_LIMIT = 50;
    private static final int MAX_LIMIT = 1000;

    @PostMapping("/buffers")
    public ResponseEntity<BufferResponse> createBuffer(@RequestBody BufferDTO bufferDTO) {
        bufferValidator.validate(bufferDTO);
        BufferBLM bufferBLM = bufferConverter.toBLM(bufferDTO);
        BufferBLM buffer = bufferService.createBuffer(bufferBLM);

        return ResponseEntity.ok(new BufferResponse(buffer.getUid()));
    }

    @GetMapping("/buffers")
    public ResponseEntity<BuffersListResponse> getBuffers(
            @RequestParam(required = false) List<UUID> bufferUids,
            @RequestParam(required = false) UUID deviceUid,
            @RequestParam(required = false) UUID connectionSchemeUid,
            @RequestParam(defaultValue = "" + DEFAULT_OFFSET) int offset,
            @RequestParam(defaultValue = "" + DEFAULT_LIMIT) int limit) {
        
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        List<BufferBLM> buffers;

        if (deviceUid != null) {
            log.info("Getting buffers for device: {} with offset: {}, limit: {}", deviceUid, offset, limit);
            buffers = bufferService.getBuffersByDevice(deviceUid);
        } else if (connectionSchemeUid != null) {
            log.info("Getting buffers for connection scheme: {} with offset: {}, limit: {}", 
                    connectionSchemeUid, offset, limit);
            buffers = bufferService.getBuffersByConnectionScheme(connectionSchemeUid);
        } else {
            log.info("Getting all buffers for client with offset: {}, limit: {}", offset, limit);
            buffers = bufferService.getBuffersByClient(clientUid);
        }
        BuffersListResponse.PaginationInfo paginationInfo = 
            new BuffersListResponse.PaginationInfo(
                offset, 
                limit, 
                buffers.size(), 
                (offset + limit) < buffers.size()
            );
        // Применяем пагинацию
        List<BufferDTO> bufferDTOs = applyPagination(buffers, offset, limit)
                .stream()
                .map(bufferConverter::toDTO)
                .collect(Collectors.toList());

        return ResponseEntity.ok(new BuffersListResponse(bufferDTOs, paginationInfo));
    }
    @PatchMapping("/buffers/{bufferUid}")
    public ResponseEntity<BufferResponse> partialUpdateBuffer(
            @PathVariable UUID bufferUid,
            @RequestBody PartialBufferUpdateRequest updateRequest) {
        
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        log.info("Partial update buffer: {} for client: {}", bufferUid, clientUid);
        
        // Временная реализация - получаем текущий буфер и возвращаем его
        BufferBLM buffer = bufferService.getBufferByUid(bufferUid);
        buffer.setMaxMessageSize(updateRequest.maxSize);
        buffer.setMaxMessagesNumber(updateRequest.maxMessages);
        
        bufferValidator.validate(buffer);

        bufferService.updateBuffer(bufferUid, buffer);
        
        return ResponseEntity.ok(new BufferResponse(buffer.getUid()));
    }


    @PutMapping("/buffers/{bufferUid}")
    public ResponseEntity<BufferResponse> updateBuffer(
            @PathVariable UUID bufferUid,
            @RequestBody BufferDTO bufferDTO) {

        UUID clientUid = SecurityUtils.getCurrentClientUid();
        log.info("Updating buffer: {} for client: {}", bufferUid, clientUid);

        bufferValidator.validate(bufferDTO);

        BufferBLM bufferBLM = bufferConverter.toBLM(bufferDTO);

        BufferBLM buffer = bufferService.updateBuffer(bufferUid, bufferBLM);

        return ResponseEntity.ok(new BufferResponse(buffer.getUid()));
    }

    @DeleteMapping("/buffers")
    public ResponseEntity<Void> deleteBuffers(
            @RequestParam List<UUID> bufferUids) {
        
        for (UUID b : bufferUids){
            bufferService.deleteBuffer(b);
        }
        return ResponseEntity.noContent().build();
    }


    @GetMapping("/health")
    public ResponseEntity<HealthResponse> healthCheck() {
        log.info("Health check: status: OK, service: buffer-service, timestamp: {}",
                System.currentTimeMillis());

        return ResponseEntity.ok().body(new HealthResponse(bufferService.getHealthStatus().toString()));
    }

    /**
     * Применяет пагинацию к списку буферов
     * 
     * @param buffers полный список буферов
     * @param offset смещение (начальная позиция)
     * @param limit максимальное количество элементов
     * @return пагинированный список буферов
     */
    private List<BufferBLM> applyPagination(List<BufferBLM> buffers, int offset, int limit) {
        // Валидация параметров пагинации
        if (offset < 0) {
            offset = DEFAULT_OFFSET;
        }
        
        if (limit <= 0 || limit > MAX_LIMIT) {
            limit = DEFAULT_LIMIT;
        }
        
        // Применяем пагинацию
        return buffers.stream()
                .skip(offset)
                .limit(limit)
                .collect(Collectors.toList());
    }
        public static class PartialBufferUpdateRequest {
        private Integer maxMessages;
        private Integer maxSize;

        // Getters and Setters
        public Integer getMaxMessages() {
            return maxMessages;
        }

        public void setMaxMessages(Integer maxMessages) {
            this.maxMessages = maxMessages;
        }

        public Integer getMaxSize() {
            return maxSize;
        }

        public void setMaxSize(Integer maxSize) {
            this.maxSize = maxSize;
        }

    }
}// CreateBufferRequest.java
package com.service.buffer.controller;

import java.util.UUID;

import com.connection.processing.buffer.model.BufferDTO;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
@Getter
@Setter
public class CreateBufferRequest {
    private BufferDTO bufferDTO;
    private UUID connectionSchemeUid;
}// UpdateBufferRequest.java
package com.service.buffer.controller;

import java.util.UUID;

import com.connection.processing.buffer.model.BufferDTO;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
@Getter
@Setter
public class UpdateBufferRequest {
    private BufferDTO bufferDTO;
    private UUID connectionSchemeUid;
}// BufferServiceApplication.java
package com.service.buffer;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BufferServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(BufferServiceApplication.class, args);
    }
}// // BufferCommandConsumer.java
// package com.service.buffer.kafka;

// import org.apache.kafka.clients.consumer.ConsumerRecord;
// import org.springframework.beans.factory.annotation.Qualifier;
// import org.springframework.kafka.annotation.KafkaListener;
// import org.springframework.kafka.core.KafkaTemplate;
// import org.springframework.stereotype.Component;

// import com.connection.buffer.events.commands.GetBufferByUidCommand;
// import com.connection.buffer.events.commands.GetBuffersByClientUidCommand;
// import com.connection.buffer.events.commands.GetBuffersByConnectionSchemeUidCommand;
// import com.connection.buffer.events.commands.GetBuffersByDeviceUidCommand;
// import com.connection.buffer.events.commands.HealthCheckCommand;
// import com.connection.buffer.events.responses.GetBufferByUidResponse;
// import com.connection.buffer.events.responses.GetBuffersByClientResponse;
// import com.connection.buffer.events.responses.GetBuffersByConnectionSchemeResponse;
// import com.connection.buffer.events.responses.GetBuffersByDeviceResponse;
// import com.connection.buffer.events.responses.HealthCheckResponse;
// import com.connection.common.events.Command;
// import com.service.buffer.BufferService;
// import com.connection.processing.buffer.converter.BufferConverter;
// import com.connection.processing.buffer.model.BufferBLM;
// import com.connection.processing.buffer.model.BufferDTO;

// import lombok.RequiredArgsConstructor;
// import lombok.extern.slf4j.Slf4j;

// import java.util.List;
// import java.util.stream.Collectors;

// @Slf4j
// @Component
// @RequiredArgsConstructor
// public class BufferCommandConsumer {

//     @Qualifier("KafkaBufferService")
//     private final BufferService bufferService;
//     private final BufferConverter bufferConverter;
//     private final KafkaTemplate<String, Object> kafkaTemplate;

//     @KafkaListener(topics = "${app.kafka.topics.buffer-commands:buffer.commands}")
//     public void handleBufferCommand(ConsumerRecord<String, Command> record) {
//         try {
//             Command command = record.value();
//             String key = record.key();

//             log.info("Received buffer command: {} with key: {}", command.getClass().getSimpleName(), key);

//             if (command instanceof GetBufferByUidCommand) {
//                 GetBufferByUidCommand getBufferCommand = (GetBufferByUidCommand) command;
//                 handleGetBufferByUidCommand(getBufferCommand, key);
//             } else if (command instanceof GetBuffersByClientUidCommand) {
//                 GetBuffersByClientUidCommand getBuffersCommand = (GetBuffersByClientUidCommand) command;
//                 handleGetBuffersByClientCommand(getBuffersCommand, key);
//             } else if (command instanceof GetBuffersByDeviceUidCommand) {
//                 GetBuffersByDeviceUidCommand getBuffersCommand = (GetBuffersByDeviceUidCommand) command;
//                 handleGetBuffersByDeviceCommand(getBuffersCommand, key);
//             } else if (command instanceof GetBuffersByConnectionSchemeUidCommand) {
//                 GetBuffersByConnectionSchemeUidCommand getBuffersCommand = (GetBuffersByConnectionSchemeUidCommand) command;
//                 handleGetBuffersByConnectionSchemeCommand(getBuffersCommand, key);
//             } else if (command instanceof HealthCheckCommand) {
//                 HealthCheckCommand healthCommand = (HealthCheckCommand) command;
//                 handleHealthCheckCommand(healthCommand, key);
//             } else {
//                 log.warn("Unknown buffer command type: {}", command.getClass().getCanonicalName());
//             }

//         } catch (Exception e) {
//             log.error("Error processing buffer command: key={}", record.key(), e);
//         }
//     }

//     private void handleGetBufferByUidCommand(GetBufferByUidCommand command, String key) {
//         try {
//             log.info("Processing GetBufferByUidCommand for buffer UID: {}", command.getBufferUid());

//             BufferBLM bufferBLM = bufferService.getBufferByUid(command.getBufferUid());
//             BufferDTO bufferDTO = bufferConverter.toDTO(bufferBLM);

//             GetBufferByUidResponse response = GetBufferByUidResponse.success(
//                     command.getCorrelationId(),
//                     bufferDTO);

//             kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
//             log.info("GetBufferByUid response sent to {}: correlationId={}",
//                     command.getReplyTopic(), command.getCorrelationId());

//         } catch (Exception e) {
//             log.error("Error processing GetBufferByUidCommand for buffer UID: {}", command.getBufferUid(), e);

//             GetBufferByUidResponse response = GetBufferByUidResponse.error(
//                     command.getCorrelationId(),
//                     e.getMessage());

//             kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
//         }
//     }

//     private void handleGetBuffersByClientCommand(GetBuffersByClientUidCommand command, String key) {
//         try {
//             log.info("Processing GetBuffersByClientCommand for client UID: {}", command.getClientUid());

//             List<BufferBLM> buffersBLM = bufferService.getBuffersByClient(command.getClientUid());
//             List<BufferDTO> bufferDTOs = buffersBLM.stream()
//                     .map(bufferConverter::toDTO)
//                     .collect(Collectors.toList());

//             GetBuffersByClientResponse response = GetBuffersByClientResponse.success(
//                     command.getCorrelationId(),
//                     bufferDTOs);

//             kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);

//             log.info("GetBufferByClient response sent to {}: correlationId={}",
//                     command.getReplyTopic(), command.getCorrelationId());

//         } catch (Exception e) {
//             log.error("Error processing GetBuffersByClientCommand for client UID: {}", command.getClientUid(), e);

//             GetBuffersByClientResponse response = GetBuffersByClientResponse.error(
//                     command.getCorrelationId(),
//                     e.getMessage());

//             kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
//         }
//     }

//     private void handleGetBuffersByDeviceCommand(GetBuffersByDeviceUidCommand command, String key) {
//         try {
//             log.info("Processing GetBuffersByDeviceCommand for device UID: {}", command.getDeviceUid());

//             List<BufferBLM> buffersBLM = bufferService.getBuffersByDevice(command.getDeviceUid());
//             List<BufferDTO> bufferDTOs = buffersBLM.stream()
//                     .map(bufferConverter::toDTO)
//                     .collect(Collectors.toList());

//             GetBuffersByDeviceResponse response = GetBuffersByDeviceResponse.success(
//                     command.getCorrelationId(),
//                     bufferDTOs);

//             kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);

//             log.info("GetBufferByDevice response sent to {}: correlationId={}",
//                     command.getReplyTopic(), command.getCorrelationId());

//         } catch (Exception e) {
//             log.error("Error processing GetBuffersByDeviceCommand for device UID: {}", command.getDeviceUid(), e);

//             GetBuffersByDeviceResponse response = GetBuffersByDeviceResponse.error(
//                     command.getCorrelationId(),
//                     e.getMessage());

//             kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
//         }
//     }

//     private void handleGetBuffersByConnectionSchemeCommand(GetBuffersByConnectionSchemeUidCommand command, String key) {
//         try {
//             log.info("Processing GetBuffersByConnectionSchemeCommand for connection scheme UID: {}",
//                     command.getConnectionSchemeUid());

//             List<BufferBLM> buffersBLM = bufferService.getBuffersByConnectionScheme(command.getConnectionSchemeUid());
//             List<BufferDTO> bufferDTOs = buffersBLM.stream()
//                     .map(bufferConverter::toDTO)
//                     .collect(Collectors.toList());

//             GetBuffersByConnectionSchemeResponse response = GetBuffersByConnectionSchemeResponse.success(
//                     command.getCorrelationId(),
//                     bufferDTOs);

//             kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);

//             log.info("GetBufferByConnectionScheme response sent to {}: correlationId={}",
//                     command.getReplyTopic(), command.getCorrelationId());

//         } catch (Exception e) {
//             log.error("Error processing GetBuffersByConnectionSchemeCommand for connection scheme UID: {}",
//                     command.getConnectionSchemeUid(), e);

//             GetBuffersByConnectionSchemeResponse response = GetBuffersByConnectionSchemeResponse.error(
//                     command.getCorrelationId(),
//                     e.getMessage());

//             kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
//         }
//     }

//     private void handleHealthCheckCommand(HealthCheckCommand command, String key) {
//         try {
//             log.info("Processing HealthCheckCommand");

//             var healthStatus = bufferService.getHealthStatus();

//             HealthCheckResponse response = HealthCheckResponse.success(
//                     command.getCorrelationId(),
//                     healthStatus);

//             kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);

//             log.info("HealthCheck response sent to {}: correlationId={}",
//                     command.getReplyTopic(), command.getCorrelationId());

//         } catch (Exception e) {
//             log.error("Error processing HealthCheckCommand", e);

//             HealthCheckResponse response = HealthCheckResponse.error(
//                     command.getCorrelationId(),
//                     e.getMessage());

//             kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
//         }
//     }
// }// package com.service.buffer.kafka;

// import org.apache.kafka.clients.consumer.ConsumerRecord;
// import org.springframework.beans.factory.annotation.Autowired;
// import org.springframework.boot.context.event.ApplicationReadyEvent;
// import org.springframework.context.ApplicationListener;
// import org.springframework.kafka.annotation.KafkaListener;
// import org.springframework.kafka.config.KafkaListenerEndpointRegistry;
// import org.springframework.kafka.listener.MessageListenerContainer;
// import org.springframework.stereotype.Component;

// import com.connection.common.events.CommandResponse;
// import com.connection.scheme.events.responses.GetConnectionSchemeByUidResponse;
// import com.connection.scheme.events.responses.HealthCheckResponse;

// import lombok.RequiredArgsConstructor;
// import lombok.extern.slf4j.Slf4j;

// @Slf4j
// @Component
// @RequiredArgsConstructor
// public class ConnectionSchemeResponseConsumer implements ApplicationListener<ApplicationReadyEvent> {

//     @Autowired
//     private TypedConnectionSchemeKafkaClient connectionSchemeKafkaClient;
//     @Autowired
//     private KafkaListenerEndpointRegistry registry;

//     @KafkaListener(id = "dynamicConnectionSchemeListener", 
//                    topics = "#{@typedConnectionSchemeKafkaClient.getInstanceReplyTopic()}")
//     public void handleConnectionSchemeResponse(ConsumerRecord<String, CommandResponse> record) {
//         try {
//             CommandResponse message = record.value();
//             String correlationId = record.key();
            
//             log.info("Received connection scheme response from instance topic: correlationId={}, topic={}", 
//                     correlationId, record.topic());
                
//             if (message instanceof GetConnectionSchemeByUidResponse) {
//                 GetConnectionSchemeByUidResponse typedResponse = (GetConnectionSchemeByUidResponse) message;
//                 connectionSchemeKafkaClient.handleResponse(correlationId, typedResponse);
//             } else if (message instanceof HealthCheckResponse) {
//                 HealthCheckResponse typedResponse = (HealthCheckResponse) message;
//                 connectionSchemeKafkaClient.handleResponse(correlationId, typedResponse);
//             } else {
//                 log.warn("Unknown connection scheme response type for correlationId: {}", correlationId);
//             }
            
//         } catch (Exception e) {
//             log.error("Error processing connection scheme response: correlationId={}", record.key(), e);
//         }
//     }

//     @Override
//     public void onApplicationEvent(ApplicationReadyEvent event) {
//         try {
//             MessageListenerContainer container = registry.getListenerContainer("dynamicConnectionSchemeListener");
//             if (container != null && !container.isRunning()) {
//                 container.start();
//                 log.info("Dynamic connection scheme response listener started for topic: {}", 
//                         connectionSchemeKafkaClient.getInstanceReplyTopic());
//             }
//         } catch (Exception e) {
//             log.error("Failed to start dynamic connection scheme listener", e);
//         }
//     }
// }// package com.service.buffer.kafka;

// import org.apache.kafka.clients.consumer.ConsumerRecord;
// import org.springframework.beans.factory.annotation.Autowired;
// import org.springframework.boot.context.event.ApplicationReadyEvent;
// import org.springframework.context.ApplicationListener;
// import org.springframework.kafka.annotation.KafkaListener;
// import org.springframework.kafka.config.KafkaListenerEndpointRegistry;
// import org.springframework.kafka.listener.MessageListenerContainer;
// import org.springframework.stereotype.Component;

// import com.connection.auth.events.responses.TokenValidationResponse;
// import com.connection.common.events.CommandResponse;
// import com.connection.auth.events.responses.HealthCheckResponse;

// import lombok.extern.slf4j.Slf4j;

// @Slf4j
// @Component
// public class AuthResponseConsumer implements ApplicationListener<ApplicationReadyEvent> {
//     @Autowired
//     private TypedAuthKafkaClient authKafkaClient;
//     @Autowired
//     private KafkaListenerEndpointRegistry registry;

//     @KafkaListener(id = "dynamicAuthListener", topics = "#{@typedAuthKafkaClient.getInstanceReplyTopic()}")
//     public void handleAuthResponse(ConsumerRecord<String, CommandResponse> record) {
//         try {
//             CommandResponse message = record.value();
//             String correlationId = record.key();
            
//             log.info("Received auth response from instance topic: correlationId={}, topic={}", 
//                     correlationId, record.topic());
                
//             if (message instanceof TokenValidationResponse) {
//                 TokenValidationResponse typedResponse = (TokenValidationResponse) message;
//                 authKafkaClient.handleResponse(correlationId, typedResponse);
//             } else if (message instanceof HealthCheckResponse) {
//                 HealthCheckResponse typedResponse = (HealthCheckResponse) message;
//                 authKafkaClient.handleResponse(correlationId, typedResponse);
//             } else {
//                 log.warn("Unknown response type for correlationId: {}", correlationId);
//             }
            
//         } catch (Exception e) {
//             log.error("Error processing auth response: correlationId={}", record.key(), e);
//         }
//     }

//     @Override
//     public void onApplicationEvent(ApplicationReadyEvent event) {
//         try {
//             MessageListenerContainer container = registry.getListenerContainer("dynamicAuthListener");
//             if (container != null && !container.isRunning()) {
//                 container.start();
//                 log.info("Dynamic auth response listener started for topic: {}", 
//                         authKafkaClient.getInstanceReplyTopic());
//             }
//         } catch (Exception e) {
//             log.error("Failed to start dynamic auth listener", e);
//         }
//     }
// }// package com.service.buffer.kafka;

// import java.util.Date;
// import java.util.Map;
// import java.util.UUID;
// import java.util.concurrent.CompletableFuture;
// import java.util.concurrent.ConcurrentHashMap;
// import java.util.concurrent.TimeUnit;

// import org.springframework.beans.factory.annotation.Autowired;
// import org.springframework.beans.factory.annotation.Value;
// import org.springframework.kafka.core.KafkaTemplate;
// import org.springframework.stereotype.Component;

// import com.connection.auth.events.AuthEventConstants;
// import com.connection.auth.events.AuthEventUtils;
// import com.connection.auth.events.commands.ExtractClientUidCommand;
// import com.connection.auth.events.commands.HealthCheckCommand;
// import com.connection.auth.events.commands.ValidateTokenCommand;
// import com.connection.auth.events.responses.HealthCheckResponse;
// import com.connection.auth.events.responses.TokenValidationResponse;

// import lombok.RequiredArgsConstructor;
// import lombok.extern.slf4j.Slf4j;

// @Slf4j
// @Component
// @RequiredArgsConstructor
// public class TypedAuthKafkaClient {

//     @Autowired
//     private KafkaTemplate<String, Object> kafkaTemplate;

//     @Value("${app.kafka.topics.auth-commands:auth.commands}")
//     private String authCommandsTopic;

    
//     private final Map<String, PendingRequest<?>> pendingRequests = new ConcurrentHashMap<>();
    
//     // 👇 Уникальный топик для этого инстанса
//     private final String instanceReplyTopic = "auth.responses." + UUID.randomUUID().toString();

//     private static class PendingRequest<T> {
//         final CompletableFuture<T> future;
//         final Class<T> responseType;

//         PendingRequest(CompletableFuture<T> future, Class<T> responseType) {
//             this.future = future;
//             this.responseType = responseType;
//         }
//     }

//     public CompletableFuture<TokenValidationResponse> validateToken(String token, String sourceService) {
//         return sendRequest(
//             ValidateTokenCommand.builder()
//                 .token(token)
//                 .tokenType(ValidateTokenCommand.TokenType.ACCESS)
//                 .sourceService(sourceService)
//                 .replyTopic(instanceReplyTopic) // 👈 Уникальный топик инстанса
//                 .correlationId(AuthEventUtils.generateCorrelationId())
//                 .build(),
//             TokenValidationResponse.class
//         );
//     }

//     public CompletableFuture<HealthCheckResponse> healthCheck(String sourceService) {
//         return sendRequest(
//             HealthCheckCommand.builder()
//                 .eventId(UUID.randomUUID().toString())
//                 .sourceService(sourceService)
//                 .timestamp(new Date().toInstant())
//                 .replyTopic(instanceReplyTopic) // 👈 Уникальный топик инстанса
//                 .correlationId(AuthEventUtils.generateCorrelationId())
//                 .commandType(AuthEventConstants.COMMAND_HEALTH_CHECK)
//                 .build(),
//             HealthCheckResponse.class
//         );
//     }

//     private <T> CompletableFuture<T> sendRequest(Object command, Class<T> responseType) {
//         String correlationId;
        
//         if (command instanceof ValidateTokenCommand) {
//             correlationId = ((ValidateTokenCommand) command).getCorrelationId();
//         } else if (command instanceof ExtractClientUidCommand) {
//             correlationId = ((ExtractClientUidCommand) command).getCorrelationId();
//         } else if (command instanceof HealthCheckCommand) {
//             correlationId = ((HealthCheckCommand) command).getCorrelationId();
//         } else {
//             throw new IllegalArgumentException("Unsupported command type: " + command.getClass());
//         }

//         CompletableFuture<T> future = new CompletableFuture<>();
//         pendingRequests.put(correlationId, new PendingRequest<>(future, responseType));

//         // 👇 Добавляем таймаут 30 секунд
//         future.orTimeout(30, TimeUnit.SECONDS).whenComplete((result, ex) -> {
//             if (ex != null) {
//                 pendingRequests.remove(correlationId);
//                 log.warn("Request timeout or error for correlationId: {}", correlationId);
//             }
//         });

//         kafkaTemplate.send(authCommandsTopic, correlationId, command)
//                 .whenComplete((result, ex) -> {
//                     if (ex != null) {
//                         future.completeExceptionally(ex);
//                         pendingRequests.remove(correlationId);
//                         log.error("Failed to send auth command: {}", ex.getMessage());
//                     } else {
//                         log.info("Auth command sent successfully: correlationId={}, topic={}", 
//                                 correlationId, authCommandsTopic);
//                     }
//                 });

//         return future;
//     }

//     @SuppressWarnings("unchecked")
//     public void handleResponse(String correlationId, Object response) {
//         PendingRequest<?> pendingRequest = pendingRequests.remove(correlationId);
//         if (pendingRequest != null) {
//             try {
//                 if (pendingRequest.responseType.isInstance(response)) {
//                     CompletableFuture<Object> future = (CompletableFuture<Object>) pendingRequest.future;
//                     future.complete(response);
//                     log.info("Auth response handled successfully: correlationId={}", correlationId);
//                 } else {
//                     log.warn("Type mismatch for correlationId: {}. Expected: {}, Got: {}", 
//                             correlationId, pendingRequest.responseType, response.getClass());
//                     pendingRequest.future.completeExceptionally(
//                         new ClassCastException("Type mismatch in auth response")
//                     );
//                 }
//             } catch (Exception e) {
//                 pendingRequest.future.completeExceptionally(e);
//             }
//         } else {
//             log.warn("Received auth response for unknown correlationId: {}", correlationId);
//         }
//     }
    
//     // 👇 Геттер для получения уникального топика инстанса
//     public String getInstanceReplyTopic() {
//         log.info("Got teply topic: " + instanceReplyTopic);
//         return instanceReplyTopic;
//     }
// }// package com.service.buffer.kafka;

// import java.util.List;
// import java.util.Map;
// import java.util.UUID;
// import java.util.concurrent.CompletableFuture;
// import java.util.concurrent.ConcurrentHashMap;
// import java.util.concurrent.TimeUnit;

// import org.springframework.beans.factory.annotation.Autowired;
// import org.springframework.beans.factory.annotation.Value;
// import org.springframework.kafka.core.KafkaTemplate;
// import org.springframework.stereotype.Component;

// import com.connection.device.events.DeviceEventUtils;
// import com.connection.device.events.commands.GetDeviceByUidCommand;
// import com.connection.device.events.commands.GetDevicesByClientUid;
// import com.connection.device.events.commands.HealthCheckCommand;
// import com.connection.device.events.responses.GetDeviceByUidResponse;
// import com.connection.device.events.responses.GetDevicesByClientResponse;
// import com.connection.device.events.responses.HealthCheckResponse;

// import lombok.extern.slf4j.Slf4j;

// @Slf4j
// @Component
// public class TypedDeviceKafkaClient {

//     @Autowired
//     private KafkaTemplate<String, Object> kafkaTemplate;

//     private final Map<String, PendingRequest<?>> pendingRequests = new ConcurrentHashMap<>();
        
//     @Value("${app.kafka.topics.device-commands:device.commands}")
//     private String deviceCommandsTopic;

//     private final String instanceReplyTopic = "device.responses." + UUID.randomUUID().toString();

//     private static class PendingRequest<T> {
//         final CompletableFuture<T> future;
//         final Class<T> responseType;

//         PendingRequest(CompletableFuture<T> future, Class<T> responseType) {
//             this.future = future;
//             this.responseType = responseType;
//         }
//     }

//     public CompletableFuture<GetDeviceByUidResponse> getDeviceByUid(UUID deviceUid, String sourceService) {
//         return sendRequest(
//             GetDeviceByUidCommand.builder()
//                 .deviceUid(deviceUid)
//                 .sourceService(sourceService)
//                 .replyTopic(instanceReplyTopic) 
//                 .correlationId(DeviceEventUtils.generateCorrelationId())
//                 .build(),
//             GetDeviceByUidResponse.class
//         );
//     }

//     public CompletableFuture<GetDevicesByClientResponse> getDevicesByClient(UUID clientUid, String sourceService) {
//         return sendRequest(
//             GetDevicesByClientUid.builder()
//                 .sourceService(sourceService)
//                 .clientUid(clientUid)
//                 .replyTopic(instanceReplyTopic) 
//                 .correlationId(DeviceEventUtils.generateCorrelationId())
//                 .build(),
//             GetDevicesByClientResponse.class
//         );
//     }

//     public CompletableFuture<HealthCheckResponse> healthCheck(String sourceService) {
//         return sendRequest(
//             HealthCheckCommand.builder()
//                 .sourceService(sourceService)
//                 .replyTopic(instanceReplyTopic) 
//                 .correlationId(DeviceEventUtils.generateCorrelationId())
//                 .build(),
//             HealthCheckResponse.class
//         );
//     }

    
//     public boolean deviceExistsAndBelongsToClient(UUID deviceUid, UUID clientUid) {
//         try {
//             GetDeviceByUidResponse response = getDeviceByUid(deviceUid, "buffer-service")
//                     .get(10, TimeUnit.SECONDS);
//             return response.isSuccess() && response.getDeviceDTO() != null && 
//                    response.getDeviceDTO().getClientUuid().equals(clientUid.toString());
//         } catch (Exception e) {
//             log.error("Error checking device existence: {}", e.getMessage());
//             return false;
//         }
//     }

//     public List<UUID> getClientDeviceUids(UUID clientUid) {
//         try {
//             GetDevicesByClientResponse response = getDevicesByClient(clientUid, "buffer-service")
//                     .get(10, TimeUnit.SECONDS);
            
//             if (response.isSuccess() && response.getDeviceDTOs() != null) {
//                 return response.getDeviceDTOs().stream()
//                         .map(device -> UUID.fromString(device.getUid()))
//                         .collect(java.util.stream.Collectors.toList());
//             }
//             return List.of();
//         } catch (Exception e) {
//             log.error("Error getting client devices: {}", e.getMessage());
//             return List.of();
//         }
//     }

//     private <T> CompletableFuture<T> sendRequest(Object command, Class<T> responseType) {
//         String correlationId = extractCorrelationId(command);
        
//         CompletableFuture<T> future = new CompletableFuture<>();
//         pendingRequests.put(correlationId, new PendingRequest<>(future, responseType));

        
//         future.orTimeout(30, TimeUnit.SECONDS).whenComplete((result, ex) -> {
//             if (ex != null) {
//                 pendingRequests.remove(correlationId);
//                 log.warn("Device request timeout or error for correlationId: {}", correlationId);
//             }
//         });

//         kafkaTemplate.send(deviceCommandsTopic, correlationId, command)
//                 .whenComplete((result, ex) -> {
//                     if (ex != null) {
//                         future.completeExceptionally(ex);
//                         pendingRequests.remove(correlationId);
//                         log.error("Failed to send device command: {}", ex.getMessage());
//                     } else {
//                         log.info("Device command sent successfully: correlationId={}, topic={}", 
//                                 correlationId, deviceCommandsTopic);
//                     }
//                 });

//         return future;
//     }

//     @SuppressWarnings("unchecked")
//     public void handleResponse(String correlationId, Object response) {
//         PendingRequest<?> pendingRequest = pendingRequests.remove(correlationId);
//         if (pendingRequest != null) {
//             try {
//                 if (pendingRequest.responseType.isInstance(response)) {
//                     log.info("Device response: ", pendingRequest.toString());
//                     CompletableFuture<Object> future = (CompletableFuture<Object>) pendingRequest.future;
//                     future.complete(response);
//                     log.info("Device response handled successfully: correlationId={}", correlationId);
//                 } else {
//                     log.warn("Type mismatch for correlationId: {}. Expected: {}, Got: {}", 
//                             correlationId, pendingRequest.responseType, response.getClass());
//                     pendingRequest.future.completeExceptionally(
//                         new ClassCastException("Type mismatch in device response")
//                     );
//                 }
//             } catch (Exception e) {
//                 pendingRequest.future.completeExceptionally(e);
//             }
//         } else {
//             log.warn("Received device response for unknown correlationId: {}", correlationId);
//         }
//     }

//     private String extractCorrelationId(Object command) {
//         if (command instanceof GetDeviceByUidCommand) {
//             return ((GetDeviceByUidCommand) command).getCorrelationId();
//         } else if (command instanceof GetDevicesByClientUid) {
//             return ((GetDevicesByClientUid) command).getCorrelationId();
//         } else if (command instanceof HealthCheckCommand) {
//             return ((HealthCheckCommand) command).getCorrelationId();
//         } else {
//             throw new IllegalArgumentException("Unsupported device command type: " + command.getClass());
//         }
//     }
    
    
//     public String getInstanceReplyTopic() {
//         log.info("Got teply topic: " + instanceReplyTopic);
//         return instanceReplyTopic;
//     }
// }// package com.service.buffer.kafka;

// import java.util.Map;
// import java.util.UUID;
// import java.util.concurrent.CompletableFuture;
// import java.util.concurrent.ConcurrentHashMap;
// import java.util.concurrent.TimeUnit;

// import org.springframework.beans.factory.annotation.Autowired;
// import org.springframework.beans.factory.annotation.Value;
// import org.springframework.kafka.core.KafkaTemplate;
// import org.springframework.stereotype.Component;

// import com.connection.scheme.events.ConnectionSchemeEventUtils;
// import com.connection.scheme.events.commands.GetConnectionSchemeByUidCommand;
// import com.connection.scheme.events.commands.HealthCheckCommand;
// import com.connection.scheme.events.responses.GetConnectionSchemeByUidResponse;
// import com.connection.scheme.events.responses.HealthCheckResponse;

// import lombok.RequiredArgsConstructor;
// import lombok.extern.slf4j.Slf4j;

// @Slf4j
// @Component
// @RequiredArgsConstructor
// public class TypedConnectionSchemeKafkaClient {

//     @Autowired
//     private KafkaTemplate<String, Object> kafkaTemplate;
//     private final Map<String, PendingRequest<?>> pendingRequests = new ConcurrentHashMap<>();
    
//     @Value("${app.kafka.topics.connection-scheme-commands:connection.scheme.commands}")
//     private String connectionSchemeCommandsTopic;

//     // 👇 Уникальный топик для этого инстанса
//     private final String instanceReplyTopic = "connection-scheme.responses." + UUID.randomUUID().toString();

//     private static class PendingRequest<T> {
//         final CompletableFuture<T> future;
//         final Class<T> responseType;

//         PendingRequest(CompletableFuture<T> future, Class<T> responseType) {
//             this.future = future;
//             this.responseType = responseType;
//         }
//     }

//     public CompletableFuture<GetConnectionSchemeByUidResponse> getConnectionSchemeByUid(UUID connectionSchemeUid, String sourceService) {
//         return sendRequest(
//             GetConnectionSchemeByUidCommand.builder()
//                 .connectionSchemeUid(connectionSchemeUid)
//                 .sourceService(sourceService)
//                 .replyTopic(instanceReplyTopic) // 👈 Уникальный топик инстанса
//                 .correlationId(ConnectionSchemeEventUtils.generateCorrelationId())
//                 .build(),
//             GetConnectionSchemeByUidResponse.class
//         );
//     }

//     public CompletableFuture<HealthCheckResponse> healthCheck(String sourceService) {
//         return sendRequest(
//             HealthCheckCommand.builder()
//                 .sourceService(sourceService)
//                 .replyTopic(instanceReplyTopic) // 👈 Уникальный топик инстанса
//                 .correlationId(ConnectionSchemeEventUtils.generateCorrelationId())
//                 .build(),
//             HealthCheckResponse.class
//         );
//     }

//     // Вспомогательные методы для удобства
//     public boolean connectionSchemeExistsAndBelongsToClient(UUID connectionSchemeUid, UUID clientUuid) {
//         try {
//             GetConnectionSchemeByUidResponse response = getConnectionSchemeByUid(connectionSchemeUid, "buffer-service")
//                     .get(10, TimeUnit.SECONDS);
//             return response.isSuccess() && response.getConnectionSchemeDTO() != null && 
//                    response.getConnectionSchemeDTO().getClientUid().equals(clientUuid.toString());
//         } catch (Exception e) {
//             log.error("Error checking connection scheme existence: {}", e.getMessage());
//             return false;
//         }
//     }

//     private <T> CompletableFuture<T> sendRequest(Object command, Class<T> responseType) {
//         String correlationId = extractCorrelationId(command);
        
//         CompletableFuture<T> future = new CompletableFuture<>();
//         pendingRequests.put(correlationId, new PendingRequest<>(future, responseType));

//         // 👇 Добавляем таймаут 30 секунд
//         future.orTimeout(30, TimeUnit.SECONDS).whenComplete((result, ex) -> {
//             if (ex != null) {
//                 pendingRequests.remove(correlationId);
//                 log.warn("Connection scheme request timeout or error for correlationId: {}", correlationId);
//             }
//         });

//         kafkaTemplate.send(connectionSchemeCommandsTopic, correlationId, command)
//                 .whenComplete((result, ex) -> {
//                     if (ex != null) {
//                         future.completeExceptionally(ex);
//                         pendingRequests.remove(correlationId);
//                         log.error("Failed to send connection scheme command: {}", ex.getMessage());
//                     } else {
//                         log.info("Connection scheme command sent successfully: correlationId={}, topic={}", 
//                                 correlationId, connectionSchemeCommandsTopic);
//                     }
//                 });

//         return future;
//     }

//     @SuppressWarnings("unchecked")
//     public void handleResponse(String correlationId, Object response) {
//         PendingRequest<?> pendingRequest = pendingRequests.remove(correlationId);
//         if (pendingRequest != null) {
//             try {
//                 if (pendingRequest.responseType.isInstance(response)) {
//                     CompletableFuture<Object> future = (CompletableFuture<Object>) pendingRequest.future;
//                     future.complete(response);
//                     log.info("Connection scheme response handled successfully: correlationId={}", correlationId);
//                 } else {
//                     log.warn("Type mismatch for correlationId: {}. Expected: {}, Got: {}", 
//                             correlationId, pendingRequest.responseType, response.getClass());
//                     pendingRequest.future.completeExceptionally(
//                         new ClassCastException("Type mismatch in connection scheme response")
//                     );
//                 }
//             } catch (Exception e) {
//                 pendingRequest.future.completeExceptionally(e);
//             }
//         } else {
//             log.warn("Received connection scheme response for unknown correlationId: {}", correlationId);
//         }
//     }

//     private String extractCorrelationId(Object command) {
//         if (command instanceof GetConnectionSchemeByUidCommand) {
//             return ((GetConnectionSchemeByUidCommand) command).getCorrelationId();
//         } else if (command instanceof HealthCheckCommand) {
//             return ((HealthCheckCommand) command).getCorrelationId();
//         } else {
//             throw new IllegalArgumentException("Unsupported connection scheme command type: " + command.getClass());
//         }
//     }
    
//     // 👇 Геттер для получения уникального топика инстанса
//     public String getInstanceReplyTopic() {
//         return instanceReplyTopic;
//     }
// }// package com.service.buffer.kafka;

// import org.apache.kafka.clients.consumer.ConsumerRecord;
// import org.springframework.beans.factory.annotation.Autowired;
// import org.springframework.boot.context.event.ApplicationReadyEvent;
// import org.springframework.context.ApplicationListener;
// import org.springframework.kafka.annotation.KafkaListener;
// import org.springframework.kafka.config.KafkaListenerEndpointRegistry;
// import org.springframework.kafka.listener.MessageListenerContainer;
// import org.springframework.stereotype.Component;

// import com.connection.common.events.CommandResponse;
// import com.connection.device.events.responses.GetDeviceByUidResponse;
// import com.connection.device.events.responses.GetDevicesByClientResponse;
// import com.connection.device.events.responses.HealthCheckResponse;

// import lombok.RequiredArgsConstructor;
// import lombok.extern.slf4j.Slf4j;

// @Slf4j
// @Component
// @RequiredArgsConstructor
// public class DeviceResponseConsumer implements ApplicationListener<ApplicationReadyEvent> {

//     @Autowired
//     private TypedDeviceKafkaClient deviceKafkaClient;
//     @Autowired
//     private KafkaListenerEndpointRegistry registry;

//     @KafkaListener(id = "dynamicDeviceListener", 
//                    topics = "#{@typedDeviceKafkaClient.getInstanceReplyTopic()}")
//     public void handleDeviceResponse(ConsumerRecord<String, CommandResponse> record) {
//         try {
//             CommandResponse message = record.value();
//             String correlationId = record.key();
            
//             log.info("Received device response from instance topic: correlationId={}, topic={}", 
//                     correlationId, record.topic());
                
//             if (message instanceof GetDeviceByUidResponse) {
//                 GetDeviceByUidResponse typedResponse = (GetDeviceByUidResponse) message;
//                 deviceKafkaClient.handleResponse(correlationId, typedResponse);
//             } else if (message instanceof GetDevicesByClientResponse) {
//                 GetDevicesByClientResponse typedResponse = (GetDevicesByClientResponse) message;
//                 deviceKafkaClient.handleResponse(correlationId, typedResponse);
//             } else if (message instanceof HealthCheckResponse) {
//                 HealthCheckResponse typedResponse = (HealthCheckResponse) message;
//                 deviceKafkaClient.handleResponse(correlationId, typedResponse);
//             } else {
//                 log.warn("Unknown device response type for correlationId: {}", correlationId);
//             }
            
//         } catch (Exception e) {
//             log.error("Error processing device response: correlationId={}", record.key(), e);
//         }
//     }

//     @Override
//     public void onApplicationEvent(ApplicationReadyEvent event) {
//         try {
//             MessageListenerContainer container = registry.getListenerContainer("dynamicDeviceListener");
//             if (container != null && !container.isRunning()) {
//                 container.start();
//                 log.info("Dynamic device response listener started for topic: {}", 
//                         deviceKafkaClient.getInstanceReplyTopic());
//             }
//         } catch (Exception e) {
//             log.error("Failed to start dynamic device listener", e);
//         }
//     }
// }package com.service.buffer.client;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import com.connection.service.auth.AuthService;
import com.connection.token.model.AccessTokenBLM;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Collections;

@Slf4j
@Component
@RequiredArgsConstructor
public class AuthenticationFilter extends OncePerRequestFilter {

    private final AuthService authClient;
    private static final String AUTH_HEADER = "Authorization";
    private static final String BEARER_PREFIX = "Bearer ";

    @Override
    protected void doFilterInternal(HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain) throws ServletException, IOException {

        String authHeader = request.getHeader(AUTH_HEADER);

        if (authHeader == null || !authHeader.startsWith(BEARER_PREFIX)) {
            filterChain.doFilter(request, response);
            return;
        }

        String jwtToken = authHeader.substring(BEARER_PREFIX.length());

        try {
            authenticateWithToken(jwtToken, request);
        } catch (Exception e) {
            log.error("Authentication failed for token: {}", e.getMessage());
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            return;
        }

        filterChain.doFilter(request, response);
    }

    private void authenticateWithToken(String token, HttpServletRequest request) {
        try {
            String cleanToken = token.trim();
            cleanToken = cleanToken.replace("Bearer ", "");

            log.info("Validating token: {}...", cleanToken);

            AccessTokenBLM accessTokenBLM = authClient.validateAccessToken(cleanToken);

            UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                    accessTokenBLM.getClientUID(),
                    null,
                    Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER")));

            authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
            SecurityContextHolder.getContext().setAuthentication(authentication);

            log.info("Successfully authenticated client: {}", accessTokenBLM.getClientUID());
        } catch (Exception e) {
            throw new SecurityException("Authentication failed: " + e.getMessage());
        }
    }
}package com.service.buffer.integration;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;
import org.springframework.test.context.ActiveProfiles;

import com.connection.scheme.events.commands.GetConnectionSchemeByUidCommand;
import com.connection.scheme.events.commands.GetConnectionSchemesByBufferUid;
import com.connection.scheme.events.commands.GetConnectionSchemesByClientUid;
import com.connection.scheme.events.commands.HealthCheckCommand;
import com.connection.scheme.events.responses.GetConnectionSchemeByUidResponse;
import com.connection.scheme.events.responses.GetConnectionSchemesByBufferResponse;
import com.connection.scheme.events.responses.GetConnectionSchemesByClientResponse;
import com.connection.scheme.events.responses.HealthCheckResponse;
import com.connection.scheme.model.ConnectionSchemeDTO;

import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
@Component
@RequiredArgsConstructor
@ActiveProfiles("integrationtest")
public class TestConnectionSchemeService {

    private final KafkaTemplate<String, Object> kafkaTemplate;

    // Хранилище тестовых данных
    private final Map<UUID, ConnectionSchemeDTO> testSchemes = new ConcurrentHashMap<>();
    private final Map<UUID, List<ConnectionSchemeDTO>> clientSchemes = new ConcurrentHashMap<>();
    private final Map<UUID, List<ConnectionSchemeDTO>> bufferSchemes = new ConcurrentHashMap<>();

    @Value("${app.kafka.topics.connection-scheme-commands:connection.scheme.commands}")
    private String connectionSchemeCommandsTopic;
    @PostConstruct
    public void logKafkaConfiguration() {
        log.info("""
            🧪 Test Connection Scheme Responder Kafka Configuration:
               📨 Listening Topic: {}
            """, connectionSchemeCommandsTopic);
    }


    @KafkaListener(topics = "${app.kafka.topics.connection-scheme-commands:connection.scheme.commands}", groupId = "test-connection-scheme-responder")
    public void handleConnectionSchemeCommand(ConsumerRecord<String, Object> record) {
        try {
            Object command = record.value();
            if (command instanceof GetConnectionSchemeByUidCommand) {
                handleGetConnectionSchemeByUid((GetConnectionSchemeByUidCommand) command);
            } else if (command instanceof GetConnectionSchemesByClientUid) {
                handleGetConnectionSchemesByClient((GetConnectionSchemesByClientUid) command);
            } else if (command instanceof GetConnectionSchemesByBufferUid) {
                handleGetConnectionSchemesByBuffer((GetConnectionSchemesByBufferUid) command);
            } else if (command instanceof HealthCheckCommand) {
                handleHealthCheck((HealthCheckCommand) command);
            }

        } catch (Exception e) {
            log.error("❌ Error in test connection scheme responder", e);
        }
    }

    private void handleGetConnectionSchemeByUid(GetConnectionSchemeByUidCommand command) {
        try {
            UUID schemeUid = command.getConnectionSchemeUid();
            ConnectionSchemeDTO scheme = testSchemes.get(schemeUid);

            GetConnectionSchemeByUidResponse response;
            if (scheme != null) {
                response = GetConnectionSchemeByUidResponse.success(
                        command.getCorrelationId(),
                        scheme);
                log.info("✅ Test Responder: Connection Scheme {} found", schemeUid);
            } else {
                response = GetConnectionSchemeByUidResponse.error(
                        command.getCorrelationId(),
                        "Connection scheme not found in test data");
                log.warn("⚠️ Test Responder: Connection Scheme {} not found", schemeUid);
            }

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);

        } catch (Exception e) {
            log.error("❌ Error handling GetConnectionSchemeByUid", e);
        }
    }

    private void handleGetConnectionSchemesByClient(GetConnectionSchemesByClientUid command) {
        try {
            UUID clientUid = command.getClientUid();
            List<ConnectionSchemeDTO> schemes = clientSchemes.get(clientUid);

            GetConnectionSchemesByClientResponse response;
            if (schemes != null && !schemes.isEmpty()) {
                response = GetConnectionSchemesByClientResponse.valid(
                        command.getCorrelationId(),
                        schemes);
                log.info("✅ Test Responder: Found {} connection schemes for client {}", schemes.size(), clientUid);
            } else {
                response = GetConnectionSchemesByClientResponse.valid(
                        command.getCorrelationId(),
                        List.of());
                log.info("ℹ️ Test Responder: No connection schemes found for client {}", clientUid);
            }

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);

        } catch (Exception e) {
            log.error("❌ Error handling GetConnectionSchemesByClient", e);
        }
    }

    private void handleGetConnectionSchemesByBuffer(GetConnectionSchemesByBufferUid command) {
        try {
            UUID bufferUid = command.getBufferUid();
            List<ConnectionSchemeDTO> schemes = bufferSchemes.get(bufferUid);

            GetConnectionSchemesByBufferResponse response;
            if (schemes != null && !schemes.isEmpty()) {
                response = GetConnectionSchemesByBufferResponse.valid(
                        command.getCorrelationId(),
                        schemes);
                log.info("✅ Test Responder: Found {} connection schemes for buffer {}", schemes.size(), bufferUid);
            } else {
                response = GetConnectionSchemesByBufferResponse.valid(
                        command.getCorrelationId(),
                        List.of());
                log.info("ℹ️ Test Responder: No connection schemes found for buffer {}", bufferUid);
            }

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);

        } catch (Exception e) {
            log.error("❌ Error handling GetConnectionSchemesByBuffer", e);
        }
    }

    private void handleHealthCheck(HealthCheckCommand command) {
        try {
            HealthCheckResponse response = HealthCheckResponse.success(
                    command.getCorrelationId(),
                    Map.of("status", "OK", "service", "test-connection-scheme-responder"));

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
            log.info("✅ Test Responder: Health check responded");

        } catch (Exception e) {
            log.error("❌ Error handling HealthCheck", e);
        }
    }

    // Методы для управления тестовыми данными

    public void addTestConnectionScheme(UUID schemeUid, UUID clientUid, List<UUID> usedBuffers) {
        ConnectionSchemeDTO scheme = createTestConnectionSchemeDTO(schemeUid, clientUid, usedBuffers);
        addTestConnectionScheme(scheme);
    }

    public void addTestConnectionScheme(ConnectionSchemeDTO scheme) {
        UUID schemeUid = UUID.fromString(scheme.getUid());
        UUID clientUid = UUID.fromString(scheme.getClientUid());

        testSchemes.put(schemeUid, scheme);

        // Добавляем в список схем клиента
        List<ConnectionSchemeDTO> clientSchemeList = clientSchemes.computeIfAbsent(
                clientUid, k -> new ArrayList<>());
        clientSchemeList.add(scheme);

        // Автоматически создаем связи с буферами из usedBuffers
        if (scheme.getUsedBuffers() != null) {
            for (UUID bufferUid : scheme.getUsedBuffers()) {
                linkSchemeToBuffer(schemeUid, bufferUid);
            }
        }

        log.info("📝 Test Responder: Added connection scheme {} for client {} with {} used buffers",
                schemeUid, clientUid,
                scheme.getUsedBuffers() != null ? scheme.getUsedBuffers().size() : 0);
    }

    public void linkSchemeToBuffer(UUID schemeUid, UUID bufferUid) {
        ConnectionSchemeDTO scheme = testSchemes.get(schemeUid);
        if (scheme != null) {
            List<ConnectionSchemeDTO> bufferSchemeList = bufferSchemes.computeIfAbsent(
                    bufferUid, k -> new ArrayList<>());
            if (!bufferSchemeList.contains(scheme)) {
                bufferSchemeList.add(scheme);
            }
            log.info("🔗 Test Responder: Linked scheme {} to buffer {}", schemeUid, bufferUid);
        } else {
            log.warn("⚠️ Test Responder: Cannot link - scheme {} not found", schemeUid);
        }
    }

    public void removeTestConnectionScheme(UUID schemeUid) {
        ConnectionSchemeDTO scheme = testSchemes.remove(schemeUid);
        if (scheme != null) {
            UUID clientUid = UUID.fromString(scheme.getClientUid());

            // Удаляем из списка клиента
            List<ConnectionSchemeDTO> clientSchemesList = clientSchemes.get(clientUid);
            if (clientSchemesList != null) {
                clientSchemesList.removeIf(s -> s.getUid().equals(schemeUid.toString()));
            }

            // Удаляем из всех связей с буферами
            bufferSchemes.values()
                    .forEach(schemeList -> schemeList.removeIf(s -> s.getUid().equals(schemeUid.toString())));
        }
    }

    public void clearTestData() {
        testSchemes.clear();
        clientSchemes.clear();
        bufferSchemes.clear();
        log.info("🧹 Test Responder: All connection scheme test data cleared");
    }

    public boolean hasConnectionScheme(UUID schemeUid) {
        return testSchemes.containsKey(schemeUid);
    }

    public boolean connectionSchemeBelongsToClient(UUID schemeUid, UUID clientUid) {
        ConnectionSchemeDTO scheme = testSchemes.get(schemeUid);
        return scheme != null && scheme.getClientUid().equals(clientUid.toString());
    }

    private ConnectionSchemeDTO createTestConnectionSchemeDTO(UUID schemeUid, UUID clientUid, List<UUID> usedBuffers) {
        return ConnectionSchemeDTO.builder()
                .uid(schemeUid.toString())
                .clientUid(clientUid.toString())
                .usedBuffers(usedBuffers != null ? usedBuffers : new ArrayList<>())
                .schemeJson("{\"test\": true, \"schemeType\": \"integration-test\", \"buffers\": " +
                        (usedBuffers != null ? usedBuffers.toString() : "[]") + "}")
                .build();
    }

    // Дополнительные методы для удобства

    public void addTestConnectionSchemeWithBuffers(UUID schemeUid, UUID clientUid, UUID... bufferUids) {
        List<UUID> usedBuffers = bufferUids != null ? Arrays.asList(bufferUids) : new ArrayList<>();
        addTestConnectionScheme(schemeUid, clientUid, usedBuffers);
    }

    public void addBufferToScheme(UUID schemeUid, UUID bufferUid) {
        ConnectionSchemeDTO scheme = testSchemes.get(schemeUid);
        if (scheme != null) {
            List<UUID> usedBuffers = scheme.getUsedBuffers();
            if (usedBuffers == null) {
                usedBuffers = new ArrayList<>();
                scheme.setUsedBuffers(usedBuffers);
            }
            if (!usedBuffers.contains(bufferUid)) {
                usedBuffers.add(bufferUid);
            }
            linkSchemeToBuffer(schemeUid, bufferUid);
            log.info("➕ Test Responder: Added buffer {} to scheme {}", bufferUid, schemeUid);
        }
    }

    public void removeBufferFromScheme(UUID schemeUid, UUID bufferUid) {
        ConnectionSchemeDTO scheme = testSchemes.get(schemeUid);
        if (scheme != null && scheme.getUsedBuffers() != null) {
            scheme.getUsedBuffers().remove(bufferUid);

            // Удаляем связь
            List<ConnectionSchemeDTO> bufferSchemesList = bufferSchemes.get(bufferUid);
            if (bufferSchemesList != null) {
                bufferSchemesList.removeIf(s -> s.getUid().equals(schemeUid.toString()));
            }
            log.info("➖ Test Responder: Removed buffer {} from scheme {}", bufferUid, schemeUid);
        }
    }
}package com.service.buffer.integration;

import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.stereotype.Component;
import org.springframework.test.context.ActiveProfiles;

import com.connection.device.DeviceService;
import com.connection.device.model.DeviceBLM;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
@ActiveProfiles("integrationtest")
public class TestDeviceService implements DeviceService {
    
    // Хранилище тестовых данных
    private final Map<UUID, DeviceBLM> testDevices = new ConcurrentHashMap<>();
    private final Map<UUID, List<DeviceBLM>> clientDevices = new ConcurrentHashMap<>();
        
    
    
    // Методы для управления тестовыми данными
    public void addTestDevice(UUID deviceUid, UUID clientUid, String deviceName) {
        DeviceBLM device = new DeviceBLM();
        device.setUid(deviceUid);
        device.setClientUuid(clientUid);
        device.setDeviceName(deviceName);
        device.setDeviceDescription("Test device for integration tests");
        
        testDevices.put(deviceUid, device);
        
        // Также добавляем в список устройств клиента
        List<DeviceBLM> clientDeviceList = clientDevices.computeIfAbsent(
            clientUid, k -> new java.util.ArrayList<>()
        );
        clientDeviceList.add(device);
        
        log.info("📝 Test Responder: Added test device {} for client {}", deviceUid, clientUid);
    }
    
    public void addTestDevice(DeviceBLM device) {
        UUID deviceUid = (device.getUid());
        UUID clientUid = (device.getClientUuid());
        
        testDevices.put(deviceUid, device);
        
        List<DeviceBLM> clientDeviceList = clientDevices.computeIfAbsent(
            clientUid, k -> new java.util.ArrayList<>()
        );
        clientDeviceList.add(device);
    }
    
    public void removeTestDevice(UUID deviceUid) {
        DeviceBLM device = testDevices.remove(deviceUid);
        if (device != null) {
            UUID clientUid = (device.getClientUuid());
            List<DeviceBLM> clientDevicesList = clientDevices.get(clientUid);
            if (clientDevicesList != null) {
                clientDevicesList.removeIf(d -> d.getUid().equals(deviceUid));
            }
        }
    }
    
    public void clearTestData() {
        testDevices.clear();
        clientDevices.clear();
        log.info("🧹 Test Responder: All test data cleared");
    }
    
    public boolean hasDevice(UUID deviceUid) {
        return testDevices.containsKey(deviceUid);
    }

    @Override
    public DeviceBLM createDevice(DeviceBLM deviceBLM) {
        throw new UnsupportedOperationException("Unimplemented method 'createDevice'");
    }

    @Override
    public boolean deviceExists(UUID deviceUid) {
        boolean exists = testDevices.containsKey(deviceUid);
        log.debug("🔍 Test Responder: Check if device {} exists: {}", deviceUid, exists);
        return exists;
    }

    @Override
    public DeviceBLM getDevice(UUID deviceUid) {
        DeviceBLM deviceBLM = testDevices.get(deviceUid);
        if (deviceBLM != null) {
            log.debug(" Test Responder: Retrieved device {}", deviceUid);
            return deviceBLM;
        } else {
            log.warn(" Test Responder: Device {} not found", deviceUid);
            return null;
        }
    }

    @Override
    public List<DeviceBLM> getDevicesByClient(UUID clientUid) {
        throw new UnsupportedOperationException("Unimplemented method 'createDevice'");
    }

    @Override
    public Map<String, Object> getHealthStatus() {
        Map<String, Object> healthStatus = new java.util.HashMap<>();
        healthStatus.put("status", "UP");
        healthStatus.put("testDevicesCount", testDevices.size());
        healthStatus.put("clientsWithDevicesCount", clientDevices.size());
        healthStatus.put("timestamp", java.time.LocalDateTime.now().toString());
        
        log.debug(" Test Responder: Health status checked");
        return healthStatus;
    }

    @Override
    public DeviceBLM updateDevice(DeviceBLM deviceBLM) {
        throw new UnsupportedOperationException("Unimplemented method 'createDevice'");
    }

    @Override
    public void deleteDevice(UUID deviceUid) {
        throw new UnsupportedOperationException("Unimplemented method 'deleteDevice'");
    }
}package com.service.buffer.mother;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import com.connection.processing.buffer.model.BufferBLM;
import com.connection.processing.buffer.model.BufferDALM;
import com.connection.processing.buffer.model.BufferDTO;
import com.connection.scheme.model.ConnectionSchemeBLM;

public class BufferObjectMother {

    public static final UUID CLIENT_UUID = UUID.fromString("123e4567-e89b-12d3-a456-426614174000");
    public static final UUID BUFFER_UUID = UUID.fromString("323e4567-e89b-12d3-a456-426614174002");
    public static final UUID SCHEME_UUID = UUID.fromString("423e4567-e89b-12d3-a456-426614174003");
    public static final String VALID_TOKEN = "valid-token-123";
    public static final String INVALID_TOKEN = "invalid-token-456";


    private static final UUID BUFFER_UID_1 = UUID.fromString("223e4567-e89b-12d3-a456-426614174002");
    private static final UUID BUFFER_UID_2 = UUID.fromString("223e4567-e89b-12d3-a456-426614174003");
    private static final UUID BUFFER_UID_3 = UUID.fromString("223e4567-e89b-12d3-a456-426614174004");
    
    private static final String DEFAULT_SCHEME_JSON = "{" +
        "\"usedBuffers\": [\"" + BUFFER_UID_1 + "\", \"" + BUFFER_UID_2 + "\"], " +
        "\"bufferTransitions\": {" +
            "\"" + BUFFER_UID_1 + "\": [\"" + BUFFER_UID_2 + "\"], " +
            "\"" + BUFFER_UID_2 + "\": [\"" + BUFFER_UID_3 + "\"]" +
        "}" +
    "}";


    public static BufferDTO createValidBufferDTO() {
        return new BufferDTO(
            BUFFER_UUID.toString(),
            SCHEME_UUID.toString(),
            1000,
            1024,
            "message prototype"
        );
    }

    public static BufferBLM createValidBufferBLM() {
        return new BufferBLM(
            BUFFER_UUID,
            SCHEME_UUID,
            1000,
            1024,
            "message prototype"
        );
    }

    public static BufferDALM createValidBufferDALM() {
        return new BufferDALM(
            BUFFER_UUID,
            SCHEME_UUID,
            1000,
            1024,
            "message prototype"
        );
    }
    public static ConnectionSchemeBLM createValidConnectionSchemeBLM() {
        Map<UUID, List<UUID>> bufferTransitions = new HashMap<>();
        bufferTransitions.put(BUFFER_UID_1, Arrays.asList(BUFFER_UID_2));
        bufferTransitions.put(BUFFER_UID_2, Arrays.asList(BUFFER_UID_3));
        
        return ConnectionSchemeBLM.builder()
                .uid(SCHEME_UUID)
                .clientUid(CLIENT_UUID)
                .schemeJson(DEFAULT_SCHEME_JSON)
                .usedBuffers(Arrays.asList(BUFFER_UID_1, BUFFER_UID_2))
                .bufferTransitions(bufferTransitions)
                .build();
    }

    public static ConnectionSchemeBLM createValidConnectionSchemeBLM(UUID clientUuid) {
        Map<UUID, List<UUID>> bufferTransitions = new HashMap<>();
        bufferTransitions.put(BUFFER_UID_1, Arrays.asList(BUFFER_UID_2));
        bufferTransitions.put(BUFFER_UID_2, Arrays.asList(BUFFER_UID_3));
        
        return ConnectionSchemeBLM.builder()
                .uid(SCHEME_UUID)
                .clientUid(clientUuid)
                .schemeJson(DEFAULT_SCHEME_JSON)
                .usedBuffers(Arrays.asList(BUFFER_UID_1, BUFFER_UID_2))
                .bufferTransitions(bufferTransitions)
                .build();
    }

    public static BufferDTO createBufferDTOWithDifferentScheme() {
        return new BufferDTO(
            BUFFER_UUID.toString(),
            UUID.randomUUID().toString(), // different scheme
            1000,
            1024,
            "message prototype"
        );
    }

    public static BufferDTO createInvalidBufferDTO() {
        return new BufferDTO(
            "invalid-uuid",
            "invalid-scheme-uuid",
            -1, // invalid max messages
            -1, // invalid max size
            null // null prototype
        );
    }
}