// BufferService.java
package com.service.buffer;

import java.util.List;
import java.util.Map;
import java.util.UUID;

import com.connection.processing.buffer.model.BufferBLM;
import com.connection.processing.buffer.model.BufferDTO;

public interface BufferService {
    BufferBLM createBuffer(UUID clientUid, BufferDTO bufferDTO);
    void addToConnectionScheme(UUID clientUid, UUID bufferUid, UUID connectionSchemeUid);

    BufferBLM getBufferByUid(UUID clientUid, UUID bufferUid);
    List<BufferBLM> getBuffersByClient(UUID clientUid);
    List<BufferBLM> getBuffersByDevice(UUID clientUid, UUID deviceUid);
    List<BufferBLM> getBuffersByConnectionScheme(UUID clientUid, UUID connectionSchemeUid);

    BufferBLM updateBuffer(UUID clientUid, UUID bufferUid, BufferDTO bufferDTO);

    void deleteBuffer(UUID clientUid, UUID bufferUid);
    void deleteBuffersByConnectionScheme(UUID clientUid, UUID connectionSchemeUid);

    boolean bufferExists(UUID clientUid, UUID bufferUid);
    Map<String, Object> getHealthStatus();
}
// FeignClientConfig.java
package com.service.buffer.config;

import org.springframework.cloud.openfeign.EnableFeignClients;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.service.buffer.client.FeignErrorDecoder;

@Configuration
@EnableFeignClients(basePackages = "com.service.buffer.client")
public class FeignClientConfig {
    
    @Bean
    public FeignErrorDecoder feignErrorDecoder() {
        return new FeignErrorDecoder();
    }
}package com.service.buffer.config;

import io.swagger.v3.oas.annotations.enums.SecuritySchemeType;
import io.swagger.v3.oas.annotations.security.SecurityScheme;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@SecurityScheme(
    name = "bearerAuth",
    type = SecuritySchemeType.HTTP,
    bearerFormat = "JWT",
    scheme = "bearer"
)
public class SwaggerConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("Buffer Service API")
                        .version("1.0")
                        .description("API для управления буферами"))
                .addSecurityItem(new SecurityRequirement().addList("bearerAuth"))
                .components(new Components()
                        .addSecuritySchemes("bearerAuth", 
                            new io.swagger.v3.oas.models.security.SecurityScheme()
                                .type(io.swagger.v3.oas.models.security.SecurityScheme.Type.HTTP)
                                .scheme("bearer")
                                .bearerFormat("JWT")));
    }
}package com.service.buffer.config;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

import java.util.UUID;

@Component
public class SecurityUtils {

    public static UUID getCurrentClientUid() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        
        if (authentication == null || !authentication.isAuthenticated()) {
            throw new SecurityException("User not authenticated");
        }

        Object principal = authentication.getPrincipal();
        
        if (principal instanceof UUID) {
            return (UUID) principal;
        } else if (principal instanceof String) {
            try {
                return UUID.fromString((String) principal);
            } catch (IllegalArgumentException e) {
                throw new SecurityException("Invalid client UID format in principal");
            }
        } else {
            throw new SecurityException("Unexpected principal type: " + principal.getClass());
        }
    }

    public static String getCurrentClientUidAsString() {
        return getCurrentClientUid().toString();
    }
}// BufferJDBCConfig.java
package com.service.buffer.config;

import java.util.Properties;
import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.atomikos.jdbc.AtomikosDataSourceBean;

@Configuration
public class BufferJDBCConfig {
    
    @Value("${app.datasource.buffer.xa-data-source-class-name:org.postgresql.xa.PGXADataSource}")
    private String xaDataSourceClassName;

    @Value("${app.datasource.buffer.xa-properties.url}")
    private String jdbcUrl;

    @Value("${app.datasource.buffer.xa-properties.user}")
    private String username;

    @Value("${app.datasource.buffer.xa-properties.password}")
    private String password;

    @Value("${app.datasource.buffer.unique-resource-name:bufferXADataSource}")
    private String uniqueResourceName;

    @Bean("BufferDataSource")
    DataSource bufferDataSource() {
        AtomikosDataSourceBean dataSource = new AtomikosDataSourceBean();
        dataSource.setUniqueResourceName(uniqueResourceName);
        dataSource.setXaDataSourceClassName(xaDataSourceClassName);
        
        Properties xaProperties = new Properties();
        xaProperties.setProperty("url", jdbcUrl);
        xaProperties.setProperty("user", username);
        xaProperties.setProperty("password", password);

        dataSource.setXaProperties(xaProperties);
        dataSource.setPoolSize(5);
        dataSource.setTestQuery("SELECT 1");

        return dataSource;
    }

    @Bean("BufferJdbcTemplate")
    NamedParameterJdbcTemplate bufferNamedParameterJdbcTemplate(
            @Qualifier("BufferDataSource") DataSource bufferDataSource) {
        return new NamedParameterJdbcTemplate(bufferDataSource);
    }
}// BufferKafkaConfig.java
package com.service.buffer.config;

import org.apache.kafka.clients.admin.NewTopic;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.config.TopicBuilder;

import com.connection.auth.events.AuthEventConstants;

@Configuration
public class BufferKafkaConfig {

    @Bean
    public NewTopic authResponsesTopic() {
        return TopicBuilder.name(AuthEventConstants.AUTH_RESPONSES_TOPIC)
                .partitions(3)
                .replicas(1)
                .build();
    }
}// TransactionConfig.java
package com.service.buffer.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.jta.JtaTransactionManager;

import com.atomikos.icatch.jta.UserTransactionManager;

import jakarta.transaction.SystemException;

@Configuration
public class TransactionConfig {

    @Bean
    public UserTransactionManager userTransactionManager() throws SystemException{
        UserTransactionManager manager = new UserTransactionManager();
        manager.setTransactionTimeout(300);
        manager.setForceShutdown(true);
        return manager;
    }

    @Bean(name = "atomicosTransactionManager")
    public JtaTransactionManager jtaTransactionManager() throws SystemException {
        JtaTransactionManager jtaTransactionManager = new JtaTransactionManager();
        jtaTransactionManager.setTransactionManager(userTransactionManager());
        jtaTransactionManager.setUserTransaction(userTransactionManager());
        return jtaTransactionManager;
    }
}// BufferRepositoryConfig.java
package com.service.buffer.config;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.connection.processing.buffer.repository.BufferRepository;
import com.connection.processing.buffer.repository.BufferRepositorySQLImpl;

@Configuration
public class BufferRepositoryConfig {
    @Bean("BufferRepository")
    BufferRepository bufferRepository(@Qualifier("BufferJdbcTemplate") NamedParameterJdbcTemplate template){
        return new BufferRepositorySQLImpl(template);
    }
}package com.service.buffer.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import com.service.buffer.client.JwtKafkaAuthenticationFilter;

import lombok.RequiredArgsConstructor;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtKafkaAuthenticationFilter jwtKafkaAuthenticationFilter;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                .csrf(csrf -> csrf.disable()) // Отключаем CSRF для API
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/swagger-ui.html").permitAll()
                        .requestMatchers("/swagger-ui/**").permitAll()
                        .requestMatchers("/api-docs/**").permitAll()
                        .requestMatchers("/webjars/**").permitAll()
                        .requestMatchers("/v3/api-docs/**").permitAll()
                        .requestMatchers("/api/buffer-service/health").permitAll()
                        .requestMatchers("/api/buffer-service/**").authenticated()
                        .anyRequest().denyAll()
                )
                .addFilterBefore(jwtKafkaAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)
                .build();
    }
}// BufferUtilsConfig.java
package com.service.buffer.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.connection.processing.buffer.converter.BufferConverter;
import com.connection.processing.buffer.validator.BufferValidator;

@Configuration
public class BufferUtilsConfig {
    @Bean("BufferConverter")
    BufferConverter bufferConverter(){
        return new BufferConverter();
    }

    @Bean("BufferValidator")
    BufferValidator bufferValidator(){
        return new BufferValidator();
    }
}// BuffersListResponse.java
package com.service.buffer.controller;

import com.connection.processing.buffer.model.BufferDTO;

import lombok.AllArgsConstructor;
import lombok.Getter;

import java.util.List;

@AllArgsConstructor
@Getter
public class BuffersListResponse {
    private final List<BufferDTO> buffers;
}// GlobalExceptionHandler.java
package com.service.buffer.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import com.connection.processing.buffer.exception.BufferNotFoundException;
import com.connection.processing.buffer.exception.BufferValidateException;

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(SecurityException.class)
    public ResponseEntity<?> handleSecurityException(SecurityException e) {
        log.warn("Security exception: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(new ErrorResponse(
                "invalid_authorization",
                "Invalid or missing authorization header"));
    }

    @ExceptionHandler(BufferNotFoundException.class)
    public ResponseEntity<?> handleBufferNotFoundException(
            BufferNotFoundException e) {
        log.warn("Buffer not found: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ErrorResponse(
                "buffer_not_found",
                "Buffer not found"));
    }

    @ExceptionHandler(BufferValidateException.class)
    public ResponseEntity<?> handleBufferValidationException(
            BufferValidateException e) {
        log.warn("Buffer validation failed: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(new ErrorResponse(
                "validation_failed",
                e.getMessage() != null ? e.getMessage() : "Invalid buffer data"));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<?> handleGenericException(Exception e) {
        log.error("Unexpected error occurred: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(new ErrorResponse(
                "internal_server_error",
                "An unexpected error occurred"));
    }
}// ErrorResponse.java
package com.service.buffer.controller;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class ErrorResponse {
    private final String error;
    private final String message;
}// HealthResponse.java
package com.service.buffer.controller;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class HealthResponse {
    private final String messaege;
}// BufferResponse.java
package com.service.buffer.controller;

import java.util.UUID;


import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class BufferResponse {
    private final UUID bufferUuid;
}// BufferController.java
package com.service.buffer.controller;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import com.connection.processing.buffer.converter.BufferConverter;
import com.connection.processing.buffer.model.BufferBLM;
import com.connection.processing.buffer.model.BufferDTO;
import com.service.buffer.BufferService;
import com.service.buffer.config.SecurityUtils;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/buffer-service")
public class BufferController {
    
    private final BufferService bufferService;
    private final BufferConverter bufferConverter;

    @PostMapping("/buffers")
    public ResponseEntity<?> createBuffer(
            @RequestBody CreateBufferRequest createRequest) {
        
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        log.info("Creating buffer for client: {}, connection scheme: {}", 
                clientUid, createRequest.getConnectionSchemeUid());
        
        // Конвертируем CreateBufferRequest в BufferDTO
        BufferDTO bufferDTO = createRequest.getBufferDTO();
        BufferBLM buffer = bufferService.createBuffer(clientUid, bufferDTO);
        
        log.info("Created buffer with uid {} for client {}", buffer.getUid(), clientUid);
        return ResponseEntity.ok(new BufferResponse(buffer.getUid()));
    }

    @GetMapping("/buffers/{bufferUid}")
    public ResponseEntity<?> getBuffer(
            @PathVariable UUID bufferUid) {
        
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        log.info("Getting buffer: {} for client: {}", bufferUid, clientUid);
        
        BufferBLM buffer = bufferService.getBuffer(authorizationHeader, bufferUid);

        log.info("Got buffer: {} for client: {}", buffer.getUid(), clientUid);
        return ResponseEntity.ok(new BufferResponse(buffer.getUid()));
    }

    @GetMapping("/buffers")
    public ResponseEntity<?> getBuffersByClient() {
        
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        log.info("Getting all buffers for client: {}", clientUid);
        
        List<BufferBLM> buffers = bufferService.getBuffersByClient(clientUid);
        List<BufferDTO> bufferDTOs = buffers.stream()
            .map(buffer -> bufferConverter.toDTO(buffer))
            .collect(Collectors.toList());

        return ResponseEntity.ok(new BuffersListResponse(bufferDTOs));
    }

    @GetMapping("/buffers/scheme/{connectionSchemeUid}")
    public ResponseEntity<?> getBuffersByConnectionScheme(
            @PathVariable UUID connectionSchemeUid) {
        
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        log.info("Getting buffers for connection scheme: {} for client: {}", connectionSchemeUid, clientUid);
        
        List<BufferBLM> buffers = bufferService.getBuffersByConnectionScheme(clientUid, connectionSchemeUid);
        List<BufferDTO> bufferDTOs = buffers.stream()
            .map(buffer -> bufferConverter.toDTO(buffer))
            .collect(Collectors.toList());

        return ResponseEntity.ok(new BuffersListResponse(bufferDTOs));
    }

    @PutMapping("/buffers/{bufferUid}")
    public ResponseEntity<?> updateBuffer(
            @PathVariable UUID bufferUid,
            @RequestBody UpdateBufferRequest updateRequest) {
        
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        log.info("Updating buffer: {} for client: {}", bufferUid, clientUid);
        
        // Конвертируем UpdateBufferRequest в BufferDTO
        BufferDTO bufferDTO = updateRequest.getBufferDTO();
        BufferBLM buffer = bufferService.updateBuffer(clientUid, bufferUid, bufferDTO);
        
        return ResponseEntity.ok(new BufferResponse(buffer.getUid()));
    }

    @DeleteMapping("/buffers/{bufferUid}")
    public ResponseEntity<?> deleteBuffer(
            @PathVariable UUID bufferUid) {
        
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        log.info("Deleting buffer: {} for client: {}", bufferUid, clientUid);
        
        bufferService.deleteBuffer(authorizationHeader, bufferUid);
        return ResponseEntity.noContent().build();
    }

    @DeleteMapping("/buffers/scheme/{connectionSchemeUid}")
    public ResponseEntity<?> deleteBuffersByConnectionScheme(
            @PathVariable UUID connectionSchemeUid) {
        
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        log.info("Deleting buffers for connection scheme: {} for client: {}", connectionSchemeUid, clientUid);
        
        bufferService.deleteBuffersByConnectionScheme(authorizationHeader, connectionSchemeUid);
        return ResponseEntity.noContent().build();
    }

    @GetMapping("/health")
    public ResponseEntity<?> healthCheck() {
        log.info("Health check - status: OK, service: buffer-service, timestamp: {}", 
                System.currentTimeMillis());

        // Предполагая, что bufferService.getHealthStatus() возвращает HealthResponse
        return ResponseEntity.ok().body(bufferService.getHealthStatus());
    }
}
// CreateBufferRequest.java
package com.service.buffer.controller;

import java.util.UUID;

import com.connection.processing.buffer.model.BufferDTO;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
@Getter
@Setter
public class CreateBufferRequest {
    private BufferDTO bufferDTO;
    private UUID connectionSchemeUid;
}// UpdateBufferRequest.java
package com.service.buffer.controller;

import java.util.UUID;

import com.connection.processing.buffer.model.BufferDTO;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
@Getter
@Setter
public class UpdateBufferRequest {
    private BufferDTO bufferDTO;
    private UUID connectionSchemeUid;
}// BufferServiceApplication.java
package com.service.buffer;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BufferServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(BufferServiceApplication.class, args);
    }
}package com.service.buffer.kafka;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

import com.connection.buffer.events.commands.GetBufferByUidCommand;
import com.connection.buffer.events.commands.GetBuffersByClientUid;
import com.connection.buffer.events.commands.GetBuffersByDeviceUid;
import com.connection.buffer.events.commands.HealthCheckCommand;
import com.connection.buffer.events.responses.GetBufferByUidResponse;
import com.connection.buffer.events.responses.GetBuffersByClientResponse;
import com.connection.buffer.events.responses.GetBuffersByDeviceResponse;
import com.connection.buffer.events.responses.HealthCheckResponse;
import com.connection.common.events.Command;
import com.service.buffer.BufferService;
import com.connection.processing.buffer.converter.BufferConverter;
import com.connection.processing.buffer.model.BufferBLM;
import com.connection.processing.buffer.model.BufferDTO;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@Component
@RequiredArgsConstructor
public class BufferCommandConsumer {

    private final BufferService bufferService;
    private final BufferConverter bufferConverter;
    private final KafkaTemplate<String, Object> kafkaTemplate;

    @KafkaListener(topics = "${app.kafka.topics.buffer-commands:buffer.commands}")
    public void handleBufferCommand(ConsumerRecord<String, Command> record) {
        try {
            Command command = record.value();
            String key = record.key();

            log.info("Received buffer command: {} with key: {}", command.getClass().getSimpleName(), key);

            if (command instanceof GetBufferByUidCommand) {
                GetBufferByUidCommand getBufferCommand = (GetBufferByUidCommand) command;
                handleGetBufferByUidCommand(getBufferCommand, key);
            } else if (command instanceof GetBuffersByClientUid) {
                GetBuffersByClientUid getBuffersCommand = (GetBuffersByClientUid) command;
                handleGetBuffersByClientCommand(getBuffersCommand, key);
            } else if (command instanceof GetBuffersByDeviceUid) {
                GetBuffersByDeviceUid getBuffersCommand = (GetBuffersByDeviceUid) command;
                handleGetBuffersByDeviceCommand(getBuffersCommand, key);
            } else if (command instanceof HealthCheckCommand) {
                HealthCheckCommand healthCommand = (HealthCheckCommand) command;
                handleHealthCheckCommand(healthCommand, key);
            } else {
                log.warn("Unknown buffer command type: {}", command.getClass().getCanonicalName());
            }

        } catch (Exception e) {
            log.error("Error processing buffer command: key={}", record.key(), e);
        }
    }

    private void handleGetBufferByUidCommand(GetBufferByUidCommand command, String key) {
        try {
            log.info("Processing GetBufferByUidCommand for buffer UID: {}", command.getBufferUid());

            BufferBLM bufferBLM = bufferService.getBufferByUid(command.getClientUid(), command.getBufferUid());
            BufferDTO bufferDTO = bufferConverter.toDTO(bufferBLM);

            GetBufferByUidResponse response = GetBufferByUidResponse.success(
                    command.getCorrelationId(),
                    bufferDTO);

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
            log.info("Successfully processed GetBufferByUidCommand for buffer: {}", command.getBufferUid());

        } catch (Exception e) {
            log.error("Error processing GetBufferByUidCommand for buffer UID: {}", command.getBufferUid(), e);

            GetBufferByUidResponse response = GetBufferByUidResponse.error(
                    command.getCorrelationId(),
                    e.getMessage());

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
        }
    }

    private void handleGetBuffersByClientCommand(GetBuffersByClientUid command, String key) {
        try {
            log.info("Processing GetBuffersByClientCommand for client UID: {}", command.getClientUid());

            List<BufferBLM> buffersBLM = bufferService.getBuffersByClient(command.getClientUid());
            List<BufferDTO> bufferDTOs = buffersBLM.stream()
                    .map(bufferConverter::toDTO)
                    .collect(Collectors.toList());

            GetBuffersByClientResponse response = GetBuffersByClientResponse.valid(
                    command.getCorrelationId(),
                    bufferDTOs);

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);

            log.info("Successfully processed GetBuffersByClientCommand for client: {}, found {} buffers",
                    command.getClientUid(), bufferDTOs.size());

        } catch (Exception e) {
            log.error("Error processing GetBuffersByClientCommand for client UID: {}", command.getClientUid(), e);

            GetBuffersByClientResponse response = GetBuffersByClientResponse.error(
                    command.getCorrelationId(),
                    e.getMessage());

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
        }
    }

    private void handleGetBuffersByDeviceCommand(GetBuffersByDeviceUid command, String key) {
        try {
            log.info("Processing GetBuffersByDeviceCommand for device UID: {}", command.getDeviceUid());

            // Этот метод нужно добавить в BufferService
            List<BufferBLM> buffersBLM = bufferService.getBuffersByDevice(command.getClientUid(), command.getDeviceUid());
            List<BufferDTO> bufferDTOs = buffersBLM.stream()
                    .map(bufferConverter::toDTO)
                    .collect(Collectors.toList());

            GetBuffersByDeviceResponse response = GetBuffersByDeviceResponse.valid(
                    command.getCorrelationId(),
                    bufferDTOs);

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);

            log.info("Successfully processed GetBuffersByDeviceCommand for device: {}, found {} buffers",
                    command.getDeviceUid(), bufferDTOs.size());

        } catch (Exception e) {
            log.error("Error processing GetBuffersByDeviceCommand for device UID: {}", command.getDeviceUid(), e);

            GetBuffersByDeviceResponse response = GetBuffersByDeviceResponse.error(
                    command.getCorrelationId(),
                    e.getMessage());

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
        }
    }

    private void handleHealthCheckCommand(HealthCheckCommand command, String key) {
        try {
            log.info("Processing HealthCheckCommand");

            var healthStatus = bufferService.getHealthStatus();

            HealthCheckResponse response = HealthCheckResponse.success(
                    command.getCorrelationId(),
                    healthStatus);

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);

            log.info("Successfully processed HealthCheckCommand");

        } catch (Exception e) {
            log.error("Error processing HealthCheckCommand", e);

            HealthCheckResponse response = HealthCheckResponse.error(
                    command.getCorrelationId(),
                    e.getMessage());

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
        }
    }
}package com.service.buffer.kafka;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Component;

import com.connection.auth.events.responses.TokenValidationResponse;
import com.connection.common.events.CommandResponse;
import com.connection.auth.events.responses.ClientUidResponse;
import com.connection.auth.events.responses.HealthCheckResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class AuthResponseConsumer {

    private final TypedAuthKafkaClient authKafkaClient;

    @KafkaListener(topics = "${app.kafka.topics.auth-responses:auth.responses}")
    public void handleAuthResponse(ConsumerRecord<String, CommandResponse> record) {
        try {
            CommandResponse message = record.value();
            String correlationId = record.key();
            
            log.info("Received auth response: correlationId={}", correlationId);
                
            if (message instanceof TokenValidationResponse) {
                TokenValidationResponse typedResponse = (TokenValidationResponse) message;
                authKafkaClient.handleResponse(correlationId, typedResponse);
            } else if (message instanceof ClientUidResponse) {
                ClientUidResponse typedResponse = (ClientUidResponse) message;
                authKafkaClient.handleResponse(correlationId, typedResponse);
            } else if (message instanceof HealthCheckResponse) {
                HealthCheckResponse typedResponse = (HealthCheckResponse) message;
                authKafkaClient.handleResponse(correlationId, typedResponse);
            } else {
                log.warn("Unknown response type for correlationId: {}", correlationId);
            }
            
        } catch (Exception e) {
            log.error("Error processing auth response: correlationId={}", record.key(), e);
        }
    }
}// TypedAuthKafkaClient.java (альтернативная версия)
package com.service.buffer.kafka;

import java.util.Date;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

import com.connection.auth.events.AuthEventConstants;
import com.connection.auth.events.AuthEventUtils;
import com.connection.auth.events.commands.ExtractClientUidCommand;
import com.connection.auth.events.commands.HealthCheckCommand;
import com.connection.auth.events.commands.ValidateTokenCommand;
import com.connection.auth.events.responses.ClientUidResponse;
import com.connection.auth.events.responses.HealthCheckResponse;
import com.connection.auth.events.responses.TokenValidationResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class TypedAuthKafkaClient {

    private final KafkaTemplate<String, Object> kafkaTemplate;
    
    // Типизированное хранилище с поддержкой разных типов ответов
    private final Map<String, PendingRequest<?>> pendingRequests = new ConcurrentHashMap<>();

    // Базовый класс для типизированных запросов
    private static class PendingRequest<T> {
        final CompletableFuture<T> future;
        final Class<T> responseType;

        PendingRequest(CompletableFuture<T> future, Class<T> responseType) {
            this.future = future;
            this.responseType = responseType;
        }
    }

    public CompletableFuture<TokenValidationResponse> validateToken(String token, String sourceService) {
        return sendRequest(
            ValidateTokenCommand.builder()
                .token(token)
                .tokenType(ValidateTokenCommand.TokenType.ACCESS)
                .sourceService(sourceService)
                .replyTopic(AuthEventConstants.AUTH_RESPONSES_TOPIC)
                .correlationId(AuthEventUtils.generateCorrelationId())
                .build(),
            TokenValidationResponse.class
        );
    }

    public CompletableFuture<ClientUidResponse> getClientUid(String token, String sourceService) {
        return sendRequest(
            ExtractClientUidCommand.builder()
                .token(token)
                .tokenType(ExtractClientUidCommand.TokenType.ACCESS)
                .sourceService(sourceService)
                .replyTopic(AuthEventConstants.AUTH_RESPONSES_TOPIC)
                .correlationId(AuthEventUtils.generateCorrelationId())
                .build(),
            ClientUidResponse.class
        );
    }

    public CompletableFuture<HealthCheckResponse> healthCheck(String sourceService) {
        return sendRequest(
            HealthCheckCommand.builder()
                .eventId(UUID.randomUUID().toString())
                .sourceService(sourceService)
                .timestamp(new Date().toInstant())
                .replyTopic(AuthEventConstants.AUTH_RESPONSES_TOPIC)
                .correlationId(AuthEventUtils.generateCorrelationId())
                .commandType(AuthEventConstants.COMMAND_HEALTH_CHECK)
                .build(),
            HealthCheckResponse.class
        );
    }

    private <T> CompletableFuture<T> sendRequest(Object command, Class<T> responseType) {
        String correlationId;
        
        // Извлекаем correlationId из команды
        if (command instanceof ValidateTokenCommand) {
            correlationId = ((ValidateTokenCommand) command).getCorrelationId();
        } else if (command instanceof ExtractClientUidCommand) {
            correlationId = ((ExtractClientUidCommand) command).getCorrelationId();
        } else if (command instanceof HealthCheckCommand) {
            correlationId = ((HealthCheckCommand) command).getCorrelationId();
        } else {
            throw new IllegalArgumentException("Unsupported command type: " + command.getClass());
        }

        CompletableFuture<T> future = new CompletableFuture<>();
        pendingRequests.put(correlationId, new PendingRequest<>(future, responseType));

        kafkaTemplate.send(AuthEventConstants.AUTH_COMMANDS_TOPIC, correlationId, command)
                .whenComplete((result, ex) -> {
                    if (ex != null) {
                        future.completeExceptionally(ex);
                        pendingRequests.remove(correlationId);
                        log.error("Failed to send command: {}", ex.getMessage());
                    }
                });

        return future;
    }

    @SuppressWarnings("unchecked")
    public void handleResponse(String correlationId, Object response) {
        PendingRequest<?> pendingRequest = pendingRequests.remove(correlationId);
        if (pendingRequest != null) {
            try {
                // Проверяем тип ответа
                if (pendingRequest.responseType.isInstance(response)) {
                    CompletableFuture<Object> future = (CompletableFuture<Object>) pendingRequest.future;
                    future.complete(response);
                } else {
                    log.warn("Type mismatch for correlationId: {}. Expected: {}, Got: {}", 
                            correlationId, pendingRequest.responseType, response.getClass());
                    pendingRequest.future.completeExceptionally(
                        new ClassCastException("Type mismatch in response")
                    );
                }
            } catch (Exception e) {
                pendingRequest.future.completeExceptionally(e);
            }
        } else {
            log.warn("Received response for unknown correlationId: {}", correlationId);
        }
    }
}package com.service.buffer.kafka;

import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;

import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

import com.connection.device.events.DeviceEventConstants;
import com.connection.device.events.DeviceEventUtils;
import com.connection.device.events.commands.GetDeviceByUidCommand;
import com.connection.device.events.commands.GetDevicesByClientUid;
import com.connection.device.events.commands.HealthCheckCommand;
import com.connection.device.events.responses.GetDeviceByUidResponse;
import com.connection.device.events.responses.GetDevicesByClientResponse;
import com.connection.device.events.responses.HealthCheckResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class TypedDeviceKafkaClient {

    private final KafkaTemplate<String, Object> kafkaTemplate;
    private final Map<String, PendingRequest<?>> pendingRequests = new ConcurrentHashMap<>();

    private static class PendingRequest<T> {
        final CompletableFuture<T> future;
        final Class<T> responseType;

        PendingRequest(CompletableFuture<T> future, Class<T> responseType) {
            this.future = future;
            this.responseType = responseType;
        }
    }

    public CompletableFuture<GetDeviceByUidResponse> getDeviceByUid(UUID deviceUid, UUID clientUid, String sourceService) {
        return sendRequest(
            GetDeviceByUidCommand.builder()
                .deviceUid(deviceUid)
                .clientUid(clientUid)
                .sourceService(sourceService)
                .replyTopic(DeviceEventConstants.DEVICE_RESPONSES_TOPIC)
                .correlationId(DeviceEventUtils.generateCorrelationId())
                .build(),
            GetDeviceByUidResponse.class
        );
    }

    public CompletableFuture<GetDevicesByClientResponse> getDevicesByClient(UUID clientUid, String sourceService) {
        return sendRequest(
            GetDevicesByClientUid.builder()
                .clientUid(clientUid)
                .sourceService(sourceService)
                .replyTopic(DeviceEventConstants.DEVICE_RESPONSES_TOPIC)
                .correlationId(DeviceEventUtils.generateCorrelationId())
                .build(),
            GetDevicesByClientResponse.class
        );
    }

    public CompletableFuture<HealthCheckResponse> healthCheck(String sourceService) {
        return sendRequest(
            HealthCheckCommand.builder()
                .sourceService(sourceService)
                .replyTopic(DeviceEventConstants.DEVICE_RESPONSES_TOPIC)
                .correlationId(DeviceEventUtils.generateCorrelationId())
                .build(),
            HealthCheckResponse.class
        );
    }

    // Вспомогательные методы для удобства
    public boolean deviceExistsAndBelongsToClient(UUID deviceUid, UUID clientUid) {
        try {
            GetDeviceByUidResponse response = getDeviceByUid(deviceUid, clientUid, "buffer-service")
                    .get(10, java.util.concurrent.TimeUnit.SECONDS);
            return response.isSuccess() && response.getDeviceDTO() != null;
        } catch (Exception e) {
            log.error("Error checking device existence: {}", e.getMessage());
            return false;
        }
    }

    public List<UUID> getClientDeviceUids(UUID clientUid) {
        try {
            GetDevicesByClientResponse response = getDevicesByClient(clientUid, "buffer-service")
                    .get(10, java.util.concurrent.TimeUnit.SECONDS);
            
            if (response.isSuccess() && response.getDeviceDTOs() != null) {
                return response.getDeviceDTOs().stream()
                        .map(device -> UUID.fromString(device.getUid()))
                        .collect(java.util.stream.Collectors.toList());
            }
            return List.of();
        } catch (Exception e) {
            log.error("Error getting client devices: {}", e.getMessage());
            return List.of();
        }
    }

    private <T> CompletableFuture<T> sendRequest(Object command, Class<T> responseType) {
        String correlationId = extractCorrelationId(command);
        
        CompletableFuture<T> future = new CompletableFuture<>();
        pendingRequests.put(correlationId, new PendingRequest<>(future, responseType));

        kafkaTemplate.send(DeviceEventConstants.DEVICE_COMMANDS_TOPIC, correlationId, command)
                .whenComplete((result, ex) -> {
                    if (ex != null) {
                        future.completeExceptionally(ex);
                        pendingRequests.remove(correlationId);
                        log.error("Failed to send device command: {}", ex.getMessage());
                    }
                });

        return future;
    }

    @SuppressWarnings("unchecked")
    public void handleResponse(String correlationId, Object response) {
        PendingRequest<?> pendingRequest = pendingRequests.remove(correlationId);
        if (pendingRequest != null) {
            try {
                if (pendingRequest.responseType.isInstance(response)) {
                    CompletableFuture<Object> future = (CompletableFuture<Object>) pendingRequest.future;
                    future.complete(response);
                } else {
                    log.warn("Type mismatch for correlationId: {}. Expected: {}, Got: {}", 
                            correlationId, pendingRequest.responseType, response.getClass());
                    pendingRequest.future.completeExceptionally(
                        new ClassCastException("Type mismatch in device response")
                    );
                }
            } catch (Exception e) {
                pendingRequest.future.completeExceptionally(e);
            }
        } else {
            log.warn("Received device response for unknown correlationId: {}", correlationId);
        }
    }

    private String extractCorrelationId(Object command) {
        // Реализация аналогичная TypedAuthKafkaClient
        if (command instanceof GetDeviceByUidCommand) {
            return ((GetDeviceByUidCommand) command).getCorrelationId();
        } else if (command instanceof GetDevicesByClientUid) {
            return ((GetDevicesByClientUid) command).getCorrelationId();
        } else if (command instanceof HealthCheckCommand) {
            return ((HealthCheckCommand) command).getCorrelationId();
        } else {
            throw new IllegalArgumentException("Unsupported device command type: " + command.getClass());
        }
    }
}package com.service.buffer.client;

import com.service.buffer.kafka.TypedAuthKafkaClient;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import com.connection.auth.events.responses.TokenValidationResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Collections;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

@Slf4j
@Component
@RequiredArgsConstructor
public class JwtKafkaAuthenticationFilter extends OncePerRequestFilter {

    private final TypedAuthKafkaClient authKafkaClient;
    private static final String AUTH_HEADER = "Authorization";
    private static final String BEARER_PREFIX = "Bearer ";

    @Override
    protected void doFilterInternal(HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain) throws ServletException, IOException {

        String authHeader = request.getHeader(AUTH_HEADER);

        if (authHeader == null || !authHeader.startsWith(BEARER_PREFIX)) {
            filterChain.doFilter(request, response);
            return;
        }

        String jwtToken = authHeader.substring(BEARER_PREFIX.length());

        try {
            authenticateWithToken(jwtToken, request);
        } catch (Exception e) {
            log.error("Authentication failed for token: {}", e.getMessage());
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            return;
        }

        filterChain.doFilter(request, response);
    }

    private void authenticateWithToken(String token, HttpServletRequest request) {
        try {
            // ОБЯЗАТЕЛЬНО обрезаем пробелы!
            String cleanToken = token.trim();
            cleanToken = cleanToken.replace("Bearer ", "");

            log.info("Validating token: {}...", cleanToken);

            CompletableFuture<TokenValidationResponse> validationFuture = authKafkaClient.validateToken(cleanToken,
                    "buffer-service");

            TokenValidationResponse validationResponse = validationFuture
                    .get(10, TimeUnit.SECONDS);

            if (!validationResponse.isValid()) {
                throw new SecurityException("Token validation failed: " + validationResponse.getError());
            }

            // Создаем аутентификацию
            UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                    validationResponse.getClientUid(),
                    null,
                    Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER")));

            authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
            SecurityContextHolder.getContext().setAuthentication(authentication);

            log.info("Successfully authenticated client: {}", validationResponse.getClientUid());

        } catch (java.util.concurrent.TimeoutException e) {
            throw new SecurityException("Token validation timeout");
        } catch (java.util.concurrent.ExecutionException e) {
            throw new SecurityException("Token validation error: " + e.getCause().getMessage());
        } catch (Exception e) {
            throw new SecurityException("Authentication failed: " + e.getMessage());
        }
    }
}package com.service.buffer;

import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.connection.auth.events.responses.HealthCheckResponse;
import com.connection.processing.buffer.converter.BufferConverter;
import com.connection.processing.buffer.exception.BufferAlreadyExistsException;
import com.connection.processing.buffer.model.BufferBLM;
import com.connection.processing.buffer.model.BufferDALM;
import com.connection.processing.buffer.model.BufferDTO;
import com.connection.processing.buffer.repository.BufferRepository;
import com.connection.processing.buffer.validator.BufferValidator;
import com.service.buffer.kafka.TypedAuthKafkaClient;
import com.service.buffer.kafka.TypedDeviceKafkaClient;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RequiredArgsConstructor
@Service
@EnableAutoConfiguration(exclude = {
        JpaRepositoriesAutoConfiguration.class
})
@Transactional("atomicosTransactionManager")
public class BufferServiceImpl implements BufferService {

    private final BufferRepository bufferRepository;
    private final BufferConverter bufferConverter;
    private final BufferValidator bufferValidator;
    private final TypedAuthKafkaClient authKafkaClient;
    private final TypedDeviceKafkaClient deviceKafkaClient;

    @Override
    public BufferBLM createBuffer(UUID clientUid, BufferBLM bufferBLM) {
        bufferValidator.validate(bufferBLM);

        // Проверяем существование и принадлежность устройства
        if (!deviceKafkaClient.deviceExistsAndBelongsToClient(bufferBLM.getDeviceUid(), clientUid)) {
            throw new SecurityException("Device doesn't exist or doesn't belong to the authenticated client");
        }

        // Проверяем, что буфер с таким именем не существует для этого устройства
        if (bufferRepository.existsByDeviceAndName(bufferBLM.getDeviceUid(), bufferBLM.getBufferName())) {
            throw new BufferAlreadyExistsException(
                    "Buffer with name '" + bufferBLM.getBufferName() + "' already exists for this device");
        }

        BufferDALM bufferDALM = bufferConverter.toDALM(bufferBLM);
        bufferRepository.add(bufferDALM);

        log.info("Buffer created: {} for device: {}", bufferBLM.getUid(), bufferBLM.getDeviceUid());
        return bufferBLM;
    }

    @Override
    public BufferBLM getBufferByUid(UUID clientUid, UUID bufferUid) {
        BufferDALM bufferDALM = bufferRepository.findByUid(bufferUid);

        // Проверяем принадлежность устройства клиенту
        if (!deviceKafkaClient.deviceExistsAndBelongsToClient(bufferDALM.getDeviceUid(), clientUid)) {
            throw new SecurityException("Buffer doesn't belong to the authenticated client");
        }

        return bufferConverter.toBLM(bufferDALM);
    }

    @Override
    public List<BufferBLM> getBuffersByClient(UUID clientUid) {
        // Получаем все устройства клиента и затем все буферы для этих устройств
        List<UUID> clientDeviceUids = deviceKafkaClient.getClientDeviceUids(clientUid);
        
        return clientDeviceUids.stream()
                .flatMap(deviceUid -> bufferRepository.findByDeviceUid(deviceUid).stream())
                .map(bufferConverter::toBLM)
                .collect(Collectors.toList());
    }

    @Override
    public List<BufferBLM> getBuffersByConnectionScheme(UUID clientUid, UUID connectionSchemeUid) {
        // Получаем буферы по схеме подключения с проверкой принадлежности
        List<BufferDALM> buffersDALM = bufferRepository.findByConnectionSchemeUid(connectionSchemeUid);
        
        return buffersDALM.stream()
                .filter(buffer -> deviceKafkaClient.deviceExistsAndBelongsToClient(buffer.getDeviceUid(), clientUid))
                .map(bufferConverter::toBLM)
                .collect(Collectors.toList());
    }

    @Override
    public BufferBLM updateBuffer(UUID clientUid, UUID bufferUid, BufferBLM bufferBLM) {
        bufferValidator.validate(bufferBLM);

        BufferDALM existingBuffer = bufferRepository.findByUid(bufferUid);
        
        // Проверяем принадлежность существующего буфера
        if (!deviceKafkaClient.deviceExistsAndBelongsToClient(existingBuffer.getDeviceUid(), clientUid)) {
            throw new SecurityException("Buffer doesn't belong to the authenticated client");
        }

        // Проверяем принадлежность нового устройства (если изменилось)
        if (!deviceKafkaClient.deviceExistsAndBelongsToClient(bufferBLM.getDeviceUid(), clientUid)) {
            throw new SecurityException("New device doesn't belong to the authenticated client");
        }

        // Проверяем, что UID не изменяется
        if (!bufferUid.equals(bufferBLM.getUid())) {
            throw new IllegalArgumentException("Cannot change buffer UID");
        }

        BufferDALM bufferDALM = bufferConverter.toDALM(bufferBLM);
        bufferRepository.update(bufferDALM);

        log.info("Buffer updated: {} for device: {}", bufferUid, bufferBLM.getDeviceUid());
        return bufferBLM;
    }

    @Override
    public void deleteBuffer(UUID clientUid, UUID bufferUid) {
        BufferDALM existingBuffer = bufferRepository.findByUid(bufferUid);
        
        if (!deviceKafkaClient.deviceExistsAndBelongsToClient(existingBuffer.getDeviceUid(), clientUid)) {
            throw new SecurityException("Buffer doesn't belong to the authenticated client");
        }

        bufferRepository.delete(bufferUid);
        log.info("Buffer deleted: {} for client: {}", bufferUid, clientUid);
    }

    @Override
    public void deleteBuffersByConnectionScheme(UUID clientUid, UUID connectionSchemeUid) {
        List<BufferDALM> buffers = bufferRepository.findByConnectionSchemeUid(connectionSchemeUid);
        
        // Фильтруем только те буферы, которые принадлежат клиенту
        List<UUID> buffersToDelete = buffers.stream()
                .filter(buffer -> deviceKafkaClient.deviceExistsAndBelongsToClient(buffer.getDeviceUid(), clientUid))
                .map(BufferDALM::getUid)
                .collect(Collectors.toList());

        buffersToDelete.forEach(bufferRepository::delete);
        log.info("Deleted {} buffers for connection scheme: {}", buffersToDelete.size(), connectionSchemeUid);
    }

    @Override
    public boolean bufferExists(UUID bufferUid) {
        return bufferRepository.exists(bufferUid);
    }

    @Override
    public Map<String, Object> getHealthStatus() {
        try {
            HealthCheckResponse authHealth = authKafkaClient.healthCheck("buffer-service")
                    .get(5, java.util.concurrent.TimeUnit.SECONDS);

            // Также проверяем здоровье device-service
            HealthCheckResponse deviceHealth = deviceKafkaClient.healthCheck("buffer-service")
                    .get(5, java.util.concurrent.TimeUnit.SECONDS);

            return Map.of(
                    "status", "OK",
                    "service", "buffer-service",
                    "timestamp", System.currentTimeMillis(),
                    "auth-service", authHealth.isSuccess() ? authHealth.getHealthStatus() : "UNAVAILABLE",
                    "device-service", deviceHealth.isSuccess() ? deviceHealth.getHealthStatus() : "UNAVAILABLE");
        } catch (Exception e) {
            log.error("Health check error: ", e);
            return Map.of(
                    "status", "DEGRADED",
                    "service", "buffer-service",
                    "timestamp", System.currentTimeMillis(),
                    "auth-service", "UNAVAILABLE",
                    "device-service", "UNAVAILABLE",
                    "error", e.getMessage());
        }
    }

    @Override
    public BufferBLM createBuffer(UUID clientUid, BufferDTO bufferDTO) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'createBuffer'");
    }

    @Override
    public List<BufferBLM> getBuffersByDevice(UUID clientUid, UUID deviceUid) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'getBuffersByDevice'");
    }

    @Override
    public BufferBLM updateBuffer(UUID clientUid, UUID bufferUid, BufferDTO bufferDTO) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'updateBuffer'");
    }

    @Override
    public boolean bufferExists(UUID clientUid, UUID bufferUid) {
        // TODO Auto-generated method stub
        throw new UnsupportedOperationException("Unimplemented method 'bufferExists'");
    }
}package com.service.buffer.mother;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import com.connection.processing.buffer.model.BufferBLM;
import com.connection.processing.buffer.model.BufferDALM;
import com.connection.processing.buffer.model.BufferDTO;
import com.connection.scheme.model.ConnectionSchemeBLM;

public class BufferObjectMother {

    public static final UUID CLIENT_UUID = UUID.fromString("123e4567-e89b-12d3-a456-426614174000");
    public static final UUID BUFFER_UUID = UUID.fromString("323e4567-e89b-12d3-a456-426614174002");
    public static final UUID SCHEME_UUID = UUID.fromString("423e4567-e89b-12d3-a456-426614174003");
    public static final String VALID_TOKEN = "valid-token-123";
    public static final String INVALID_TOKEN = "invalid-token-456";


    private static final UUID BUFFER_UID_1 = UUID.fromString("223e4567-e89b-12d3-a456-426614174002");
    private static final UUID BUFFER_UID_2 = UUID.fromString("223e4567-e89b-12d3-a456-426614174003");
    private static final UUID BUFFER_UID_3 = UUID.fromString("223e4567-e89b-12d3-a456-426614174004");
    
    private static final String DEFAULT_SCHEME_JSON = "{" +
        "\"usedBuffers\": [\"" + BUFFER_UID_1 + "\", \"" + BUFFER_UID_2 + "\"], " +
        "\"bufferTransitions\": {" +
            "\"" + BUFFER_UID_1 + "\": [\"" + BUFFER_UID_2 + "\"], " +
            "\"" + BUFFER_UID_2 + "\": [\"" + BUFFER_UID_3 + "\"]" +
        "}" +
    "}";


    public static BufferDTO createValidBufferDTO() {
        return new BufferDTO(
            BUFFER_UUID.toString(),
            SCHEME_UUID.toString(),
            1000,
            1024,
            "message prototype"
        );
    }

    public static BufferBLM createValidBufferBLM() {
        return new BufferBLM(
            BUFFER_UUID,
            SCHEME_UUID,
            1000,
            1024,
            "message prototype"
        );
    }

    public static BufferDALM createValidBufferDALM() {
        return new BufferDALM(
            BUFFER_UUID,
            SCHEME_UUID,
            1000,
            1024,
            "message prototype"
        );
    }
    public static ConnectionSchemeBLM createValidConnectionSchemeBLM() {
        Map<UUID, List<UUID>> bufferTransitions = new HashMap<>();
        bufferTransitions.put(BUFFER_UID_1, Arrays.asList(BUFFER_UID_2));
        bufferTransitions.put(BUFFER_UID_2, Arrays.asList(BUFFER_UID_3));
        
        return ConnectionSchemeBLM.builder()
                .uid(SCHEME_UUID)
                .clientUid(CLIENT_UUID)
                .schemeJson(DEFAULT_SCHEME_JSON)
                .usedBuffers(Arrays.asList(BUFFER_UID_1, BUFFER_UID_2))
                .bufferTransitions(bufferTransitions)
                .build();
    }

    public static ConnectionSchemeBLM createValidConnectionSchemeBLM(UUID clientUuid) {
        Map<UUID, List<UUID>> bufferTransitions = new HashMap<>();
        bufferTransitions.put(BUFFER_UID_1, Arrays.asList(BUFFER_UID_2));
        bufferTransitions.put(BUFFER_UID_2, Arrays.asList(BUFFER_UID_3));
        
        return ConnectionSchemeBLM.builder()
                .uid(SCHEME_UUID)
                .clientUid(clientUuid)
                .schemeJson(DEFAULT_SCHEME_JSON)
                .usedBuffers(Arrays.asList(BUFFER_UID_1, BUFFER_UID_2))
                .bufferTransitions(bufferTransitions)
                .build();
    }

    public static BufferDTO createBufferDTOWithDifferentScheme() {
        return new BufferDTO(
            BUFFER_UUID.toString(),
            UUID.randomUUID().toString(), // different scheme
            1000,
            1024,
            "message prototype"
        );
    }

    public static BufferDTO createInvalidBufferDTO() {
        return new BufferDTO(
            "invalid-uuid",
            "invalid-scheme-uuid",
            -1, // invalid max messages
            -1, // invalid max size
            null // null prototype
        );
    }
}