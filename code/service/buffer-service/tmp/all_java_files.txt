package com.service.buffer;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.connection.auth.events.responses.HealthCheckResponse;
import com.connection.device.converter.DeviceConverter;
import com.connection.device.events.responses.GetDevicesByClientResponse;
import com.connection.device.model.DeviceBLM;
import com.connection.device.model.DeviceDTO;
import com.connection.processing.buffer.converter.BufferConverter;
import com.connection.processing.buffer.exception.BufferAlreadyExistsException;
import com.connection.processing.buffer.model.BufferBLM;
import com.connection.processing.buffer.model.BufferDTO;
import com.connection.processing.buffer.repository.BufferRepository;
import com.connection.processing.buffer.validator.BufferValidator;
import com.service.buffer.config.SecurityUtils;
import com.service.buffer.kafka.TypedAuthKafkaClient;
import com.service.buffer.kafka.TypedConnectionSchemeKafkaClient;
import com.service.buffer.kafka.TypedDeviceKafkaClient;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RequiredArgsConstructor
@Service("ApiBufferService")
@EnableAutoConfiguration(exclude = {
        JpaRepositoriesAutoConfiguration.class
})
@Transactional("atomicosTransactionManager")
public class ApiBufferServiceImpl implements BufferService {

    private final BufferRepository bufferRepository;
    private final BufferConverter bufferConverter;
    private final BufferValidator bufferValidator;

    private final DeviceConverter deviceConverter;

    private final TypedAuthKafkaClient authKafkaClient;
    private final TypedDeviceKafkaClient deviceKafkaClient;
    private final TypedConnectionSchemeKafkaClient connectionSchemeKafkaClient;

    @Override
    public BufferBLM createBuffer(BufferDTO bufferDTO) {
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        bufferValidator.validate(bufferDTO);

        BufferBLM bufferBLM = bufferConverter.toBLM(bufferDTO);

        if (!deviceKafkaClient.deviceExistsAndBelongsToClient(bufferBLM.getDeviceUid(), clientUid)) {
            throw new SecurityException("Device doesn't exist or doesn't belong to the authenticated client");
        }

        if (bufferRepository.exists(bufferBLM.getUid())) {
            throw new BufferAlreadyExistsException(
                    "Buffer with UID '" + bufferBLM.getUid() + "' already exists");
        }
        bufferRepository.add(bufferBLM);

        log.info("Buffer created: {} for device: {}", bufferBLM.getUid(), bufferBLM.getDeviceUid());
        return bufferBLM;
    }

    @Override
    public BufferBLM getBufferByUid(UUID bufferUid) {
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        BufferBLM bufferBLM = bufferRepository.findByUid(bufferUid);

        if (!deviceKafkaClient.deviceExistsAndBelongsToClient(bufferBLM.getDeviceUid(), clientUid)) {
            throw new SecurityException("Buffer doesn't exist or doesn't belong to the authenticated client");
        }

        return bufferBLM;
    }

    @Override
    public List<BufferBLM> getBuffersByClient(UUID clientUid) {
        UUID currentClientUid = SecurityUtils.getCurrentClientUid();
        if (!currentClientUid.equals(clientUid)) {
            throw new SecurityException("Access denied to client buffers");
        }

        try {
            GetDevicesByClientResponse devicesResponse = deviceKafkaClient
                    .getDevicesByClient(clientUid, "buffer-service")
                    .get(5, java.util.concurrent.TimeUnit.SECONDS);

            if (!devicesResponse.isSuccess() || devicesResponse.getDeviceDTOs() == null) {
                log.warn("Failed to get devices for client: {}", clientUid);
                return List.of();
            }

            List<DeviceDTO> deviceDTOs = devicesResponse.getDeviceDTOs();
            List<DeviceBLM> deviceBLMs = deviceDTOs.stream()
                    .map(deviceConverter::toBLM)
                    .collect(Collectors.toList());

            List<BufferBLM> bufferBlms = new ArrayList<>();
            for (DeviceBLM device : deviceBLMs) {
                try {
                    List<BufferBLM> deviceBuffers = getBuffersByDevice(device.getUid());
                    bufferBlms.addAll(deviceBuffers);
                } catch (Exception e) {
                    log.error("Error getting buffers for device: {}", device.getUid(), e);
                }
            }
            return bufferBlms;

        } catch (java.util.concurrent.TimeoutException e) {
            log.error("Timeout getting devices for client: {}", clientUid, e);
            throw new RuntimeException("Device service timeout", e);
        } catch (java.util.concurrent.ExecutionException e) {
            log.error("Error getting devices for client: {}", clientUid, e);
            throw new RuntimeException("Device service error", e);
        } catch (Exception e) {
            log.error("Unexpected error getting buffers for client: {}", clientUid, e);
            throw new RuntimeException("Unexpected error", e);
        }
    }

    @Override
    public List<BufferBLM> getBuffersByDevice(UUID deviceUid) {
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        if (!deviceKafkaClient.deviceExistsAndBelongsToClient(deviceUid, clientUid)) {
            throw new SecurityException("Device doesn't belong to the authenticated client");
        }

        List<BufferBLM> bufferBLMs = bufferRepository.findByDeviceUid(deviceUid);
        return bufferBLMs;
    }

    @Override
    public List<BufferBLM> getBuffersByConnectionScheme(UUID connectionSchemeUid) {
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        if (!connectionSchemeKafkaClient.connectionSchemeExistsAndBelongsToClient(connectionSchemeUid, clientUid)) {
            throw new SecurityException("Connection scheme doesn't belong to the authenticated client");
        }

        List<BufferBLM> buffersBLM = bufferRepository.findByConnectionSchemeUid(connectionSchemeUid);
        return buffersBLM;
    }

    @Override
    public BufferBLM updateBuffer(UUID bufferUid, BufferDTO bufferDTO) {
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        bufferValidator.validate(bufferDTO);

        BufferBLM existingBuffer = bufferRepository.findByUid(bufferUid);

        if (!deviceKafkaClient.deviceExistsAndBelongsToClient(existingBuffer.getDeviceUid(), clientUid)) {
            throw new SecurityException("Buffer doesn't exist or doesn't belong to the authenticated client");
        }

        BufferBLM bufferBLM = bufferConverter.toBLM(bufferDTO);

        if (!deviceKafkaClient.deviceExistsAndBelongsToClient(bufferBLM.getDeviceUid(), clientUid)) {
            throw new SecurityException("New device doesn't belong to the authenticated client");
        }

        if (!bufferUid.equals(bufferBLM.getUid())) {
            throw new IllegalArgumentException("Cannot change buffer UID");
        }

        bufferRepository.update(bufferBLM);

        log.info("Buffer updated: {} for device: {}", bufferUid, bufferBLM.getDeviceUid());
        return bufferBLM;
    }

    @Override
    public void deleteBuffer(UUID bufferUid) {
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        BufferBLM existingBuffer = bufferRepository.findByUid(bufferUid);

        if (!deviceKafkaClient.deviceExistsAndBelongsToClient(existingBuffer.getDeviceUid(), clientUid)) {
            throw new SecurityException("Buffer doesn't exist or doesn't belong to the authenticated client");
        }

        bufferRepository.delete(bufferUid);
        log.info("Buffer deleted: {} for client: {}, device: {}", bufferUid, clientUid, existingBuffer.getDeviceUid());
    }

    @Override
    public boolean bufferExists(UUID bufferUid) {
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        if (!bufferRepository.exists(bufferUid)) {
            return false;
        }

        try {
            BufferBLM buffer = bufferRepository.findByUid(bufferUid);
            return deviceKafkaClient.deviceExistsAndBelongsToClient(buffer.getDeviceUid(), clientUid);
        } catch (Exception e) {
            return false;
        }
    }

    @Override
    public Map<String, Object> getHealthStatus() {
        try {
            HealthCheckResponse authHealth = authKafkaClient
                    .healthCheck("buffer-service")
                    .get(5, java.util.concurrent.TimeUnit.SECONDS);

            com.connection.device.events.responses.HealthCheckResponse deviceHealth = deviceKafkaClient
                    .healthCheck("buffer-service")
                    .get(5, java.util.concurrent.TimeUnit.SECONDS);

            com.connection.scheme.events.responses.HealthCheckResponse connectionSchemeHealth = connectionSchemeKafkaClient
                    .healthCheck("buffer-service")
                    .get(5, java.util.concurrent.TimeUnit.SECONDS);

            return Map.of(
                    "status", "OK",
                    "service", "buffer-service",
                    "timestamp", System.currentTimeMillis(),
                    "auth-service", authHealth.isSuccess() ? "AVAILABLE" : "UNAVAILABLE",
                    "device-service", deviceHealth.isSuccess() ? "AVAILABLE" : "UNAVAILABLE",
                    "connection-scheme-service", connectionSchemeHealth.isSuccess() ? "AVAILABLE" : "UNAVAILABLE",
                    "database", "CONNECTED");

        } catch (Exception e) {
            log.error("Health check error: ", e);
            return Map.of(
                    "status", "DEGRADED",
                    "service", "buffer-service",
                    "timestamp", System.currentTimeMillis(),
                    "auth-service", "UNAVAILABLE",
                    "device-service", "UNAVAILABLE",
                    "connection-scheme-service", "UNAVAILABLE",
                    "database", "CONNECTED",
                    "error", e.getMessage());
        }
    }

    @Override
    public void deleteBufferFromConnectionScheme(UUID connectionSchemeUid, UUID bufferUid) {
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        if (!connectionSchemeKafkaClient.connectionSchemeExistsAndBelongsToClient(connectionSchemeUid, clientUid)) {
            throw new SecurityException("Connection scheme doesn't belong to the authenticated client");
        }

        List<BufferBLM> buffers = getBuffersByConnectionScheme(connectionSchemeUid);
        for (BufferBLM b : buffers) {
            bufferRepository.removeBufferFromConnectionScheme(b.getUid(), connectionSchemeUid);
        }

        log.info("Deleted buffers for connection scheme: {}", connectionSchemeUid);
    }

    @Override
    public void deleteAllBuffersFromConnectionScheme(UUID connectionSchemeUid) {
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        if (!connectionSchemeKafkaClient.connectionSchemeExistsAndBelongsToClient(connectionSchemeUid, clientUid)) {
            throw new SecurityException("Connection scheme doesn't belong to the authenticated client");
        }

        List<BufferBLM> buffers = getBuffersByConnectionScheme(connectionSchemeUid);
        for (BufferBLM b : buffers) {
            bufferRepository.removeBufferFromConnectionScheme(b.getUid(), connectionSchemeUid);
        }

        log.info("Deleted buffers for connection scheme: {}", connectionSchemeUid);
    }
}package com.service.buffer;

import java.util.List;
import java.util.Map;
import java.util.UUID;

import com.connection.processing.buffer.model.BufferBLM;
import com.connection.processing.buffer.model.BufferDTO;

public interface BufferService {
    BufferBLM createBuffer(BufferDTO bufferDTO);
    BufferBLM getBufferByUid(UUID bufferUid);
    List<BufferBLM> getBuffersByClient(UUID clientUid);
    List<BufferBLM> getBuffersByDevice(UUID deviceUid);
    List<BufferBLM> getBuffersByConnectionScheme(UUID connectionSchemeUid);
    BufferBLM updateBuffer(UUID bufferUid, BufferDTO bufferDTO);
    void deleteBuffer(UUID bufferUid);
    void deleteBufferFromConnectionScheme(UUID connectionSchemeUid, UUID bufferUid);
    void deleteAllBuffersFromConnectionScheme(UUID connectionSchemeUid);
    boolean bufferExists(UUID bufferUid);
    Map<String, Object> getHealthStatus();
}package com.service.buffer.config;

import io.swagger.v3.oas.annotations.enums.SecuritySchemeType;
import io.swagger.v3.oas.annotations.security.SecurityScheme;
import io.swagger.v3.oas.models.OpenAPI;
import io.swagger.v3.oas.models.info.Info;
import io.swagger.v3.oas.models.Components;
import io.swagger.v3.oas.models.security.SecurityRequirement;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@SecurityScheme(
    name = "bearerAuth",
    type = SecuritySchemeType.HTTP,
    bearerFormat = "JWT",
    scheme = "bearer"
)
public class SwaggerConfig {

    @Bean
    public OpenAPI customOpenAPI() {
        return new OpenAPI()
                .info(new Info()
                        .title("Buffer Service API")
                        .version("1.0")
                        .description("API для управления буферами"))
                .addSecurityItem(new SecurityRequirement().addList("bearerAuth"))
                .components(new Components()
                        .addSecuritySchemes("bearerAuth", 
                            new io.swagger.v3.oas.models.security.SecurityScheme()
                                .type(io.swagger.v3.oas.models.security.SecurityScheme.Type.HTTP)
                                .scheme("bearer")
                                .bearerFormat("JWT")));
    }
}package com.service.buffer.config;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;

import java.util.UUID;

@Component
public class SecurityUtils {

    public static UUID getCurrentClientUid() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        
        if (authentication == null || !authentication.isAuthenticated()) {
            throw new SecurityException("User not authenticated");
        }

        Object principal = authentication.getPrincipal();
        
        if (principal instanceof UUID) {
            return (UUID) principal;
        } else if (principal instanceof String) {
            try {
                return UUID.fromString((String) principal);
            } catch (IllegalArgumentException e) {
                throw new SecurityException("Invalid client UID format in principal");
            }
        } else {
            throw new SecurityException("Unexpected principal type: " + principal.getClass());
        }
    }

    public static String getCurrentClientUidAsString() {
        return getCurrentClientUid().toString();
    }
}// BufferJDBCConfig.java
package com.service.buffer.config;

import java.util.Properties;
import javax.sql.DataSource;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.atomikos.jdbc.AtomikosDataSourceBean;

import lombok.extern.slf4j.Slf4j;

@Configuration
@Slf4j
public class BufferJDBCConfig {
    
    @Value("${app.datasource.buffer.xa-data-source-class-name:org.postgresql.xa.PGXADataSource}")
    private String xaDataSourceClassName;

    @Value("${app.datasource.buffer.xa-properties.url}")
    private String jdbcUrl;

    @Value("${app.datasource.buffer.xa-properties.user}")
    private String username;

    @Value("${app.datasource.buffer.xa-properties.password}")
    private String password;

    @Value("${app.datasource.buffer.unique-resource-name:bufferXADataSource}")
    private String uniqueResourceName;

    @Bean("BufferDataSource")
    DataSource bufferDataSource() {
        log.info("url: " + jdbcUrl);
        log.info("user: " + username);
        log.info("password: " + password);

        AtomikosDataSourceBean dataSource = new AtomikosDataSourceBean();
        dataSource.setUniqueResourceName(uniqueResourceName);
        dataSource.setXaDataSourceClassName(xaDataSourceClassName);
        
        Properties xaProperties = new Properties();
        xaProperties.setProperty("url", jdbcUrl);
        xaProperties.setProperty("user", username);
        xaProperties.setProperty("password", password);

        dataSource.setXaProperties(xaProperties);
        dataSource.setPoolSize(5);
        dataSource.setTestQuery("SELECT 1");

        return dataSource;
    }

    @Bean("BufferJdbcTemplate")
    NamedParameterJdbcTemplate bufferNamedParameterJdbcTemplate(
            @Qualifier("BufferDataSource") DataSource bufferDataSource) {
        return new NamedParameterJdbcTemplate(bufferDataSource);
    }
}// BufferKafkaConfig.java
package com.service.buffer.config;

import java.util.HashMap;
import java.util.Map;

import org.apache.kafka.clients.consumer.ConsumerConfig;
import org.apache.kafka.clients.producer.ProducerConfig;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.core.ConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaConsumerFactory;
import org.springframework.kafka.core.DefaultKafkaProducerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.core.ProducerFactory;
import org.springframework.kafka.listener.DefaultErrorHandler;
import org.springframework.kafka.support.serializer.ErrorHandlingDeserializer;
import org.springframework.kafka.support.serializer.JsonDeserializer;
import org.springframework.kafka.support.serializer.JsonSerializer;
import org.springframework.util.backoff.FixedBackOff;

@Configuration
public class BufferKafkaConfig {
    @Value("${spring.kafka.bootstrap-servers:localhost:29092}")
    private String bootstrapServers;

    // Конфигурация для Consumer с обработкой ошибок десериализации
    @Bean
    public ConsumerFactory<String, Object> consumerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        configProps.put(ConsumerConfig.GROUP_ID_CONFIG, "buffer-service-group");
        configProps.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");
        configProps.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer.class);
        configProps.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, ErrorHandlingDeserializer.class);
        // Конфигурация для JsonDeserializer
        configProps.put(JsonDeserializer.TRUSTED_PACKAGES,
                "com.connection.auth.events.commands," +
                        "com.connection.auth.events.responses," +
                        "com.connection.common.events," +
                        "com.connection.buffer.events.commands," +
                        "com.connection.buffer.events.responses," +
                        "com.connection.device.events.commands," +
                        "com.connection.device.events.responses," +
                        "com.connection.scheme.events.commands," +
                        "com.connection.scheme.events.responses");
        // Конфигурация для ErrorHandlingDeserializer
        configProps.put(ErrorHandlingDeserializer.KEY_DESERIALIZER_CLASS,
                org.apache.kafka.common.serialization.StringDeserializer.class);
        configProps.put(ErrorHandlingDeserializer.VALUE_DESERIALIZER_CLASS, JsonDeserializer.class);


        configProps.put(JsonDeserializer.USE_TYPE_INFO_HEADERS, true);
        configProps.put(JsonDeserializer.REMOVE_TYPE_INFO_HEADERS, false);
        configProps.put(JsonDeserializer.VALUE_DEFAULT_TYPE, "com.connection.common.events.Command");

        return new DefaultKafkaConsumerFactory<>(configProps);
    }

    @Bean
    public ConcurrentKafkaListenerContainerFactory<String, Object> kafkaListenerContainerFactory() {
        ConcurrentKafkaListenerContainerFactory<String, Object> factory = new ConcurrentKafkaListenerContainerFactory<>();
        factory.setConsumerFactory(consumerFactory());

        // Обработка ошибок десериализации - пропускаем некорректные сообщения
        DefaultErrorHandler errorHandler = new DefaultErrorHandler(
                (record, exception) -> {
                    org.slf4j.Logger logger = org.slf4j.LoggerFactory.getLogger("KafkaErrorHandler");
                    logger.error(
                            "Skipping invalid message - Topic: {}, Partition: {}, Offset: {}, Key: {}, Error: {}, {}",
                            record.topic(),
                            record.partition(),
                            record.offset(),
                            record.key(),
                            exception.getMessage(),
                            exception.toString());
                },
                new FixedBackOff(0L, 0L));

        factory.setCommonErrorHandler(errorHandler);

        return factory;
    }

    // Конфигурация для Producer
    @Bean
    public ProducerFactory<String, Object> producerFactory() {
        Map<String, Object> configProps = new HashMap<>();
        configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, bootstrapServers);
        configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG,
                org.apache.kafka.common.serialization.StringSerializer.class);
        configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);
        configProps.put(JsonSerializer.ADD_TYPE_INFO_HEADERS, true);
        return new DefaultKafkaProducerFactory<>(configProps);
    }

    @Bean
    public KafkaTemplate<String, Object> kafkaTemplate() {
        return new KafkaTemplate<>(producerFactory());
    }
}package com.service.buffer.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.connection.device.converter.DeviceConverter;

@Configuration
public class DeviceUtilsConfig {
    @Bean
    DeviceConverter deviceConverter(){
        return new DeviceConverter();
    }
}
// TransactionConfig.java
package com.service.buffer.config;

import java.util.UUID;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.transaction.jta.JtaTransactionManager;

import com.atomikos.icatch.jta.UserTransactionManager;

import jakarta.transaction.SystemException;

@Configuration
public class TransactionConfig {

    @Bean
    public UserTransactionManager userTransactionManager() throws SystemException{
        UserTransactionManager manager = new UserTransactionManager();
        setPropertyIfNotExists("com.atomikos.icatch.log_base_name", "atomikos-tm-" + UUID.randomUUID().toString().substring(0, 8));
        setPropertyIfNotExists("com.atomikos.icatch.log_base_dir", "./logs");
        setPropertyIfNotExists("com.atomikos.icatch.tm_unique_name", "tm-" + UUID.randomUUID().toString().substring(0, 8));

        manager.setTransactionTimeout(300);
        manager.setForceShutdown(true);
        return manager;
    }

    @Bean(name = "atomicosTransactionManager")
    public JtaTransactionManager jtaTransactionManager() throws SystemException {
        JtaTransactionManager jtaTransactionManager = new JtaTransactionManager();
        jtaTransactionManager.setTransactionManager(userTransactionManager());
        jtaTransactionManager.setUserTransaction(userTransactionManager());
        return jtaTransactionManager;
    }
    /**
     * Устанавливает системное свойство только если оно еще не было установлено
     * @param key ключ свойства
     * @param value значение свойства
     */
    private void setPropertyIfNotExists(String key, String value) {
        if (System.getProperty(key) == null) {
            System.setProperty(key, value);
            System.out.println("Set property: " + key + " = " + value);
        } else {
            System.out.println("Property already set: " + key + " = " + System.getProperty(key));
        }
    }
}// BufferRepositoryConfig.java
package com.service.buffer.config;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;

import com.connection.processing.buffer.repository.BufferRepository;
import com.connection.processing.buffer.repository.BufferRepositorySQLImpl;

@Configuration
public class BufferRepositoryConfig {
    @Bean("BufferRepository")
    BufferRepository bufferRepository(@Qualifier("BufferJdbcTemplate") NamedParameterJdbcTemplate template){
        return new BufferRepositorySQLImpl(template);
    }
}package com.service.buffer.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import com.service.buffer.client.JwtKafkaAuthenticationFilter;

import lombok.RequiredArgsConstructor;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
@RequiredArgsConstructor
public class SecurityConfig {

    private final JwtKafkaAuthenticationFilter jwtKafkaAuthenticationFilter;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        return http
                .csrf(csrf -> csrf.disable()) // Отключаем CSRF для API
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers("/swagger-ui.html").permitAll()
                        .requestMatchers("/swagger-ui/**").permitAll()
                        .requestMatchers("/api-docs/**").permitAll()
                        .requestMatchers("/webjars/**").permitAll()
                        .requestMatchers("/v3/api-docs/**").permitAll()
                        .requestMatchers("/api/v1/health").permitAll()
                        .requestMatchers("/api/v1/**").authenticated()
                        .anyRequest().denyAll()
                )
                .addFilterBefore(jwtKafkaAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)
                .build();
    }
}// BufferUtilsConfig.java
package com.service.buffer.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import com.connection.processing.buffer.converter.BufferConverter;
import com.connection.processing.buffer.validator.BufferValidator;

@Configuration
public class BufferUtilsConfig {
    @Bean("BufferConverter")
    BufferConverter bufferConverter(){
        return new BufferConverter();
    }

    @Bean("BufferValidator")
    BufferValidator bufferValidator(){
        return new BufferValidator();
    }
}// BuffersListResponse.java
package com.service.buffer.controller;

import com.connection.processing.buffer.model.BufferDTO;

import lombok.AllArgsConstructor;
import lombok.Getter;

import java.util.List;

@AllArgsConstructor
@Getter
public class BuffersListResponse {
    private final List<BufferDTO> buffers;
    private final PaginationInfo pagination;

    @AllArgsConstructor
    @Getter
    public static class PaginationInfo {
        private final int offset;
        private final int limit;
        private final int totalCount;
        private final boolean hasMore;
    }

    // Конструктор для обратной совместимости
    public BuffersListResponse(List<BufferDTO> buffers) {
        this.buffers = buffers;
        this.pagination = null;
    }
}// GlobalExceptionHandler.java
package com.service.buffer.controller;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import com.connection.processing.buffer.exception.BufferNotFoundException;
import com.connection.processing.buffer.exception.BufferValidateException;

@Slf4j
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(SecurityException.class)
    public ResponseEntity<?> handleSecurityException(SecurityException e) {
        log.warn("Security exception: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(new ErrorResponse(
                "invalid_authorization",
                "Invalid or missing authorization header"));
    }

    @ExceptionHandler(BufferNotFoundException.class)
    public ResponseEntity<?> handleBufferNotFoundException(
            BufferNotFoundException e) {
        log.warn("Buffer not found: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(new ErrorResponse(
                "buffer_not_found",
                "Buffer not found"));
    }

    @ExceptionHandler(BufferValidateException.class)
    public ResponseEntity<?> handleBufferValidationException(
            BufferValidateException e) {
        log.warn("Buffer validation failed: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(new ErrorResponse(
                "validation_failed",
                e.getMessage() != null ? e.getMessage() : "Invalid buffer data"));
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<?> handleGenericException(Exception e) {
        log.error("Unexpected error occurred: {}", e.getMessage());
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(new ErrorResponse(
                "internal_server_error",
                "An unexpected error occurred"));
    }
}// ErrorResponse.java
package com.service.buffer.controller;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class ErrorResponse {
    private final String error;
    private final String message;
}// HealthResponse.java
package com.service.buffer.controller;

import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class HealthResponse {
    private final String messaege;
}// BufferResponse.java
package com.service.buffer.controller;

import java.util.UUID;


import lombok.AllArgsConstructor;
import lombok.Getter;

@AllArgsConstructor
@Getter
public class BufferResponse {
    private final UUID bufferUuid;
}package com.service.buffer.controller;

import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.DeleteMapping;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import com.connection.processing.buffer.converter.BufferConverter;
import com.connection.processing.buffer.model.BufferBLM;
import com.connection.processing.buffer.model.BufferDTO;
import com.connection.processing.buffer.validator.BufferValidator;
import com.service.buffer.BufferService;
import com.service.buffer.config.SecurityUtils;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/v1")
public class BufferController {

    @Qualifier("ApiBufferService")
    private final BufferService bufferService;
    private final BufferValidator bufferValidator;
    private final BufferConverter bufferConverter;

    // Константы для пагинации по умолчанию
    private static final int DEFAULT_OFFSET = 0;
    private static final int DEFAULT_LIMIT = 50;
    private static final int MAX_LIMIT = 1000;

    @PostMapping("/buffers")
    public ResponseEntity<BufferResponse> createBuffer(@RequestBody BufferDTO bufferDTO) {
        bufferValidator.validate(bufferDTO);
        BufferBLM buffer = bufferService.createBuffer(bufferDTO);

        return ResponseEntity.ok(new BufferResponse(buffer.getUid()));
    }

    @GetMapping("/buffers")
    public ResponseEntity<BuffersListResponse> getBuffers(
            @RequestParam(required = false) List<UUID> bufferUids,
            @RequestParam(required = false) UUID deviceUid,
            @RequestParam(required = false) UUID connectionSchemeUid,
            @RequestParam(defaultValue = "" + DEFAULT_OFFSET) int offset,
            @RequestParam(defaultValue = "" + DEFAULT_LIMIT) int limit) {
        
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        List<BufferBLM> buffers;

        if (deviceUid != null) {
            log.info("Getting buffers for device: {} with offset: {}, limit: {}", deviceUid, offset, limit);
            buffers = bufferService.getBuffersByDevice(deviceUid);
        } else if (connectionSchemeUid != null) {
            log.info("Getting buffers for connection scheme: {} with offset: {}, limit: {}", 
                    connectionSchemeUid, offset, limit);
            buffers = bufferService.getBuffersByConnectionScheme(connectionSchemeUid);
        } else {
            log.info("Getting all buffers for client with offset: {}, limit: {}", offset, limit);
            buffers = bufferService.getBuffersByClient(clientUid);
        }
        BuffersListResponse.PaginationInfo paginationInfo = 
            new BuffersListResponse.PaginationInfo(
                offset, 
                limit, 
                buffers.size(), 
                (offset + limit) < buffers.size()
            );
        // Применяем пагинацию
        List<BufferDTO> bufferDTOs = applyPagination(buffers, offset, limit)
                .stream()
                .map(bufferConverter::toDTO)
                .collect(Collectors.toList());

        return ResponseEntity.ok(new BuffersListResponse(bufferDTOs, paginationInfo));
    }
    @PatchMapping("/buffers/{bufferUid}")
    public ResponseEntity<BufferResponse> partialUpdateBuffer(
            @PathVariable UUID bufferUid,
            @RequestBody PartialBufferUpdateRequest updateRequest) {
        
        UUID clientUid = SecurityUtils.getCurrentClientUid();
        log.info("Partial update buffer: {} for client: {}", bufferUid, clientUid);
        
        // Временная реализация - получаем текущий буфер и возвращаем его
        BufferBLM buffer = bufferService.getBufferByUid(bufferUid);
        buffer.setMaxMessageSize(updateRequest.maxSize);
        buffer.setMaxMessagesNumber(updateRequest.maxMessages);
        
        bufferValidator.validate(buffer);

        bufferService.updateBuffer(bufferUid, bufferConverter.toDTO(buffer));
        
        return ResponseEntity.ok(new BufferResponse(buffer.getUid()));
    }


    @PutMapping("/buffers/{bufferUid}")
    public ResponseEntity<BufferResponse> updateBuffer(
            @PathVariable UUID bufferUid,
            @RequestBody BufferDTO bufferDTO) {

        UUID clientUid = SecurityUtils.getCurrentClientUid();
        log.info("Updating buffer: {} for client: {}", bufferUid, clientUid);

        bufferValidator.validate(bufferDTO);
        BufferBLM buffer = bufferService.updateBuffer(bufferUid, bufferDTO);

        return ResponseEntity.ok(new BufferResponse(buffer.getUid()));
    }

    @DeleteMapping("/buffers")
    public ResponseEntity<Void> deleteBuffers(
            @RequestParam List<UUID> bufferUids) {
        
        for (UUID b : bufferUids){
            bufferService.deleteBuffer(b);
        }
        return ResponseEntity.noContent().build();
    }


    @GetMapping("/health")
    public ResponseEntity<HealthResponse> healthCheck() {
        log.info("Health check: status: OK, service: buffer-service, timestamp: {}",
                System.currentTimeMillis());

        return ResponseEntity.ok().body(new HealthResponse(bufferService.getHealthStatus().toString()));
    }

    /**
     * Применяет пагинацию к списку буферов
     * 
     * @param buffers полный список буферов
     * @param offset смещение (начальная позиция)
     * @param limit максимальное количество элементов
     * @return пагинированный список буферов
     */
    private List<BufferBLM> applyPagination(List<BufferBLM> buffers, int offset, int limit) {
        // Валидация параметров пагинации
        if (offset < 0) {
            offset = DEFAULT_OFFSET;
        }
        
        if (limit <= 0 || limit > MAX_LIMIT) {
            limit = DEFAULT_LIMIT;
        }
        
        // Применяем пагинацию
        return buffers.stream()
                .skip(offset)
                .limit(limit)
                .collect(Collectors.toList());
    }
        public static class PartialBufferUpdateRequest {
        private Integer maxMessages;
        private Integer maxSize;

        // Getters and Setters
        public Integer getMaxMessages() {
            return maxMessages;
        }

        public void setMaxMessages(Integer maxMessages) {
            this.maxMessages = maxMessages;
        }

        public Integer getMaxSize() {
            return maxSize;
        }

        public void setMaxSize(Integer maxSize) {
            this.maxSize = maxSize;
        }

    }
}// CreateBufferRequest.java
package com.service.buffer.controller;

import java.util.UUID;

import com.connection.processing.buffer.model.BufferDTO;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
@Getter
@Setter
public class CreateBufferRequest {
    private BufferDTO bufferDTO;
    private UUID connectionSchemeUid;
}// UpdateBufferRequest.java
package com.service.buffer.controller;

import java.util.UUID;

import com.connection.processing.buffer.model.BufferDTO;

import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;

@AllArgsConstructor
@Getter
@Setter
public class UpdateBufferRequest {
    private BufferDTO bufferDTO;
    private UUID connectionSchemeUid;
}// BufferServiceApplication.java
package com.service.buffer;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class BufferServiceApplication {

    public static void main(String[] args) {
        SpringApplication.run(BufferServiceApplication.class, args);
    }
}// BufferCommandConsumer.java
package com.service.buffer.kafka;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

import com.connection.buffer.events.commands.GetBufferByUidCommand;
import com.connection.buffer.events.commands.GetBuffersByClientUidCommand;
import com.connection.buffer.events.commands.GetBuffersByConnectionSchemeUidCommand;
import com.connection.buffer.events.commands.GetBuffersByDeviceUidCommand;
import com.connection.buffer.events.commands.HealthCheckCommand;
import com.connection.buffer.events.responses.GetBufferByUidResponse;
import com.connection.buffer.events.responses.GetBuffersByClientResponse;
import com.connection.buffer.events.responses.GetBuffersByConnectionSchemeResponse;
import com.connection.buffer.events.responses.GetBuffersByDeviceResponse;
import com.connection.buffer.events.responses.HealthCheckResponse;
import com.connection.common.events.Command;
import com.service.buffer.BufferService;
import com.connection.processing.buffer.converter.BufferConverter;
import com.connection.processing.buffer.model.BufferBLM;
import com.connection.processing.buffer.model.BufferDTO;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.stream.Collectors;

@Slf4j
@Component
@RequiredArgsConstructor
public class BufferCommandConsumer {

    @Qualifier("KafkaBufferService")
    private final BufferService bufferService;
    private final BufferConverter bufferConverter;
    private final KafkaTemplate<String, Object> kafkaTemplate;

    @KafkaListener(topics = "${app.kafka.topics.buffer-commands:buffer.commands}")
    public void handleBufferCommand(ConsumerRecord<String, Command> record) {
        try {
            Command command = record.value();
            String key = record.key();

            log.info("Received buffer command: {} with key: {}", command.getClass().getSimpleName(), key);

            if (command instanceof GetBufferByUidCommand) {
                GetBufferByUidCommand getBufferCommand = (GetBufferByUidCommand) command;
                handleGetBufferByUidCommand(getBufferCommand, key);
            } else if (command instanceof GetBuffersByClientUidCommand) {
                GetBuffersByClientUidCommand getBuffersCommand = (GetBuffersByClientUidCommand) command;
                handleGetBuffersByClientCommand(getBuffersCommand, key);
            } else if (command instanceof GetBuffersByDeviceUidCommand) {
                GetBuffersByDeviceUidCommand getBuffersCommand = (GetBuffersByDeviceUidCommand) command;
                handleGetBuffersByDeviceCommand(getBuffersCommand, key);
            } else if (command instanceof GetBuffersByConnectionSchemeUidCommand) {
                GetBuffersByConnectionSchemeUidCommand getBuffersCommand = (GetBuffersByConnectionSchemeUidCommand) command;
                handleGetBuffersByConnectionSchemeCommand(getBuffersCommand, key);
            } else if (command instanceof HealthCheckCommand) {
                HealthCheckCommand healthCommand = (HealthCheckCommand) command;
                handleHealthCheckCommand(healthCommand, key);
            } else {
                log.warn("Unknown buffer command type: {}", command.getClass().getCanonicalName());
            }

        } catch (Exception e) {
            log.error("Error processing buffer command: key={}", record.key(), e);
        }
    }

    private void handleGetBufferByUidCommand(GetBufferByUidCommand command, String key) {
        try {
            log.info("Processing GetBufferByUidCommand for buffer UID: {}", command.getBufferUid());

            BufferBLM bufferBLM = bufferService.getBufferByUid(command.getBufferUid());
            BufferDTO bufferDTO = bufferConverter.toDTO(bufferBLM);

            GetBufferByUidResponse response = GetBufferByUidResponse.success(
                    command.getCorrelationId(),
                    bufferDTO);

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
            log.info("GetBufferByUid response sent to {}: correlationId={}",
                    command.getReplyTopic(), command.getCorrelationId());

        } catch (Exception e) {
            log.error("Error processing GetBufferByUidCommand for buffer UID: {}", command.getBufferUid(), e);

            GetBufferByUidResponse response = GetBufferByUidResponse.error(
                    command.getCorrelationId(),
                    e.getMessage());

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
        }
    }

    private void handleGetBuffersByClientCommand(GetBuffersByClientUidCommand command, String key) {
        try {
            log.info("Processing GetBuffersByClientCommand for client UID: {}", command.getClientUid());

            List<BufferBLM> buffersBLM = bufferService.getBuffersByClient(command.getClientUid());
            List<BufferDTO> bufferDTOs = buffersBLM.stream()
                    .map(bufferConverter::toDTO)
                    .collect(Collectors.toList());

            GetBuffersByClientResponse response = GetBuffersByClientResponse.success(
                    command.getCorrelationId(),
                    bufferDTOs);

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);

            log.info("GetBufferByClient response sent to {}: correlationId={}",
                    command.getReplyTopic(), command.getCorrelationId());

        } catch (Exception e) {
            log.error("Error processing GetBuffersByClientCommand for client UID: {}", command.getClientUid(), e);

            GetBuffersByClientResponse response = GetBuffersByClientResponse.error(
                    command.getCorrelationId(),
                    e.getMessage());

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
        }
    }

    private void handleGetBuffersByDeviceCommand(GetBuffersByDeviceUidCommand command, String key) {
        try {
            log.info("Processing GetBuffersByDeviceCommand for device UID: {}", command.getDeviceUid());

            List<BufferBLM> buffersBLM = bufferService.getBuffersByDevice(command.getDeviceUid());
            List<BufferDTO> bufferDTOs = buffersBLM.stream()
                    .map(bufferConverter::toDTO)
                    .collect(Collectors.toList());

            GetBuffersByDeviceResponse response = GetBuffersByDeviceResponse.success(
                    command.getCorrelationId(),
                    bufferDTOs);

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);

            log.info("GetBufferByDevice response sent to {}: correlationId={}",
                    command.getReplyTopic(), command.getCorrelationId());

        } catch (Exception e) {
            log.error("Error processing GetBuffersByDeviceCommand for device UID: {}", command.getDeviceUid(), e);

            GetBuffersByDeviceResponse response = GetBuffersByDeviceResponse.error(
                    command.getCorrelationId(),
                    e.getMessage());

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
        }
    }

    private void handleGetBuffersByConnectionSchemeCommand(GetBuffersByConnectionSchemeUidCommand command, String key) {
        try {
            log.info("Processing GetBuffersByConnectionSchemeCommand for connection scheme UID: {}",
                    command.getConnectionSchemeUid());

            List<BufferBLM> buffersBLM = bufferService.getBuffersByConnectionScheme(command.getConnectionSchemeUid());
            List<BufferDTO> bufferDTOs = buffersBLM.stream()
                    .map(bufferConverter::toDTO)
                    .collect(Collectors.toList());

            GetBuffersByConnectionSchemeResponse response = GetBuffersByConnectionSchemeResponse.success(
                    command.getCorrelationId(),
                    bufferDTOs);

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);

            log.info("GetBufferByConnectionScheme response sent to {}: correlationId={}",
                    command.getReplyTopic(), command.getCorrelationId());

        } catch (Exception e) {
            log.error("Error processing GetBuffersByConnectionSchemeCommand for connection scheme UID: {}",
                    command.getConnectionSchemeUid(), e);

            GetBuffersByConnectionSchemeResponse response = GetBuffersByConnectionSchemeResponse.error(
                    command.getCorrelationId(),
                    e.getMessage());

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
        }
    }

    private void handleHealthCheckCommand(HealthCheckCommand command, String key) {
        try {
            log.info("Processing HealthCheckCommand");

            var healthStatus = bufferService.getHealthStatus();

            HealthCheckResponse response = HealthCheckResponse.success(
                    command.getCorrelationId(),
                    healthStatus);

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);

            log.info("HealthCheck response sent to {}: correlationId={}",
                    command.getReplyTopic(), command.getCorrelationId());

        } catch (Exception e) {
            log.error("Error processing HealthCheckCommand", e);

            HealthCheckResponse response = HealthCheckResponse.error(
                    command.getCorrelationId(),
                    e.getMessage());

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
        }
    }
}package com.service.buffer.kafka;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.config.KafkaListenerEndpointRegistry;
import org.springframework.kafka.listener.MessageListenerContainer;
import org.springframework.stereotype.Component;

import com.connection.common.events.CommandResponse;
import com.connection.scheme.events.responses.GetConnectionSchemeByUidResponse;
import com.connection.scheme.events.responses.HealthCheckResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class ConnectionSchemeResponseConsumer implements ApplicationListener<ApplicationReadyEvent> {

    @Autowired
    private TypedConnectionSchemeKafkaClient connectionSchemeKafkaClient;
    @Autowired
    private KafkaListenerEndpointRegistry registry;

    @KafkaListener(id = "dynamicConnectionSchemeListener", 
                   topics = "#{@typedConnectionSchemeKafkaClient.getInstanceReplyTopic()}")
    public void handleConnectionSchemeResponse(ConsumerRecord<String, CommandResponse> record) {
        try {
            CommandResponse message = record.value();
            String correlationId = record.key();
            
            log.info("Received connection scheme response from instance topic: correlationId={}, topic={}", 
                    correlationId, record.topic());
                
            if (message instanceof GetConnectionSchemeByUidResponse) {
                GetConnectionSchemeByUidResponse typedResponse = (GetConnectionSchemeByUidResponse) message;
                connectionSchemeKafkaClient.handleResponse(correlationId, typedResponse);
            } else if (message instanceof HealthCheckResponse) {
                HealthCheckResponse typedResponse = (HealthCheckResponse) message;
                connectionSchemeKafkaClient.handleResponse(correlationId, typedResponse);
            } else {
                log.warn("Unknown connection scheme response type for correlationId: {}", correlationId);
            }
            
        } catch (Exception e) {
            log.error("Error processing connection scheme response: correlationId={}", record.key(), e);
        }
    }

    @Override
    public void onApplicationEvent(ApplicationReadyEvent event) {
        try {
            MessageListenerContainer container = registry.getListenerContainer("dynamicConnectionSchemeListener");
            if (container != null && !container.isRunning()) {
                container.start();
                log.info("Dynamic connection scheme response listener started for topic: {}", 
                        connectionSchemeKafkaClient.getInstanceReplyTopic());
            }
        } catch (Exception e) {
            log.error("Failed to start dynamic connection scheme listener", e);
        }
    }
}package com.service.buffer.kafka;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.config.KafkaListenerEndpointRegistry;
import org.springframework.kafka.listener.MessageListenerContainer;
import org.springframework.stereotype.Component;

import com.connection.auth.events.responses.TokenValidationResponse;
import com.connection.common.events.CommandResponse;
import com.connection.auth.events.responses.HealthCheckResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
public class AuthResponseConsumer implements ApplicationListener<ApplicationReadyEvent> {
    @Autowired
    private TypedAuthKafkaClient authKafkaClient;
    @Autowired
    private KafkaListenerEndpointRegistry registry;

    @KafkaListener(id = "dynamicAuthListener", topics = "#{@typedAuthKafkaClient.getInstanceReplyTopic()}")
    public void handleAuthResponse(ConsumerRecord<String, CommandResponse> record) {
        try {
            CommandResponse message = record.value();
            String correlationId = record.key();
            
            log.info("Received auth response from instance topic: correlationId={}, topic={}", 
                    correlationId, record.topic());
                
            if (message instanceof TokenValidationResponse) {
                TokenValidationResponse typedResponse = (TokenValidationResponse) message;
                authKafkaClient.handleResponse(correlationId, typedResponse);
            } else if (message instanceof HealthCheckResponse) {
                HealthCheckResponse typedResponse = (HealthCheckResponse) message;
                authKafkaClient.handleResponse(correlationId, typedResponse);
            } else {
                log.warn("Unknown response type for correlationId: {}", correlationId);
            }
            
        } catch (Exception e) {
            log.error("Error processing auth response: correlationId={}", record.key(), e);
        }
    }

    @Override
    public void onApplicationEvent(ApplicationReadyEvent event) {
        try {
            MessageListenerContainer container = registry.getListenerContainer("dynamicAuthListener");
            if (container != null && !container.isRunning()) {
                container.start();
                log.info("Dynamic auth response listener started for topic: {}", 
                        authKafkaClient.getInstanceReplyTopic());
            }
        } catch (Exception e) {
            log.error("Failed to start dynamic auth listener", e);
        }
    }
}package com.service.buffer.kafka;

import java.util.Date;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

import com.connection.auth.events.AuthEventConstants;
import com.connection.auth.events.AuthEventUtils;
import com.connection.auth.events.commands.ExtractClientUidCommand;
import com.connection.auth.events.commands.HealthCheckCommand;
import com.connection.auth.events.commands.ValidateTokenCommand;
import com.connection.auth.events.responses.HealthCheckResponse;
import com.connection.auth.events.responses.TokenValidationResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class TypedAuthKafkaClient {

    @Autowired
    private KafkaTemplate<String, Object> kafkaTemplate;
    
    private final Map<String, PendingRequest<?>> pendingRequests = new ConcurrentHashMap<>();
    
    // 👇 Уникальный топик для этого инстанса
    private final String instanceReplyTopic = "auth.responses." + UUID.randomUUID().toString();

    private static class PendingRequest<T> {
        final CompletableFuture<T> future;
        final Class<T> responseType;

        PendingRequest(CompletableFuture<T> future, Class<T> responseType) {
            this.future = future;
            this.responseType = responseType;
        }
    }

    public CompletableFuture<TokenValidationResponse> validateToken(String token, String sourceService) {
        return sendRequest(
            ValidateTokenCommand.builder()
                .token(token)
                .tokenType(ValidateTokenCommand.TokenType.ACCESS)
                .sourceService(sourceService)
                .replyTopic(instanceReplyTopic) // 👈 Уникальный топик инстанса
                .correlationId(AuthEventUtils.generateCorrelationId())
                .build(),
            TokenValidationResponse.class
        );
    }

    public CompletableFuture<HealthCheckResponse> healthCheck(String sourceService) {
        return sendRequest(
            HealthCheckCommand.builder()
                .eventId(UUID.randomUUID().toString())
                .sourceService(sourceService)
                .timestamp(new Date().toInstant())
                .replyTopic(instanceReplyTopic) // 👈 Уникальный топик инстанса
                .correlationId(AuthEventUtils.generateCorrelationId())
                .commandType(AuthEventConstants.COMMAND_HEALTH_CHECK)
                .build(),
            HealthCheckResponse.class
        );
    }

    private <T> CompletableFuture<T> sendRequest(Object command, Class<T> responseType) {
        String correlationId;
        
        if (command instanceof ValidateTokenCommand) {
            correlationId = ((ValidateTokenCommand) command).getCorrelationId();
        } else if (command instanceof ExtractClientUidCommand) {
            correlationId = ((ExtractClientUidCommand) command).getCorrelationId();
        } else if (command instanceof HealthCheckCommand) {
            correlationId = ((HealthCheckCommand) command).getCorrelationId();
        } else {
            throw new IllegalArgumentException("Unsupported command type: " + command.getClass());
        }

        CompletableFuture<T> future = new CompletableFuture<>();
        pendingRequests.put(correlationId, new PendingRequest<>(future, responseType));

        // 👇 Добавляем таймаут 30 секунд
        future.orTimeout(30, TimeUnit.SECONDS).whenComplete((result, ex) -> {
            if (ex != null) {
                pendingRequests.remove(correlationId);
                log.warn("Request timeout or error for correlationId: {}", correlationId);
            }
        });

        kafkaTemplate.send(AuthEventConstants.AUTH_COMMANDS_TOPIC, correlationId, command)
                .whenComplete((result, ex) -> {
                    if (ex != null) {
                        future.completeExceptionally(ex);
                        pendingRequests.remove(correlationId);
                        log.error("Failed to send auth command: {}", ex.getMessage());
                    } else {
                        log.info("Auth command sent successfully: correlationId={}, topic={}", 
                                correlationId, AuthEventConstants.AUTH_COMMANDS_TOPIC);
                    }
                });

        return future;
    }

    @SuppressWarnings("unchecked")
    public void handleResponse(String correlationId, Object response) {
        PendingRequest<?> pendingRequest = pendingRequests.remove(correlationId);
        if (pendingRequest != null) {
            try {
                if (pendingRequest.responseType.isInstance(response)) {
                    CompletableFuture<Object> future = (CompletableFuture<Object>) pendingRequest.future;
                    future.complete(response);
                    log.info("Auth response handled successfully: correlationId={}", correlationId);
                } else {
                    log.warn("Type mismatch for correlationId: {}. Expected: {}, Got: {}", 
                            correlationId, pendingRequest.responseType, response.getClass());
                    pendingRequest.future.completeExceptionally(
                        new ClassCastException("Type mismatch in auth response")
                    );
                }
            } catch (Exception e) {
                pendingRequest.future.completeExceptionally(e);
            }
        } else {
            log.warn("Received auth response for unknown correlationId: {}", correlationId);
        }
    }
    
    // 👇 Геттер для получения уникального топика инстанса
    public String getInstanceReplyTopic() {
        log.info("Got teply topic: " + instanceReplyTopic);
        return instanceReplyTopic;
    }
}package com.service.buffer.kafka;

import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

import com.connection.device.events.DeviceEventConstants;
import com.connection.device.events.DeviceEventUtils;
import com.connection.device.events.commands.GetDeviceByUidCommand;
import com.connection.device.events.commands.GetDevicesByClientUid;
import com.connection.device.events.commands.HealthCheckCommand;
import com.connection.device.events.responses.GetDeviceByUidResponse;
import com.connection.device.events.responses.GetDevicesByClientResponse;
import com.connection.device.events.responses.HealthCheckResponse;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
public class TypedDeviceKafkaClient {

    @Autowired
    private KafkaTemplate<String, Object> kafkaTemplate;

    private final Map<String, PendingRequest<?>> pendingRequests = new ConcurrentHashMap<>();
        
    
    private final String instanceReplyTopic = "device.responses." + UUID.randomUUID().toString();

    private static class PendingRequest<T> {
        final CompletableFuture<T> future;
        final Class<T> responseType;

        PendingRequest(CompletableFuture<T> future, Class<T> responseType) {
            this.future = future;
            this.responseType = responseType;
        }
    }

    public CompletableFuture<GetDeviceByUidResponse> getDeviceByUid(UUID deviceUid, String sourceService) {
        return sendRequest(
            GetDeviceByUidCommand.builder()
                .deviceUid(deviceUid)
                .sourceService(sourceService)
                .replyTopic(instanceReplyTopic) 
                .correlationId(DeviceEventUtils.generateCorrelationId())
                .build(),
            GetDeviceByUidResponse.class
        );
    }

    public CompletableFuture<GetDevicesByClientResponse> getDevicesByClient(UUID clientUid, String sourceService) {
        return sendRequest(
            GetDevicesByClientUid.builder()
                .sourceService(sourceService)
                .clientUid(clientUid)
                .replyTopic(instanceReplyTopic) 
                .correlationId(DeviceEventUtils.generateCorrelationId())
                .build(),
            GetDevicesByClientResponse.class
        );
    }

    public CompletableFuture<HealthCheckResponse> healthCheck(String sourceService) {
        return sendRequest(
            HealthCheckCommand.builder()
                .sourceService(sourceService)
                .replyTopic(instanceReplyTopic) 
                .correlationId(DeviceEventUtils.generateCorrelationId())
                .build(),
            HealthCheckResponse.class
        );
    }

    
    public boolean deviceExistsAndBelongsToClient(UUID deviceUid, UUID clientUid) {
        try {
            GetDeviceByUidResponse response = getDeviceByUid(deviceUid, "buffer-service")
                    .get(10, TimeUnit.SECONDS);
            return response.isSuccess() && response.getDeviceDTO() != null && 
                   response.getDeviceDTO().getClientUuid().equals(clientUid.toString());
        } catch (Exception e) {
            log.error("Error checking device existence: {}", e.getMessage());
            return false;
        }
    }

    public List<UUID> getClientDeviceUids(UUID clientUid) {
        try {
            GetDevicesByClientResponse response = getDevicesByClient(clientUid, "buffer-service")
                    .get(10, TimeUnit.SECONDS);
            
            if (response.isSuccess() && response.getDeviceDTOs() != null) {
                return response.getDeviceDTOs().stream()
                        .map(device -> UUID.fromString(device.getUid()))
                        .collect(java.util.stream.Collectors.toList());
            }
            return List.of();
        } catch (Exception e) {
            log.error("Error getting client devices: {}", e.getMessage());
            return List.of();
        }
    }

    private <T> CompletableFuture<T> sendRequest(Object command, Class<T> responseType) {
        String correlationId = extractCorrelationId(command);
        
        CompletableFuture<T> future = new CompletableFuture<>();
        pendingRequests.put(correlationId, new PendingRequest<>(future, responseType));

        
        future.orTimeout(30, TimeUnit.SECONDS).whenComplete((result, ex) -> {
            if (ex != null) {
                pendingRequests.remove(correlationId);
                log.warn("Device request timeout or error for correlationId: {}", correlationId);
            }
        });

        kafkaTemplate.send(DeviceEventConstants.DEVICE_COMMANDS_TOPIC, correlationId, command)
                .whenComplete((result, ex) -> {
                    if (ex != null) {
                        future.completeExceptionally(ex);
                        pendingRequests.remove(correlationId);
                        log.error("Failed to send device command: {}", ex.getMessage());
                    } else {
                        log.info("Device command sent successfully: correlationId={}, topic={}", 
                                correlationId, DeviceEventConstants.DEVICE_COMMANDS_TOPIC);
                    }
                });

        return future;
    }

    @SuppressWarnings("unchecked")
    public void handleResponse(String correlationId, Object response) {
        PendingRequest<?> pendingRequest = pendingRequests.remove(correlationId);
        if (pendingRequest != null) {
            try {
                if (pendingRequest.responseType.isInstance(response)) {
                    log.info("Device response: ", pendingRequest.toString());
                    CompletableFuture<Object> future = (CompletableFuture<Object>) pendingRequest.future;
                    future.complete(response);
                    log.info("Device response handled successfully: correlationId={}", correlationId);
                } else {
                    log.warn("Type mismatch for correlationId: {}. Expected: {}, Got: {}", 
                            correlationId, pendingRequest.responseType, response.getClass());
                    pendingRequest.future.completeExceptionally(
                        new ClassCastException("Type mismatch in device response")
                    );
                }
            } catch (Exception e) {
                pendingRequest.future.completeExceptionally(e);
            }
        } else {
            log.warn("Received device response for unknown correlationId: {}", correlationId);
        }
    }

    private String extractCorrelationId(Object command) {
        if (command instanceof GetDeviceByUidCommand) {
            return ((GetDeviceByUidCommand) command).getCorrelationId();
        } else if (command instanceof GetDevicesByClientUid) {
            return ((GetDevicesByClientUid) command).getCorrelationId();
        } else if (command instanceof HealthCheckCommand) {
            return ((HealthCheckCommand) command).getCorrelationId();
        } else {
            throw new IllegalArgumentException("Unsupported device command type: " + command.getClass());
        }
    }
    
    
    public String getInstanceReplyTopic() {
        log.info("Got teply topic: " + instanceReplyTopic);
        return instanceReplyTopic;
    }
}package com.service.buffer.kafka;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;

import com.connection.scheme.events.ConnectionSchemeEventConstants;
import com.connection.scheme.events.ConnectionSchemeEventUtils;
import com.connection.scheme.events.commands.GetConnectionSchemeByUidCommand;
import com.connection.scheme.events.commands.HealthCheckCommand;
import com.connection.scheme.events.responses.GetConnectionSchemeByUidResponse;
import com.connection.scheme.events.responses.HealthCheckResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class TypedConnectionSchemeKafkaClient {

    @Autowired
    private KafkaTemplate<String, Object> kafkaTemplate;
    private final Map<String, PendingRequest<?>> pendingRequests = new ConcurrentHashMap<>();
    
    // 👇 Уникальный топик для этого инстанса
    private final String instanceReplyTopic = "connection-scheme.responses." + UUID.randomUUID().toString();

    private static class PendingRequest<T> {
        final CompletableFuture<T> future;
        final Class<T> responseType;

        PendingRequest(CompletableFuture<T> future, Class<T> responseType) {
            this.future = future;
            this.responseType = responseType;
        }
    }

    public CompletableFuture<GetConnectionSchemeByUidResponse> getConnectionSchemeByUid(UUID connectionSchemeUid, String sourceService) {
        return sendRequest(
            GetConnectionSchemeByUidCommand.builder()
                .connectionSchemeUid(connectionSchemeUid)
                .sourceService(sourceService)
                .replyTopic(instanceReplyTopic) // 👈 Уникальный топик инстанса
                .correlationId(ConnectionSchemeEventUtils.generateCorrelationId())
                .build(),
            GetConnectionSchemeByUidResponse.class
        );
    }

    public CompletableFuture<HealthCheckResponse> healthCheck(String sourceService) {
        return sendRequest(
            HealthCheckCommand.builder()
                .sourceService(sourceService)
                .replyTopic(instanceReplyTopic) // 👈 Уникальный топик инстанса
                .correlationId(ConnectionSchemeEventUtils.generateCorrelationId())
                .build(),
            HealthCheckResponse.class
        );
    }

    // Вспомогательные методы для удобства
    public boolean connectionSchemeExistsAndBelongsToClient(UUID connectionSchemeUid, UUID clientUuid) {
        try {
            GetConnectionSchemeByUidResponse response = getConnectionSchemeByUid(connectionSchemeUid, "buffer-service")
                    .get(10, TimeUnit.SECONDS);
            return response.isSuccess() && response.getConnectionSchemeDTO() != null && 
                   response.getConnectionSchemeDTO().getClientUid().equals(clientUuid.toString());
        } catch (Exception e) {
            log.error("Error checking connection scheme existence: {}", e.getMessage());
            return false;
        }
    }

    private <T> CompletableFuture<T> sendRequest(Object command, Class<T> responseType) {
        String correlationId = extractCorrelationId(command);
        
        CompletableFuture<T> future = new CompletableFuture<>();
        pendingRequests.put(correlationId, new PendingRequest<>(future, responseType));

        // 👇 Добавляем таймаут 30 секунд
        future.orTimeout(30, TimeUnit.SECONDS).whenComplete((result, ex) -> {
            if (ex != null) {
                pendingRequests.remove(correlationId);
                log.warn("Connection scheme request timeout or error for correlationId: {}", correlationId);
            }
        });

        kafkaTemplate.send(ConnectionSchemeEventConstants.CONNECTION_SCHEME_COMMANDS_TOPIC, correlationId, command)
                .whenComplete((result, ex) -> {
                    if (ex != null) {
                        future.completeExceptionally(ex);
                        pendingRequests.remove(correlationId);
                        log.error("Failed to send connection scheme command: {}", ex.getMessage());
                    } else {
                        log.info("Connection scheme command sent successfully: correlationId={}, topic={}", 
                                correlationId, ConnectionSchemeEventConstants.CONNECTION_SCHEME_COMMANDS_TOPIC);
                    }
                });

        return future;
    }

    @SuppressWarnings("unchecked")
    public void handleResponse(String correlationId, Object response) {
        PendingRequest<?> pendingRequest = pendingRequests.remove(correlationId);
        if (pendingRequest != null) {
            try {
                if (pendingRequest.responseType.isInstance(response)) {
                    CompletableFuture<Object> future = (CompletableFuture<Object>) pendingRequest.future;
                    future.complete(response);
                    log.info("Connection scheme response handled successfully: correlationId={}", correlationId);
                } else {
                    log.warn("Type mismatch for correlationId: {}. Expected: {}, Got: {}", 
                            correlationId, pendingRequest.responseType, response.getClass());
                    pendingRequest.future.completeExceptionally(
                        new ClassCastException("Type mismatch in connection scheme response")
                    );
                }
            } catch (Exception e) {
                pendingRequest.future.completeExceptionally(e);
            }
        } else {
            log.warn("Received connection scheme response for unknown correlationId: {}", correlationId);
        }
    }

    private String extractCorrelationId(Object command) {
        if (command instanceof GetConnectionSchemeByUidCommand) {
            return ((GetConnectionSchemeByUidCommand) command).getCorrelationId();
        } else if (command instanceof HealthCheckCommand) {
            return ((HealthCheckCommand) command).getCorrelationId();
        } else {
            throw new IllegalArgumentException("Unsupported connection scheme command type: " + command.getClass());
        }
    }
    
    // 👇 Геттер для получения уникального топика инстанса
    public String getInstanceReplyTopic() {
        return instanceReplyTopic;
    }
}package com.service.buffer.kafka;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.context.event.ApplicationReadyEvent;
import org.springframework.context.ApplicationListener;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.config.KafkaListenerEndpointRegistry;
import org.springframework.kafka.listener.MessageListenerContainer;
import org.springframework.stereotype.Component;

import com.connection.common.events.CommandResponse;
import com.connection.device.events.responses.GetDeviceByUidResponse;
import com.connection.device.events.responses.GetDevicesByClientResponse;
import com.connection.device.events.responses.HealthCheckResponse;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
@RequiredArgsConstructor
public class DeviceResponseConsumer implements ApplicationListener<ApplicationReadyEvent> {

    @Autowired
    private TypedDeviceKafkaClient deviceKafkaClient;
    @Autowired
    private KafkaListenerEndpointRegistry registry;

    @KafkaListener(id = "dynamicDeviceListener", 
                   topics = "#{@typedDeviceKafkaClient.getInstanceReplyTopic()}")
    public void handleDeviceResponse(ConsumerRecord<String, CommandResponse> record) {
        try {
            CommandResponse message = record.value();
            String correlationId = record.key();
            
            log.info("Received device response from instance topic: correlationId={}, topic={}", 
                    correlationId, record.topic());
                
            if (message instanceof GetDeviceByUidResponse) {
                GetDeviceByUidResponse typedResponse = (GetDeviceByUidResponse) message;
                deviceKafkaClient.handleResponse(correlationId, typedResponse);
            } else if (message instanceof GetDevicesByClientResponse) {
                GetDevicesByClientResponse typedResponse = (GetDevicesByClientResponse) message;
                deviceKafkaClient.handleResponse(correlationId, typedResponse);
            } else if (message instanceof HealthCheckResponse) {
                HealthCheckResponse typedResponse = (HealthCheckResponse) message;
                deviceKafkaClient.handleResponse(correlationId, typedResponse);
            } else {
                log.warn("Unknown device response type for correlationId: {}", correlationId);
            }
            
        } catch (Exception e) {
            log.error("Error processing device response: correlationId={}", record.key(), e);
        }
    }

    @Override
    public void onApplicationEvent(ApplicationReadyEvent event) {
        try {
            MessageListenerContainer container = registry.getListenerContainer("dynamicDeviceListener");
            if (container != null && !container.isRunning()) {
                container.start();
                log.info("Dynamic device response listener started for topic: {}", 
                        deviceKafkaClient.getInstanceReplyTopic());
            }
        } catch (Exception e) {
            log.error("Failed to start dynamic device listener", e);
        }
    }
}package com.service.buffer;

import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.stream.Collectors;

import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.connection.auth.events.responses.HealthCheckResponse;
import com.connection.device.converter.DeviceConverter;
import com.connection.device.events.responses.GetDevicesByClientResponse;
import com.connection.device.model.DeviceBLM;
import com.connection.device.model.DeviceDTO;
import com.connection.processing.buffer.converter.BufferConverter;
import com.connection.processing.buffer.exception.BufferAlreadyExistsException;
import com.connection.processing.buffer.model.BufferBLM;
import com.connection.processing.buffer.model.BufferBLM;
import com.connection.processing.buffer.model.BufferDTO;
import com.connection.processing.buffer.repository.BufferRepository;
import com.connection.processing.buffer.validator.BufferValidator;
import com.service.buffer.kafka.TypedAuthKafkaClient;
import com.service.buffer.kafka.TypedConnectionSchemeKafkaClient;
import com.service.buffer.kafka.TypedDeviceKafkaClient;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

@Slf4j
@RequiredArgsConstructor
@Service("KafkaBufferService")
@EnableAutoConfiguration(exclude = {
        JpaRepositoriesAutoConfiguration.class
})
@Transactional("atomicosTransactionManager")
public class KafkaBufferServiceImpl implements BufferService {

    private final BufferRepository bufferRepository;
    private final BufferConverter bufferConverter;
    private final BufferValidator bufferValidator;

    private final DeviceConverter deviceConverter;

    private final TypedAuthKafkaClient authKafkaClient;
    private final TypedDeviceKafkaClient deviceKafkaClient;
    private final TypedConnectionSchemeKafkaClient connectionSchemeKafkaClient;

    @Override
    public BufferBLM createBuffer(BufferDTO bufferDTO) {
        bufferValidator.validate(bufferDTO);
        BufferBLM bufferBLM = bufferConverter.toBLM(bufferDTO);

        if (bufferRepository.exists(bufferBLM.getUid())) {
            throw new BufferAlreadyExistsException(
                    "Buffer with UID '" + bufferBLM.getUid() + "' already exists");
        }

        bufferRepository.add(bufferBLM);

        log.info("Buffer created via Kafka: {} for device: {}", bufferBLM.getUid(), bufferBLM.getDeviceUid());
        return bufferBLM;
    }

    @Override
    public BufferBLM getBufferByUid(UUID bufferUid) {
        BufferBLM bufferBLM = bufferRepository.findByUid(bufferUid);
        return (bufferBLM); // Без проверки безопасности
    }

    @Override
    public List<BufferBLM> getBuffersByClient(UUID clientUid) {
        try {
            GetDevicesByClientResponse devicesResponse = deviceKafkaClient
                    .getDevicesByClient(clientUid, "buffer-service")
                    .get(5, java.util.concurrent.TimeUnit.SECONDS);

            if (!devicesResponse.isSuccess() || devicesResponse.getDeviceDTOs() == null) {
                log.warn("Failed to get devices for client: {}", clientUid);
                return List.of();
            }

            List<DeviceDTO> deviceDTOs = devicesResponse.getDeviceDTOs();
            List<DeviceBLM> deviceBLMs = deviceDTOs.stream()
                    .map(deviceConverter::toBLM)
                    .collect(Collectors.toList());

            return deviceBLMs.stream()
                    .flatMap(device -> getBuffersByDevice(device.getUid()).stream())
                    .collect(Collectors.toList());

        } catch (Exception e) {
            log.error("Error getting buffers for client: {}", clientUid, e);
            throw new RuntimeException("Error getting client buffers", e);
        }
    }

    @Override
    public List<BufferBLM> getBuffersByDevice(UUID deviceUid) {
        List<BufferBLM> bufferBLMs = bufferRepository.findByDeviceUid(deviceUid);
        return bufferBLMs;
    }

    @Override
    public List<BufferBLM> getBuffersByConnectionScheme(UUID connectionSchemeUid) {
        List<BufferBLM> buffersBLM = bufferRepository.findByConnectionSchemeUid(connectionSchemeUid);
        return buffersBLM;
    }

    @Override
    public BufferBLM updateBuffer(UUID bufferUid, BufferDTO bufferDTO) {
        bufferValidator.validate(bufferDTO);
        bufferRepository.findByUid(bufferUid); // Проверяем существование

        BufferBLM bufferBLM = bufferConverter.toBLM(bufferDTO);

        if (!bufferUid.equals(bufferBLM.getUid())) {
            throw new IllegalArgumentException("Cannot change buffer UID");
        }

        bufferRepository.update(bufferBLM);

        log.info("Buffer updated via Kafka: {} for device: {}", bufferUid, bufferBLM.getDeviceUid());
        return bufferBLM;
    }

    @Override
    public void deleteBuffer(UUID bufferUid) {
        bufferRepository.delete(bufferUid);
        log.info("Buffer deleted via Kafka: {}", bufferUid);
    }

    @Override
    public boolean bufferExists(UUID bufferUid) {
        return bufferRepository.exists(bufferUid);
    }

    @Override
    public Map<String, Object> getHealthStatus() {
        try {
            HealthCheckResponse authHealth = authKafkaClient.healthCheck("buffer-service")
                    .get(5, java.util.concurrent.TimeUnit.SECONDS);

            com.connection.device.events.responses.HealthCheckResponse deviceHealth = deviceKafkaClient
                    .healthCheck("buffer-service")
                    .get(5, java.util.concurrent.TimeUnit.SECONDS);

            com.connection.scheme.events.responses.HealthCheckResponse connectionSchemeHealth = connectionSchemeKafkaClient
                    .healthCheck("buffer-service")
                    .get(5, java.util.concurrent.TimeUnit.SECONDS);

            return Map.of(
                    "status", "OK",
                    "service", "buffer-service",
                    "timestamp", System.currentTimeMillis(),
                    "auth-service", authHealth.isSuccess() ? "AVAILABLE" : "UNAVAILABLE",
                    "device-service", deviceHealth.isSuccess() ? "AVAILABLE" : "UNAVAILABLE",
                    "connection-scheme-service", connectionSchemeHealth.isSuccess() ? "AVAILABLE" : "UNAVAILABLE",
                    "database", "CONNECTED");

        } catch (Exception e) {
            log.error("Health check error: ", e);
            return Map.of(
                    "status", "DEGRADED",
                    "service", "buffer-service",
                    "timestamp", System.currentTimeMillis(),
                    "auth-service", "UNAVAILABLE",
                    "device-service", "UNAVAILABLE",
                    "connection-scheme-service", "UNAVAILABLE",
                    "database", "CONNECTED",
                    "error", e.getMessage());
        }
    }

    @Override
    public void deleteBufferFromConnectionScheme(UUID connectionSchemeUid, UUID bufferUid) {
        bufferRepository.removeBufferFromConnectionScheme(bufferUid, connectionSchemeUid);
        log.info("Buffer {} removed from connection scheme {} via Kafka", bufferUid, connectionSchemeUid);
    }

    @Override
    public void deleteAllBuffersFromConnectionScheme(UUID connectionSchemeUid) {
        List<BufferBLM> buffers = getBuffersByConnectionScheme(connectionSchemeUid);
        for (BufferBLM b : buffers) {
            bufferRepository.removeBufferFromConnectionScheme(b.getUid(), connectionSchemeUid);
        }
        log.info("All buffers removed from connection scheme {} via Kafka", connectionSchemeUid);
    }
}// JwtKafkaAuthenticationFilter.java
package com.service.buffer.client;

import com.service.buffer.kafka.TypedAuthKafkaClient;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import com.connection.auth.events.responses.TokenValidationResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Collections;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeUnit;

@Slf4j
@Component
@RequiredArgsConstructor
public class JwtKafkaAuthenticationFilter extends OncePerRequestFilter {

    private final TypedAuthKafkaClient authKafkaClient;
    private static final String AUTH_HEADER = "Authorization";
    private static final String BEARER_PREFIX = "Bearer ";

    @Override
    protected void doFilterInternal(HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain) throws ServletException, IOException {

        String authHeader = request.getHeader(AUTH_HEADER);

        if (authHeader == null || !authHeader.startsWith(BEARER_PREFIX)) {
            filterChain.doFilter(request, response);
            return;
        }

        String jwtToken = authHeader.substring(BEARER_PREFIX.length());

        try {
            authenticateWithToken(jwtToken, request);
        } catch (Exception e) {
            log.error("Authentication failed for token: {}", e.getMessage());
            response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
            return;
        }

        filterChain.doFilter(request, response);
    }

    private void authenticateWithToken(String token, HttpServletRequest request) {
        try {
            String cleanToken = token.trim();
            cleanToken = cleanToken.replace("Bearer ", "");

            log.info("Validating token: {}...", cleanToken.substring(0, Math.min(cleanToken.length(), 10)) + "...");

            CompletableFuture<TokenValidationResponse> validationFuture = authKafkaClient.validateToken(cleanToken,
                    "buffer-service");

            TokenValidationResponse validationResponse = validationFuture
                    .get(10, TimeUnit.SECONDS);

            if (!validationResponse.isValid()) {
                throw new SecurityException("Token validation failed: " + validationResponse.getError());
            }

            UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(
                    validationResponse.getClientUid(),
                    null,
                    Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER")));

            authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
            SecurityContextHolder.getContext().setAuthentication(authentication);

            log.info("Successfully authenticated client: {}", validationResponse.getClientUid());

        } catch (java.util.concurrent.TimeoutException e) {
            throw new SecurityException("Token validation timeout");
        } catch (java.util.concurrent.ExecutionException e) {
            throw new SecurityException("Token validation error: " + e.getCause().getMessage());
        } catch (Exception e) {
            throw new SecurityException("Authentication failed: " + e.getMessage());
        }
    }
}// TestKafkaConfig.java
package com.service.buffer.integration;

import org.apache.kafka.clients.admin.NewTopic;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Profile;
import org.springframework.kafka.config.TopicBuilder;
import org.springframework.stereotype.Component;

import lombok.Getter;

import java.util.UUID;

@Component
@Profile("integrationtest")
public class TestKafkaConfig {
    
    @Value("${spring.kafka.bootstrap-servers:localhost:29092}")
    private String bootstrapServers;

    // Уникальные темы для тестов, аналогично instanceReplyTopic в основном коде
    private final String testDeviceCommandsTopic = "device.commands.test." + UUID.randomUUID();
    private final String testConnectionSchemeCommandsTopic = "scheme.commands.test." + UUID.randomUUID();
    private final String testBufferCommandsTopic = "buffer.commands.test." + UUID.randomUUID();
    @Getter
    private final String testDeviceCommandsResponses = "connection-scheme.responses." + UUID.randomUUID().toString();
    @Getter
    private final String testConnectionSchemeCommandsResponses = "device.responses." + UUID.randomUUID().toString();

    @Bean
    public NewTopic testDeviceCommandsTopic() {
        return TopicBuilder.name(testDeviceCommandsTopic)
                .partitions(3)
                .replicas(1)
                .build();
    }

    @Bean
    public NewTopic testConnectionSchemeCommandsTopic() {
        return TopicBuilder.name(testConnectionSchemeCommandsTopic)
                .partitions(3)
                .replicas(1)
                .build();
    }

    @Bean
    public NewTopic testBufferCommandsTopic() {
        return TopicBuilder.name(testBufferCommandsTopic)
                .partitions(3)
                .replicas(1)
                .build();
    }

    // Геттеры для использования в тестах
    public String getTestDeviceCommandsTopic() {
        return testDeviceCommandsTopic;
    }

    public String getTestConnectionSchemeCommandsTopic() {
        return testConnectionSchemeCommandsTopic;
    }

    public String getTestBufferCommandsTopic() {
        return testBufferCommandsTopic;
    }


}package com.service.buffer.integration;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;
import org.springframework.test.context.ActiveProfiles;

import com.connection.scheme.events.commands.GetConnectionSchemeByUidCommand;
import com.connection.scheme.events.commands.GetConnectionSchemesByBufferUid;
import com.connection.scheme.events.commands.GetConnectionSchemesByClientUid;
import com.connection.scheme.events.commands.HealthCheckCommand;
import com.connection.scheme.events.responses.GetConnectionSchemeByUidResponse;
import com.connection.scheme.events.responses.GetConnectionSchemesByBufferResponse;
import com.connection.scheme.events.responses.GetConnectionSchemesByClientResponse;
import com.connection.scheme.events.responses.HealthCheckResponse;
import com.connection.scheme.model.ConnectionSchemeDTO;

import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
@Component
@RequiredArgsConstructor
@ActiveProfiles("integrationtest")
public class TestConnectionSchemeServiceResponder {

    private final KafkaTemplate<String, Object> kafkaTemplate;
    private final TestKafkaConfig testKafkaConfig;

    // Хранилище тестовых данных
    private final Map<UUID, ConnectionSchemeDTO> testSchemes = new ConcurrentHashMap<>();
    private final Map<UUID, List<ConnectionSchemeDTO>> clientSchemes = new ConcurrentHashMap<>();
    private final Map<UUID, List<ConnectionSchemeDTO>> bufferSchemes = new ConcurrentHashMap<>();

    @Value("${app.kafka.topics.connection-scheme-commands:connection.scheme.commands}")
    private String connectionSchemeCommandsTopic;
    @PostConstruct
    public void logKafkaConfiguration() {
        log.info("""
            🧪 Test Connection Scheme Responder Kafka Configuration:
               📨 Listening Topic: {}
            """, connectionSchemeCommandsTopic);
    }


    @KafkaListener(topics = "${app.kafka.topics.connection-scheme-commands:connection.scheme.commands}", groupId = "test-connection-scheme-responder")
    public void handleConnectionSchemeCommand(ConsumerRecord<String, Object> record) {
        try {
            Object command = record.value();
            log.info("🧪 Test Connection Scheme Responder received command from topic {}: {}",
                    testKafkaConfig.getTestConnectionSchemeCommandsTopic(), command.getClass().getSimpleName());

            if (command instanceof GetConnectionSchemeByUidCommand) {
                handleGetConnectionSchemeByUid((GetConnectionSchemeByUidCommand) command);
            } else if (command instanceof GetConnectionSchemesByClientUid) {
                handleGetConnectionSchemesByClient((GetConnectionSchemesByClientUid) command);
            } else if (command instanceof GetConnectionSchemesByBufferUid) {
                handleGetConnectionSchemesByBuffer((GetConnectionSchemesByBufferUid) command);
            } else if (command instanceof HealthCheckCommand) {
                handleHealthCheck((HealthCheckCommand) command);
            }

        } catch (Exception e) {
            log.error("❌ Error in test connection scheme responder", e);
        }
    }

    private void handleGetConnectionSchemeByUid(GetConnectionSchemeByUidCommand command) {
        try {
            UUID schemeUid = command.getConnectionSchemeUid();
            ConnectionSchemeDTO scheme = testSchemes.get(schemeUid);

            GetConnectionSchemeByUidResponse response;
            if (scheme != null) {
                response = GetConnectionSchemeByUidResponse.success(
                        command.getCorrelationId(),
                        scheme);
                log.info("✅ Test Responder: Connection Scheme {} found", schemeUid);
            } else {
                response = GetConnectionSchemeByUidResponse.error(
                        command.getCorrelationId(),
                        "Connection scheme not found in test data");
                log.warn("⚠️ Test Responder: Connection Scheme {} not found", schemeUid);
            }

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);

        } catch (Exception e) {
            log.error("❌ Error handling GetConnectionSchemeByUid", e);
        }
    }

    private void handleGetConnectionSchemesByClient(GetConnectionSchemesByClientUid command) {
        try {
            UUID clientUid = command.getClientUid();
            List<ConnectionSchemeDTO> schemes = clientSchemes.get(clientUid);

            GetConnectionSchemesByClientResponse response;
            if (schemes != null && !schemes.isEmpty()) {
                response = GetConnectionSchemesByClientResponse.valid(
                        command.getCorrelationId(),
                        schemes);
                log.info("✅ Test Responder: Found {} connection schemes for client {}", schemes.size(), clientUid);
            } else {
                response = GetConnectionSchemesByClientResponse.valid(
                        command.getCorrelationId(),
                        List.of());
                log.info("ℹ️ Test Responder: No connection schemes found for client {}", clientUid);
            }

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);

        } catch (Exception e) {
            log.error("❌ Error handling GetConnectionSchemesByClient", e);
        }
    }

    private void handleGetConnectionSchemesByBuffer(GetConnectionSchemesByBufferUid command) {
        try {
            UUID bufferUid = command.getBufferUid();
            List<ConnectionSchemeDTO> schemes = bufferSchemes.get(bufferUid);

            GetConnectionSchemesByBufferResponse response;
            if (schemes != null && !schemes.isEmpty()) {
                response = GetConnectionSchemesByBufferResponse.valid(
                        command.getCorrelationId(),
                        schemes);
                log.info("✅ Test Responder: Found {} connection schemes for buffer {}", schemes.size(), bufferUid);
            } else {
                response = GetConnectionSchemesByBufferResponse.valid(
                        command.getCorrelationId(),
                        List.of());
                log.info("ℹ️ Test Responder: No connection schemes found for buffer {}", bufferUid);
            }

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);

        } catch (Exception e) {
            log.error("❌ Error handling GetConnectionSchemesByBuffer", e);
        }
    }

    private void handleHealthCheck(HealthCheckCommand command) {
        try {
            HealthCheckResponse response = HealthCheckResponse.success(
                    command.getCorrelationId(),
                    Map.of("status", "OK", "service", "test-connection-scheme-responder"));

            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
            log.info("✅ Test Responder: Health check responded");

        } catch (Exception e) {
            log.error("❌ Error handling HealthCheck", e);
        }
    }

    // Методы для управления тестовыми данными

    public void addTestConnectionScheme(UUID schemeUid, UUID clientUid, List<UUID> usedBuffers) {
        ConnectionSchemeDTO scheme = createTestConnectionSchemeDTO(schemeUid, clientUid, usedBuffers);
        addTestConnectionScheme(scheme);
    }

    public void addTestConnectionScheme(ConnectionSchemeDTO scheme) {
        UUID schemeUid = UUID.fromString(scheme.getUid());
        UUID clientUid = UUID.fromString(scheme.getClientUid());

        testSchemes.put(schemeUid, scheme);

        // Добавляем в список схем клиента
        List<ConnectionSchemeDTO> clientSchemeList = clientSchemes.computeIfAbsent(
                clientUid, k -> new ArrayList<>());
        clientSchemeList.add(scheme);

        // Автоматически создаем связи с буферами из usedBuffers
        if (scheme.getUsedBuffers() != null) {
            for (UUID bufferUid : scheme.getUsedBuffers()) {
                linkSchemeToBuffer(schemeUid, bufferUid);
            }
        }

        log.info("📝 Test Responder: Added connection scheme {} for client {} with {} used buffers",
                schemeUid, clientUid,
                scheme.getUsedBuffers() != null ? scheme.getUsedBuffers().size() : 0);
    }

    public void linkSchemeToBuffer(UUID schemeUid, UUID bufferUid) {
        ConnectionSchemeDTO scheme = testSchemes.get(schemeUid);
        if (scheme != null) {
            List<ConnectionSchemeDTO> bufferSchemeList = bufferSchemes.computeIfAbsent(
                    bufferUid, k -> new ArrayList<>());
            if (!bufferSchemeList.contains(scheme)) {
                bufferSchemeList.add(scheme);
            }
            log.info("🔗 Test Responder: Linked scheme {} to buffer {}", schemeUid, bufferUid);
        } else {
            log.warn("⚠️ Test Responder: Cannot link - scheme {} not found", schemeUid);
        }
    }

    public void removeTestConnectionScheme(UUID schemeUid) {
        ConnectionSchemeDTO scheme = testSchemes.remove(schemeUid);
        if (scheme != null) {
            UUID clientUid = UUID.fromString(scheme.getClientUid());

            // Удаляем из списка клиента
            List<ConnectionSchemeDTO> clientSchemesList = clientSchemes.get(clientUid);
            if (clientSchemesList != null) {
                clientSchemesList.removeIf(s -> s.getUid().equals(schemeUid.toString()));
            }

            // Удаляем из всех связей с буферами
            bufferSchemes.values()
                    .forEach(schemeList -> schemeList.removeIf(s -> s.getUid().equals(schemeUid.toString())));
        }
    }

    public void clearTestData() {
        testSchemes.clear();
        clientSchemes.clear();
        bufferSchemes.clear();
        log.info("🧹 Test Responder: All connection scheme test data cleared");
    }

    public boolean hasConnectionScheme(UUID schemeUid) {
        return testSchemes.containsKey(schemeUid);
    }

    public boolean connectionSchemeBelongsToClient(UUID schemeUid, UUID clientUid) {
        ConnectionSchemeDTO scheme = testSchemes.get(schemeUid);
        return scheme != null && scheme.getClientUid().equals(clientUid.toString());
    }

    private ConnectionSchemeDTO createTestConnectionSchemeDTO(UUID schemeUid, UUID clientUid, List<UUID> usedBuffers) {
        return ConnectionSchemeDTO.builder()
                .uid(schemeUid.toString())
                .clientUid(clientUid.toString())
                .usedBuffers(usedBuffers != null ? usedBuffers : new ArrayList<>())
                .schemeJson("{\"test\": true, \"schemeType\": \"integration-test\", \"buffers\": " +
                        (usedBuffers != null ? usedBuffers.toString() : "[]") + "}")
                .build();
    }

    // Дополнительные методы для удобства

    public void addTestConnectionSchemeWithBuffers(UUID schemeUid, UUID clientUid, UUID... bufferUids) {
        List<UUID> usedBuffers = bufferUids != null ? Arrays.asList(bufferUids) : new ArrayList<>();
        addTestConnectionScheme(schemeUid, clientUid, usedBuffers);
    }

    public void addBufferToScheme(UUID schemeUid, UUID bufferUid) {
        ConnectionSchemeDTO scheme = testSchemes.get(schemeUid);
        if (scheme != null) {
            List<UUID> usedBuffers = scheme.getUsedBuffers();
            if (usedBuffers == null) {
                usedBuffers = new ArrayList<>();
                scheme.setUsedBuffers(usedBuffers);
            }
            if (!usedBuffers.contains(bufferUid)) {
                usedBuffers.add(bufferUid);
            }
            linkSchemeToBuffer(schemeUid, bufferUid);
            log.info("➕ Test Responder: Added buffer {} to scheme {}", bufferUid, schemeUid);
        }
    }

    public void removeBufferFromScheme(UUID schemeUid, UUID bufferUid) {
        ConnectionSchemeDTO scheme = testSchemes.get(schemeUid);
        if (scheme != null && scheme.getUsedBuffers() != null) {
            scheme.getUsedBuffers().remove(bufferUid);

            // Удаляем связь
            List<ConnectionSchemeDTO> bufferSchemesList = bufferSchemes.get(bufferUid);
            if (bufferSchemesList != null) {
                bufferSchemesList.removeIf(s -> s.getUid().equals(schemeUid.toString()));
            }
            log.info("➖ Test Responder: Removed buffer {} from scheme {}", bufferUid, schemeUid);
        }
    }
}package com.service.buffer.integration;

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.stereotype.Component;
import org.springframework.test.context.ActiveProfiles;

import com.connection.device.events.commands.GetDeviceByUidCommand;
import com.connection.device.events.commands.GetDevicesByClientUid;
import com.connection.device.events.commands.HealthCheckCommand;
import com.connection.device.events.responses.GetDeviceByUidResponse;
import com.connection.device.events.responses.GetDevicesByClientResponse;
import com.connection.device.events.responses.HealthCheckResponse;
import com.connection.device.model.DeviceDTO;

import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;

import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
@Component
@RequiredArgsConstructor
@ActiveProfiles("integrationtest")
public class TestDeviceServiceResponder {
    
    private final KafkaTemplate<String, Object> kafkaTemplate;
    private final TestKafkaConfig testKafkaConfig;
    
    
    // Хранилище тестовых данных
    private final Map<UUID, DeviceDTO> testDevices = new ConcurrentHashMap<>();
    private final Map<UUID, List<DeviceDTO>> clientDevices = new ConcurrentHashMap<>();
    
    @Value("${app.kafka.topics.device-commands:device.commands}")
    private String connectionSchemeCommandsTopic;
    @PostConstruct
    public void logKafkaConfiguration() {
        log.info("""
            🧪 Test Device Responder Kafka Configuration:
               📨 Listening Topic: {}
            """, connectionSchemeCommandsTopic);
    }

    @KafkaListener(
        topics = "${app.kafka.topics.device-commands:device.commands}",
        groupId = "test-device-responder"
    )
    public void handleDeviceCommand(ConsumerRecord<String, Object> record) {
        try {
            Object command = record.value();
            log.info("🧪 Test Device Responder received command from topic {}: {}", 
                    testKafkaConfig.getTestDeviceCommandsTopic(), command.getClass().getSimpleName());
            
            if (command instanceof GetDeviceByUidCommand) {
                handleGetDeviceByUid((GetDeviceByUidCommand) command);
            } else if (command instanceof GetDevicesByClientUid) {
                handleGetDevicesByClient((GetDevicesByClientUid) command);
            } else if (command instanceof HealthCheckCommand) {
                handleHealthCheck((HealthCheckCommand) command);
            }
            
        } catch (Exception e) {
            log.error("❌ Error in test device responder", e);
        }
    }
    
        private void handleGetDeviceByUid(GetDeviceByUidCommand command) {
        try {
            UUID deviceUid = command.getDeviceUid();
            DeviceDTO device = testDevices.get(deviceUid);
            
            GetDeviceByUidResponse response;
            if (device != null) {
                response = GetDeviceByUidResponse.success(
                    command.getCorrelationId(),
                    device
                );
                log.info("✅ Test Responder: Device {} found", deviceUid);
            } else {
                response = GetDeviceByUidResponse.error(
                    command.getCorrelationId(),
                    "Device not found in test data"
                );
                log.warn("⚠️ Test Responder: Device {} not found", deviceUid);
            }
            
            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
            log.info("Test Responder: send response to {}", command.getReplyTopic());
            
        } catch (Exception e) {
            log.error("❌ Error handling GetDeviceByUid", e);
        }
    }
    
    private void handleGetDevicesByClient(GetDevicesByClientUid command) {
        try {
            UUID clientUid = command.getClientUid();
            List<DeviceDTO> devices = clientDevices.get(clientUid);
            
            GetDevicesByClientResponse response;
            if (devices != null && !devices.isEmpty()) {
                response = GetDevicesByClientResponse.valid(
                    command.getCorrelationId(),
                    devices
                );
                log.info("✅ Test Responder: Found {} devices for client {}", devices.size(), clientUid);
            } else {
                response = GetDevicesByClientResponse.valid(
                    command.getCorrelationId(),
                    List.of()
                );
                log.info("ℹ️ Test Responder: No devices found for client {}", clientUid);
            }
            
            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
            log.info("ℹ️ Test Responder: send response to {}", command.getReplyTopic());
            
        } catch (Exception e) {
            log.error("❌ Error handling GetDevicesByClient", e);
        }
    }
    
    private void handleHealthCheck(HealthCheckCommand command) {
        try {
            HealthCheckResponse response = HealthCheckResponse.success(
                command.getCorrelationId(),
                Map.of("status", "OK", "service", "test-device-responder")
            );
            
            kafkaTemplate.send(command.getReplyTopic(), command.getCorrelationId(), response);
            log.info("✅ Test Responder: Health check responded");
            
        } catch (Exception e) {
            log.error("❌ Error handling HealthCheck", e);
        }
    }
    
    // Методы для управления тестовыми данными
    
    public void addTestDevice(UUID deviceUid, UUID clientUid, String deviceName) {
        DeviceDTO device = new DeviceDTO();
        device.setUid(deviceUid.toString());
        device.setClientUuid(clientUid.toString());
        device.setDeviceName(deviceName);
        device.setDeviceDescription("Test device for integration tests");
        
        testDevices.put(deviceUid, device);
        
        // Также добавляем в список устройств клиента
        List<DeviceDTO> clientDeviceList = clientDevices.computeIfAbsent(
            clientUid, k -> new java.util.ArrayList<>()
        );
        clientDeviceList.add(device);
        
        log.info("📝 Test Responder: Added test device {} for client {}", deviceUid, clientUid);
    }
    
    public void addTestDevice(DeviceDTO device) {
        UUID deviceUid = UUID.fromString(device.getUid());
        UUID clientUid = UUID.fromString(device.getClientUuid());
        
        testDevices.put(deviceUid, device);
        
        List<DeviceDTO> clientDeviceList = clientDevices.computeIfAbsent(
            clientUid, k -> new java.util.ArrayList<>()
        );
        clientDeviceList.add(device);
    }
    
    public void removeTestDevice(UUID deviceUid) {
        DeviceDTO device = testDevices.remove(deviceUid);
        if (device != null) {
            UUID clientUid = UUID.fromString(device.getClientUuid());
            List<DeviceDTO> clientDevicesList = clientDevices.get(clientUid);
            if (clientDevicesList != null) {
                clientDevicesList.removeIf(d -> d.getUid().equals(deviceUid.toString()));
            }
        }
    }
    
    public void clearTestData() {
        testDevices.clear();
        clientDevices.clear();
        log.info("🧹 Test Responder: All test data cleared");
    }
    
    public boolean hasDevice(UUID deviceUid) {
        return testDevices.containsKey(deviceUid);
    }
}// BufferServiceIntegrationTest.java
package com.service.buffer.integration;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

import java.util.List;
import java.util.Map;
import java.util.UUID;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.context.ActiveProfiles;

import com.connection.processing.buffer.model.BufferBLM;
import com.connection.processing.buffer.model.BufferDTO;
import com.service.buffer.BufferService;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@SpringBootTest
@ActiveProfiles("integrationtest")
@DisplayName("Buffer Service Integration Tests")
public class BufferServiceIntegrationTest extends BaseBufferIntegrationTest {

    @Autowired
    @Qualifier("ApiBufferService")
    private BufferService bufferService;

    private UUID testBufferUid;
    private UUID testDeviceUid;
    private UUID testConnectionSchemeUid;

    @BeforeEach
    void setUpTestData() {
        testBufferUid = UUID.randomUUID();
        testDeviceUid = UUID.randomUUID();
        testConnectionSchemeUid = UUID.randomUUID();

        // Настраиваем тестовые устройства ДО инициализации БД
        setupTestDevices(getTestClientUid(), testDeviceUid);

        // Инициализируем тестовые данные в БД
        initializeTestClientAndDevice();

        log.info("Created test IDs - Buffer: {}, Device: {}, Scheme: {}, Client: {}",
                testBufferUid, testDeviceUid, testConnectionSchemeUid, getTestClientUid());
    }

    @AfterEach
    void cleanupTestData() {
        cleanupCurrentClientData();
    }

    @Test
    @DisplayName("Should create buffer successfully")
    void shouldCreateBufferSuccessfully() {
        // Given
        BufferDTO bufferDTO = createTestBufferDTO();

        // Устанавливаем аутентификацию перед вызовом сервиса
        setupAuthentication();

        // When
        BufferBLM createdBuffer = bufferService.createBuffer(bufferDTO);

        // Then
        assertThat(createdBuffer).isNotNull();
        assertThat(createdBuffer.getUid()).isEqualTo(testBufferUid);
        assertThat(createdBuffer.getDeviceUid()).isEqualTo(testDeviceUid);
        assertThat(createdBuffer.getMaxMessagesNumber()).isEqualTo(1000);
        assertThat(createdBuffer.getMaxMessageSize()).isEqualTo(1024);

        log.info("Successfully created buffer: {}", testBufferUid);
    }

    @Test
    @DisplayName("Should get buffer by UID")
    void shouldGetBufferByUid() {
        // Given
        BufferDTO bufferDTO = createTestBufferDTO();

        // Создаем буфер с аутентификацией
        setupAuthentication();
        bufferService.createBuffer(bufferDTO);

        // Получаем буфер с той же аутентификацией
        BufferBLM foundBuffer = bufferService.getBufferByUid(testBufferUid);

        // Then
        assertThat(foundBuffer).isNotNull();
        assertThat(foundBuffer.getUid()).isEqualTo(testBufferUid);
        assertThat(foundBuffer.getDeviceUid()).isEqualTo(testDeviceUid);

        log.info("Successfully retrieved buffer by UID: {}", testBufferUid);
    }

    @Test
    @DisplayName("Should get buffers by device")
    void shouldGetBuffersByDevice() {
        // Given
        BufferDTO bufferDTO = createTestBufferDTO();

        setupAuthentication();
        bufferService.createBuffer(bufferDTO);

        // When
        List<BufferBLM> buffers = bufferService.getBuffersByDevice(testDeviceUid);

        // Then
        assertThat(buffers).isNotEmpty();
        assertThat(buffers.get(0).getUid()).isEqualTo(testBufferUid);
        assertThat(buffers.get(0).getDeviceUid()).isEqualTo(testDeviceUid);

        log.info("Successfully retrieved {} buffers for device: {}", buffers.size(), testDeviceUid);
    }


    @Test
    @DisplayName("Should update buffer successfully")
    void shouldUpdateBufferSuccessfully() {
        // Given
        BufferDTO originalBufferDTO = createTestBufferDTO();

        setupAuthentication();
        bufferService.createBuffer(originalBufferDTO);

        // Обновляем DTO без message_prototype, так как его нет в таблице
        BufferDTO updatedBufferDTO = new BufferDTO(
                testBufferUid.toString(),
                testDeviceUid.toString(),
                2000, // updated max messages
                2048, // updated max size
                "{}" // message_prototype не используется
        );

        // When
        BufferBLM updatedBuffer = bufferService.updateBuffer(testBufferUid, updatedBufferDTO);

        // Then
        assertThat(updatedBuffer).isNotNull();
        assertThat(updatedBuffer.getUid()).isEqualTo(testBufferUid);
        assertThat(updatedBuffer.getMaxMessagesNumber()).isEqualTo(2000);
        assertThat(updatedBuffer.getMaxMessageSize()).isEqualTo(2048);

        log.info("Successfully updated buffer: {}", testBufferUid);
    }

    @Test
    @DisplayName("Should delete buffer successfully")
    void shouldDeleteBufferSuccessfully() {
        // Given
        BufferDTO bufferDTO = createTestBufferDTO();

        setupAuthentication();
        bufferService.createBuffer(bufferDTO);

        // Verify buffer exists
        BufferBLM foundBuffer = bufferService.getBufferByUid(testBufferUid);
        assertThat(foundBuffer).isNotNull();

        // When
        bufferService.deleteBuffer(testBufferUid);

        // Then
        boolean bufferExists = bufferService.bufferExists(testBufferUid);
        assertThat(bufferExists).isFalse();

        log.info("Successfully deleted buffer: {}", testBufferUid);
    }

    @Test
    @DisplayName("Should check buffer existence")
    void shouldCheckBufferExistence() {
        // Given
        BufferDTO bufferDTO = createTestBufferDTO();

        // When & Then - Before creation
        setupAuthentication();
        boolean existsBefore = bufferService.bufferExists(testBufferUid);
        assertThat(existsBefore).isFalse();

        // When & Then - After creation
        bufferService.createBuffer(bufferDTO);
        boolean existsAfter = bufferService.bufferExists(testBufferUid);
        assertThat(existsAfter).isTrue();

        log.info("Buffer existence check successful for: {}", testBufferUid);
    }

    @Test
    @DisplayName("Should get health status")
    void shouldGetHealthStatus() {
        // When
        setupAuthentication();

        // Обрабатываем возможный NPE в health check
        try {
            var healthStatus = bufferService.getHealthStatus();

            // Then
            assertThat(healthStatus).isNotNull();
            if (healthStatus.containsKey("service")) {
                assertThat(healthStatus.get("service")).isEqualTo("buffer-service");
            }
            if (healthStatus.containsKey("status")) {
                assertThat(healthStatus.get("status")).isIn("OK", "DEGRADED");
            }

            log.info("Health status: {}", healthStatus);
        } catch (NullPointerException e) {
            log.warn("Health status check threw NPE, but test continues: {}", e.getMessage());
            // Тест проходит, даже если health check имеет проблемы
        }
    }

    @Test
    @DisplayName("Should handle buffer not found")
    void shouldHandleBufferNotFound() {
        // Given
        UUID nonExistentBufferUid = UUID.randomUUID();

        // When & Then
        setupAuthentication();
        assertThatThrownBy(() -> bufferService.getBufferByUid(nonExistentBufferUid))
                .isInstanceOf(RuntimeException.class);

        log.info("Correctly handled non-existent buffer UID: {}", nonExistentBufferUid);
    }

    @Test
    @DisplayName("Should connect to database")
    void shouldConnectToDatabase() {
        // Given
        String testQuery = "SELECT 1";

        // When
        Integer result = bufferJdbcTemplate.getJdbcTemplate()
                .queryForObject(testQuery, Integer.class);

        // Then
        assertThat(result).isEqualTo(1);
        log.info("✅ Database connection test passed");
    }

    @Test
    @DisplayName("Should throw SecurityException when not authenticated")
    void shouldThrowSecurityExceptionWhenNotAuthenticated() {
        // Given
        BufferDTO bufferDTO = createTestBufferDTO();

        // Очищаем аутентификацию
        clearAuthentication();

        // When & Then
        assertThatThrownBy(() -> bufferService.createBuffer(bufferDTO))
                .isInstanceOf(SecurityException.class)
                .hasMessageContaining("User not authenticated");

        log.info("✅ SecurityException correctly thrown when not authenticated");
    }

    /**
     * Инициализирует тестового клиента и устройство в БД
     */
    private void initializeTestClientAndDevice() {
        try {
            // Создаем тестового клиента
            String insertClientSql = """
                    INSERT INTO core.client (uid, email, birth_date, username, password)
                    VALUES (:uid, :email, CURRENT_DATE - INTERVAL '25 years', :username, :password)
                    ON CONFLICT (uid) DO NOTHING
                    """;

            int clientsInserted = bufferJdbcTemplate.update(insertClientSql, Map.of(
                    "uid", getTestClientUid(),
                    "email", "test.client." + getTestClientUid() + "@example.com",
                    "username", "testclient_" + getTestClientUid().toString().substring(0, 8),
                    "password", "testpassword123"));

            if (clientsInserted > 0) {
                log.info("✅ Created test client: {}", getTestClientUid());
            }

            // Создаем тестовое устройство для этого клиента
            String insertDeviceSql = """
                    INSERT INTO core.device (uid, client_uuid, device_name, device_description)
                    VALUES (:uid, :clientUuid, :deviceName, :deviceDescription)
                    ON CONFLICT (uid) DO NOTHING
                    """;

            int devicesInserted = bufferJdbcTemplate.update(insertDeviceSql, Map.of(
                    "uid", testDeviceUid,
                    "clientUuid", getTestClientUid(),
                    "deviceName", "Test Device " + testDeviceUid.toString().substring(0, 8),
                    "deviceDescription", "Integration test device for buffer service"));

            if (devicesInserted > 0) {
                log.info("✅ Created test device: {} for client: {}", testDeviceUid, getTestClientUid());
            }

            // Создаем тестовую connection scheme для этого клиента
            String insertSchemeSql = """
                    INSERT INTO processing.connection_scheme (uid, client_uid, scheme_json)
                    VALUES (:uid, :clientUid, :schemeJson::jsonb)
                    ON CONFLICT (uid) DO NOTHING
                    """;

            int schemesInserted = bufferJdbcTemplate.update(insertSchemeSql, Map.of(
                    "uid", testConnectionSchemeUid,
                    "clientUid", getTestClientUid(),
                    "schemeJson", "{\"test\": true, \"schemeType\": \"integration-test\"}"));

            if (schemesInserted > 0) {
                log.info("✅ Created test connection scheme: {}", testConnectionSchemeUid);
            }

        } catch (Exception e) {
            log.error("❌ Failed to initialize test client and device: {}", e.getMessage(), e);
            throw new RuntimeException("Test data initialization failed", e);
        }
    }

    /**
     * Очищает все данные текущего тестового клиента
     */
    private void cleanupCurrentClientData() {
        try {
            UUID currentClientUid = getTestClientUid();
            log.info("Cleaning up data for client: {}", currentClientUid);

            String deleteSchemeBuffersSql = """
                    DELETE FROM processing.connection_scheme_buffer
                    WHERE scheme_uid IN (
                        SELECT uid FROM processing.connection_scheme
                        WHERE client_uid = :clientUid
                    ) OR buffer_uid IN (
                        SELECT b.uid FROM processing.buffer b
                        JOIN core.device d ON b.device_uid = d.uid
                        WHERE d.client_uuid = :clientUid
                    )
                    """;
            try {
                int schemeBuffersDeleted = bufferJdbcTemplate.update(deleteSchemeBuffersSql,
                        Map.of("clientUid", currentClientUid));
                if (schemeBuffersDeleted > 0) {
                    log.debug("Deleted {} scheme-buffer links for client: {}", schemeBuffersDeleted, currentClientUid);
                }
            } catch (Exception e) {
                log.debug("No scheme-buffer links to delete for client: {}", currentClientUid);
            }

            // 3. Очистка буферов через устройства клиента
            String deleteBuffersSql = """
                    DELETE FROM processing.buffer
                    WHERE device_uid IN (
                        SELECT uid FROM core.device
                        WHERE client_uuid = :clientUid
                    )
                    """;
            try {
                int buffersDeleted = bufferJdbcTemplate.update(deleteBuffersSql, Map.of("clientUid", currentClientUid));
                if (buffersDeleted > 0) {
                    log.debug("Deleted {} buffers for client: {}", buffersDeleted, currentClientUid);
                }
            } catch (Exception e) {
                log.debug("No buffers to delete for client: {}", currentClientUid);
            }

            // 4. Очистка схем соединения клиента
            String deleteSchemesSql = "DELETE FROM processing.connection_scheme WHERE client_uid = :clientUid";
            try {
                int schemesDeleted = bufferJdbcTemplate.update(deleteSchemesSql, Map.of("clientUid", currentClientUid));
                if (schemesDeleted > 0) {
                    log.debug("Deleted {} connection schemes for client: {}", schemesDeleted, currentClientUid);
                }
            } catch (Exception e) {
                log.debug("No connection schemes to delete for client: {}", currentClientUid);
            }

            // 5. Очистка устройств клиента
            String deleteDevicesSql = "DELETE FROM core.device WHERE client_uuid = :clientUid";
            try {
                int devicesDeleted = bufferJdbcTemplate.update(deleteDevicesSql, Map.of("clientUid", currentClientUid));
                if (devicesDeleted > 0) {
                    log.debug("Deleted {} devices for client: {}", devicesDeleted, currentClientUid);
                }
            } catch (Exception e) {
                log.debug("No devices to delete for client: {}", currentClientUid);
            }

            // 6. Очистка самого клиента
            String deleteClientSql = "DELETE FROM core.client WHERE uid = :clientUid";
            try {
                int clientsDeleted = bufferJdbcTemplate.update(deleteClientSql, Map.of("clientUid", currentClientUid));
                if (clientsDeleted > 0) {
                    log.info("✅ Cleaned up client and all related data: {}", currentClientUid);
                }
            } catch (Exception e) {
                log.debug("No client to delete: {}", currentClientUid);
            }

        } catch (Exception e) {
            log.warn("Cleanup warning for client {}: {}", getTestClientUid(), e.getMessage());
        }
    }

    /**
     * Создает связь между буфером и схемой соединения
     */
    private void linkBufferToScheme() {
        try {
            String linkSql = """
                    INSERT INTO processing.connection_scheme_buffer (uid, scheme_uid, buffer_uid)
                    VALUES (:uid, :schemeUid, :bufferUid)
                    """;

            bufferJdbcTemplate.update(linkSql, Map.of(
                    "uid", UUID.randomUUID(),
                    "schemeUid", testConnectionSchemeUid,
                    "bufferUid", testBufferUid));

            log.info("✅ Linked buffer {} to scheme {}", testBufferUid, testConnectionSchemeUid);
        } catch (Exception e) {
            log.warn("Failed to link buffer to scheme: {}", e.getMessage());
        }
    }

    /**
     * Инициализирует другого клиента и устройство для тестирования разных клиентов
     */
    private void initializeDifferentClientAndDevice(UUID clientUid, UUID deviceUid) {
        try {
            // Создаем клиента
            String insertClientSql = """
                    INSERT INTO core.client (uid, email, birth_date, username, password)
                    VALUES (:uid, :email, CURRENT_DATE - INTERVAL '30 years', :username, :password)
                    """;

            bufferJdbcTemplate.update(insertClientSql, Map.of(
                    "uid", clientUid,
                    "email", "different.client." + clientUid + "@example.com",
                    "username", "diffclient_" + clientUid.toString().substring(0, 8),
                    "password", "differentpassword123"));

            // Создаем устройство для этого клиента
            String insertDeviceSql = """
                    INSERT INTO core.device (uid, client_uuid, device_name, device_description)
                    VALUES (:uid, :clientUuid, :deviceName, :deviceDescription)
                    """;

            bufferJdbcTemplate.update(insertDeviceSql, Map.of(
                    "uid", deviceUid,
                    "clientUuid", clientUid,
                    "deviceName", "Different Test Device " + deviceUid.toString().substring(0, 8),
                    "deviceDescription", "Device for different client test"));

            log.info("✅ Created different client {} with device {}", clientUid, deviceUid);

        } catch (Exception e) {
            log.error("❌ Failed to initialize different client and device: {}", e.getMessage(), e);
            throw new RuntimeException("Different client initialization failed", e);
        }
    }

    private BufferDTO createTestBufferDTO() {
        return new BufferDTO(
                testBufferUid.toString(),
                testDeviceUid.toString(),
                1000,
                1024,
                "{}");
    }

    private BufferDTO createTestBufferDTOForDifferentClient(UUID bufferUid, UUID deviceUid) {
        return new BufferDTO(
                bufferUid.toString(),
                deviceUid.toString(),
                1000,
                1024,
                "{}");
    }
}package com.service.buffer.integration;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.TestInstance;
import org.junit.jupiter.api.TestMethodOrder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.web.client.TestRestTemplate;
import org.springframework.core.env.Environment;
import org.springframework.http.HttpEntity;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.test.context.ActiveProfiles;
import org.springframework.test.context.TestPropertySource;

import com.connection.device.model.DeviceDTO;

import lombok.extern.slf4j.Slf4j;

import java.util.Arrays;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.Collections;
import java.util.List;

@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@ActiveProfiles("integrationtest")
@TestPropertySource(locations = "classpath:application-integrationtest.properties")
@TestMethodOrder(MethodOrderer.Random.class)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@Slf4j
public abstract class BaseBufferIntegrationTest {

    @Autowired
    protected TestDeviceServiceResponder testDeviceResponder;
    @Autowired
    protected TestConnectionSchemeServiceResponder testConnectionSchemeResponder;

    @Autowired
    protected Environment environment;

    @Autowired
    protected TestKafkaConfig testKafkaConfig;

    protected TestRestTemplate restTemplate = new TestRestTemplate();

    @Autowired
    protected KafkaTemplate<String, Object> kafkaTemplate;

    @Autowired
    @Qualifier("BufferJdbcTemplate")
    protected NamedParameterJdbcTemplate bufferJdbcTemplate;

    protected final Map<String, String> testData = new ConcurrentHashMap<>();
    protected UUID testClientUid;

    @BeforeEach
    void setUp() {
        checkConfig();
        testClientUid = UUID.randomUUID();

        // Инициализируем testData перед использованием
        testData.clear();

        log.info("✅ Test Kafka topics initialized - Device: {}, Scheme: {}",
                testKafkaConfig.getTestDeviceCommandsTopic(),
                testKafkaConfig.getTestConnectionSchemeCommandsTopic());

        // Очищаем тестовые данные перед каждым тестом
        testDeviceResponder.clearTestData();
        testConnectionSchemeResponder.clearTestData();
    }

    @AfterEach
    void tearDown() {
        testData.clear();
        cleanupAllTestData();
        clearAuthentication();

        // Очищаем тестовые данные после каждого теста
        testDeviceResponder.clearTestData();
        testConnectionSchemeResponder.clearTestData();
    }

    /**
     * Настраивает тестовые устройства для клиента
     */
    protected void setupTestDevices(UUID clientUid, UUID... deviceUids) {
        for (UUID deviceUid : deviceUids) {
            testDeviceResponder.addTestDevice(
                    deviceUid,
                    clientUid,
                    "Test Device " + deviceUid.toString().substring(0, 8));
        }
        log.info("✅ Test devices setup for client {}: {}", clientUid, List.of(deviceUids));
    }

    /**
     * Настраивает тестовые connection schemes для клиента
     */
    protected void setupTestConnectionSchemes(UUID clientUid, UUID... schemeUids) {
        for (UUID schemeUid : schemeUids) {
            testConnectionSchemeResponder.addTestConnectionSchemeWithBuffers(
                    schemeUid,
                    clientUid
            // без буферов по умолчанию
            );
        }
        log.info("✅ Test connection schemes setup for client {}: {}", clientUid, List.of(schemeUids));
    }

    /**
     * Настраивает connection scheme с указанными буферами
     */
    protected void setupTestConnectionSchemeWithBuffers(UUID schemeUid, UUID clientUid, UUID... bufferUids) {
        testConnectionSchemeResponder.addTestConnectionSchemeWithBuffers(schemeUid, clientUid, bufferUids);
        log.info("✅ Test connection scheme {} setup for client {} with buffers: {}",
                schemeUid, clientUid, List.of(bufferUids));
    }

    /**
     * Связывает connection scheme с buffer
     */
    protected void linkSchemeToBuffer(UUID schemeUid, UUID bufferUid) {
        testConnectionSchemeResponder.linkSchemeToBuffer(schemeUid, bufferUid);
        testConnectionSchemeResponder.addBufferToScheme(schemeUid, bufferUid);
        log.info("🔗 Linked scheme {} to buffer {}", schemeUid, bufferUid);
    }

    /**
     * Добавляет буфер в usedBuffers схемы
     */
    protected void addBufferToScheme(UUID schemeUid, UUID bufferUid) {
        testConnectionSchemeResponder.addBufferToScheme(schemeUid, bufferUid);
        log.info("➕ Added buffer {} to scheme {} usedBuffers", bufferUid, schemeUid);
    }

    /**
     * Проверяет, зарегистрировано ли устройство в тестовом ответчике
     */
    protected boolean isDeviceRegistered(UUID deviceUid) {
        return testDeviceResponder.hasDevice(deviceUid);
    }

    /**
     * Проверяет, зарегистрирована ли connection scheme в тестовом ответчике
     */
    protected boolean isConnectionSchemeRegistered(UUID schemeUid) {
        return testConnectionSchemeResponder.hasConnectionScheme(schemeUid);
    }

    /**
     * Проверяет, принадлежит ли connection scheme клиенту
     */
    protected boolean connectionSchemeBelongsToClient(UUID schemeUid, UUID clientUid) {
        return testConnectionSchemeResponder.connectionSchemeBelongsToClient(schemeUid, clientUid);
    }

    /**
     * Проверяет, связана ли схема с буфером
     */
    protected boolean isSchemeLinkedToBuffer(UUID schemeUid, UUID bufferUid) {
        // Эта логика будет зависеть от реализации, можно добавить соответствующий метод
        // в responder
        return testConnectionSchemeResponder.hasConnectionScheme(schemeUid);
    }

    /**
     * Настраивает тестовое устройство с конкретными данными
     */
    protected void setupTestDevice(DeviceDTO device) {
        testDeviceResponder.addTestDevice(device);
    }

    protected void checkConfig() {
        log.info("=== Buffer Service Integration Test Configuration ===");
        log.info("Active profiles: {}", Arrays.toString(environment.getActiveProfiles()));
        log.info("Kafka servers: {}", environment.getProperty("spring.kafka.bootstrap-servers"));
        log.info("Database URL: {}", environment.getProperty("app.datasource.buffer.xa-properties.url"));
        log.info("Database user: {}", environment.getProperty("app.datasource.buffer.xa-properties.user"));
        log.info("Service name: {}", environment.getProperty("spring.application.name"));
        log.info("=====================================================");
    }

    /**
     * Устанавливает аутентификацию для текущего тестового клиента
     */
    protected void setupAuthentication() {
        setupAuthentication(this.testClientUid);
    }

    /**
     * Устанавливает аутентификацию для указанного clientUid
     */
    protected void setupAuthentication(UUID clientUid) {
        Authentication authentication = new UsernamePasswordAuthenticationToken(
                clientUid,
                null,
                Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER")));

        SecurityContext context = SecurityContextHolder.createEmptyContext();
        context.setAuthentication(authentication);
        SecurityContextHolder.setContext(context);

        log.info("✅ Test authentication setup for client: {}", clientUid);
    }

    protected void clearAuthentication() {
        SecurityContextHolder.clearContext();
        log.info("🔒 Test authentication cleared");
    }

    protected void cleanupBufferData(UUID bufferUid) {
        try {
            log.info("Cleaning up buffer data for UID: {}", bufferUid);

            String deleteBufferSql = "DELETE FROM processing.buffer WHERE uid = :bufferUid";
            int buffersDeleted = bufferJdbcTemplate.update(deleteBufferSql, Map.of("bufferUid", bufferUid));

            if (buffersDeleted > 0) {
                log.info("Deleted {} buffers for UID: {}", buffersDeleted, bufferUid);
            }

        } catch (Exception e) {
            log.warn("Cleanup warning for buffer UID {}: {}", bufferUid, e.getMessage());
        }
    }

    // BaseBufferIntegrationTest.java - упрощаем метод cleanupAllTestData
    protected void cleanupAllTestData() {
        // Этот метод теперь не используется, так как каждый тест очищает только свои
        // данные
        log.debug("Global cleanup is disabled - each test cleans up its own client data");
    }

    protected void sleep(long milliseconds) {
        try {
            log.debug("Sleeping for {} ms", milliseconds);
            TimeUnit.MILLISECONDS.sleep(milliseconds);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            log.warn("Sleep interrupted", e);
        }
    }

    protected HttpEntity<Object> createHttpEntity(Object body) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        return new HttpEntity<>(body, headers);
    }

    protected HttpEntity<Object> createHttpEntityWithAuth(Object body, String token) {
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.setBearerAuth(token);
        return new HttpEntity<>(body, headers);
    }

    protected UUID getTestClientUid() {
        return testClientUid;
    }

    /**
     * Генерирует уникальное имя темы для тестов
     */
    protected String generateUniqueTopic(String baseTopicName) {
        return baseTopicName + ".test." + UUID.randomUUID().toString();
    }

    /**
     * Получает уникальную тему для device commands в тестах
     */
    protected String getTestDeviceCommandsTopic() {
        return environment.getProperty("app.kafka.topics.device-commands-test",
                "device.commands.test." + UUID.randomUUID().toString());
    }

    /**
     * Получает уникальную тему для connection scheme commands в тестах
     */
    protected String getTestConnectionSchemeCommandsTopic() {
        return environment.getProperty("app.kafka.topics.connection-scheme-commands-test",
                "scheme.commands.test." + UUID.randomUUID().toString());
    }

    /**
     * Настраивает тестовые темы Kafka перед выполнением теста
     */
    protected void setupTestKafkaTopics() {
        // Сохраняем оригинальные значения тем
        testData.put("original.device-commands",
                environment.getProperty("app.kafka.topics.device-commands"));
        testData.put("original.connection-scheme-commands",
                environment.getProperty("app.kafka.topics.connection-scheme-commands"));

        // Генерируем уникальные темы для теста
        String testDeviceTopic = getTestDeviceCommandsTopic();
        String testSchemeTopic = getTestConnectionSchemeCommandsTopic();

        // Устанавливаем системные свойства для переопределения тем в runtime
        System.setProperty("app.kafka.topics.device-commands", testDeviceTopic);
        System.setProperty("app.kafka.topics.connection-scheme-commands", testSchemeTopic);

        log.info("✅ Test Kafka topics setup - Device: {}, Scheme: {}",
                testDeviceTopic, testSchemeTopic);
    }

    /**
     * Восстанавливает оригинальные темы Kafka после теста
     */
    protected void restoreOriginalKafkaTopics() {
        // Восстанавливаем оригинальные значения
        String originalDeviceTopic = testData.get("original.device-commands");
        String originalSchemeTopic = testData.get("original.connection-scheme-commands");

        if (originalDeviceTopic != null) {
            System.setProperty("app.kafka.topics.device-commands", originalDeviceTopic);
        }
        if (originalSchemeTopic != null) {
            System.setProperty("app.kafka.topics.connection-scheme-commands", originalSchemeTopic);
        }

        log.info("✅ Original Kafka topics restored");
    }
}package com.service.buffer.mother;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import com.connection.processing.buffer.model.BufferBLM;
import com.connection.processing.buffer.model.BufferDALM;
import com.connection.processing.buffer.model.BufferDTO;
import com.connection.scheme.model.ConnectionSchemeBLM;

public class BufferObjectMother {

    public static final UUID CLIENT_UUID = UUID.fromString("123e4567-e89b-12d3-a456-426614174000");
    public static final UUID BUFFER_UUID = UUID.fromString("323e4567-e89b-12d3-a456-426614174002");
    public static final UUID SCHEME_UUID = UUID.fromString("423e4567-e89b-12d3-a456-426614174003");
    public static final String VALID_TOKEN = "valid-token-123";
    public static final String INVALID_TOKEN = "invalid-token-456";


    private static final UUID BUFFER_UID_1 = UUID.fromString("223e4567-e89b-12d3-a456-426614174002");
    private static final UUID BUFFER_UID_2 = UUID.fromString("223e4567-e89b-12d3-a456-426614174003");
    private static final UUID BUFFER_UID_3 = UUID.fromString("223e4567-e89b-12d3-a456-426614174004");
    
    private static final String DEFAULT_SCHEME_JSON = "{" +
        "\"usedBuffers\": [\"" + BUFFER_UID_1 + "\", \"" + BUFFER_UID_2 + "\"], " +
        "\"bufferTransitions\": {" +
            "\"" + BUFFER_UID_1 + "\": [\"" + BUFFER_UID_2 + "\"], " +
            "\"" + BUFFER_UID_2 + "\": [\"" + BUFFER_UID_3 + "\"]" +
        "}" +
    "}";


    public static BufferDTO createValidBufferDTO() {
        return new BufferDTO(
            BUFFER_UUID.toString(),
            SCHEME_UUID.toString(),
            1000,
            1024,
            "message prototype"
        );
    }

    public static BufferBLM createValidBufferBLM() {
        return new BufferBLM(
            BUFFER_UUID,
            SCHEME_UUID,
            1000,
            1024,
            "message prototype"
        );
    }

    public static BufferDALM createValidBufferDALM() {
        return new BufferDALM(
            BUFFER_UUID,
            SCHEME_UUID,
            1000,
            1024,
            "message prototype"
        );
    }
    public static ConnectionSchemeBLM createValidConnectionSchemeBLM() {
        Map<UUID, List<UUID>> bufferTransitions = new HashMap<>();
        bufferTransitions.put(BUFFER_UID_1, Arrays.asList(BUFFER_UID_2));
        bufferTransitions.put(BUFFER_UID_2, Arrays.asList(BUFFER_UID_3));
        
        return ConnectionSchemeBLM.builder()
                .uid(SCHEME_UUID)
                .clientUid(CLIENT_UUID)
                .schemeJson(DEFAULT_SCHEME_JSON)
                .usedBuffers(Arrays.asList(BUFFER_UID_1, BUFFER_UID_2))
                .bufferTransitions(bufferTransitions)
                .build();
    }

    public static ConnectionSchemeBLM createValidConnectionSchemeBLM(UUID clientUuid) {
        Map<UUID, List<UUID>> bufferTransitions = new HashMap<>();
        bufferTransitions.put(BUFFER_UID_1, Arrays.asList(BUFFER_UID_2));
        bufferTransitions.put(BUFFER_UID_2, Arrays.asList(BUFFER_UID_3));
        
        return ConnectionSchemeBLM.builder()
                .uid(SCHEME_UUID)
                .clientUid(clientUuid)
                .schemeJson(DEFAULT_SCHEME_JSON)
                .usedBuffers(Arrays.asList(BUFFER_UID_1, BUFFER_UID_2))
                .bufferTransitions(bufferTransitions)
                .build();
    }

    public static BufferDTO createBufferDTOWithDifferentScheme() {
        return new BufferDTO(
            BUFFER_UUID.toString(),
            UUID.randomUUID().toString(), // different scheme
            1000,
            1024,
            "message prototype"
        );
    }

    public static BufferDTO createInvalidBufferDTO() {
        return new BufferDTO(
            "invalid-uuid",
            "invalid-scheme-uuid",
            -1, // invalid max messages
            -1, // invalid max size
            null // null prototype
        );
    }
}package com.service.buffer;

import static com.service.buffer.mother.BufferObjectMother.BUFFER_UUID;
import static com.service.buffer.mother.BufferObjectMother.CLIENT_UUID;
import static com.service.buffer.mother.BufferObjectMother.SCHEME_UUID;
import static com.service.buffer.mother.BufferObjectMother.createValidBufferBLM;
import static com.service.buffer.mother.BufferObjectMother.createValidBufferDTO;
import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.util.Collections;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;

import com.connection.device.converter.DeviceConverter;
import com.connection.device.events.responses.GetDevicesByClientResponse;
import com.connection.device.model.DeviceBLM;
import com.connection.device.model.DeviceDTO;
import com.connection.processing.buffer.converter.BufferConverter;
import com.connection.processing.buffer.exception.BufferAlreadyExistsException;
import com.connection.processing.buffer.model.BufferBLM;
import com.connection.processing.buffer.model.BufferDTO;
import com.connection.processing.buffer.repository.BufferRepository;
import com.connection.processing.buffer.validator.BufferValidator;
import com.service.buffer.kafka.TypedAuthKafkaClient;
import com.service.buffer.kafka.TypedConnectionSchemeKafkaClient;
import com.service.buffer.kafka.TypedDeviceKafkaClient;

@ExtendWith(MockitoExtension.class)
@DisplayName("Buffer Service Implementation Tests")
class BufferServiceImplLondonTest {

    @Mock
    private BufferRepository bufferRepository;

    @Mock
    private BufferConverter bufferConverter;

    @Mock
    private BufferValidator bufferValidator;

    @Mock
    private DeviceConverter deviceConverter;

    @Mock
    private TypedAuthKafkaClient authKafkaClient;

    @Mock
    private TypedDeviceKafkaClient deviceKafkaClient;

    @Mock
    private TypedConnectionSchemeKafkaClient connectionSchemeKafkaClient;

    @Mock
    private SecurityContext securityContext;

    @InjectMocks
    private ApiBufferServiceImpl bufferService;

    private static final UUID DEVICE_UUID = UUID.fromString("523e4567-e89b-12d3-a456-426614174001");

    @BeforeEach
    void setUp() {
        SecurityContextHolder.setContext(securityContext);
    }


    private void setupAuthentication(UUID clientUid) {
        UsernamePasswordAuthenticationToken authentication = 
            new UsernamePasswordAuthenticationToken(clientUid, null, Collections.emptyList());
        when(securityContext.getAuthentication()).thenReturn(authentication);
    }


    @Test
    @DisplayName("Create buffer - Positive")
    void shouldCreateBufferWhenValidData() {
        // Arrange
        BufferDTO bufferDTO = createValidBufferDTO();
        BufferBLM bufferBLM = createValidBufferBLM();

        when(bufferConverter.toBLM(bufferDTO)).thenReturn(bufferBLM);
        when(deviceKafkaClient.deviceExistsAndBelongsToClient(
                eq(bufferBLM.getDeviceUid()), eq(CLIENT_UUID))).thenReturn(true);
        when(bufferRepository.exists(BUFFER_UUID)).thenReturn(false);

        setupAuthentication(CLIENT_UUID);

        // Act
        BufferBLM result = bufferService.createBuffer(bufferDTO);

        // Assert
        assertThat(result).isNotNull();
        assertThat(result.getUid()).isEqualTo(BUFFER_UUID);
        verify(bufferValidator).validate(bufferDTO);
        verify(deviceKafkaClient).deviceExistsAndBelongsToClient(bufferBLM.getDeviceUid(), CLIENT_UUID);
        verify(bufferRepository).add(bufferBLM);
    }

    @Test
    @DisplayName("Create buffer - Negative: Device doesn't belong to client")
    void shouldThrowExceptionWhenDeviceNotBelongsToClient() {
        // Arrange
        BufferDTO bufferDTO = createValidBufferDTO();
        BufferBLM bufferBLM = createValidBufferBLM();

        when(bufferConverter.toBLM(bufferDTO)).thenReturn(bufferBLM);
        when(deviceKafkaClient.deviceExistsAndBelongsToClient(
                eq(bufferBLM.getDeviceUid()), eq(CLIENT_UUID))).thenReturn(false);
        setupAuthentication(CLIENT_UUID);

        // Act & Assert
        assertThatThrownBy(() -> bufferService.createBuffer(bufferDTO))
            .isInstanceOf(SecurityException.class)
            .hasMessageContaining("Device doesn't exist or doesn't belong to the authenticated client");

        verify(bufferValidator).validate(bufferDTO);
        verify(bufferRepository, never()).add(any());
    }

    @Test
    @DisplayName("Create buffer - Negative: Buffer already exists")
    void shouldThrowExceptionWhenBufferAlreadyExists() {
        // Arrange
        BufferDTO bufferDTO = createValidBufferDTO();
        BufferBLM bufferBLM = createValidBufferBLM();

        when(bufferConverter.toBLM(bufferDTO)).thenReturn(bufferBLM);
        when(deviceKafkaClient.deviceExistsAndBelongsToClient(
                eq(bufferBLM.getDeviceUid()), eq(CLIENT_UUID))).thenReturn(true);
        when(bufferRepository.exists(BUFFER_UUID)).thenReturn(true);
        setupAuthentication(CLIENT_UUID);

        // Act & Assert
        assertThatThrownBy(() -> bufferService.createBuffer(bufferDTO))
            .isInstanceOf(BufferAlreadyExistsException.class);
        
        verify(bufferValidator).validate(bufferDTO);
        verify(bufferRepository, never()).add(any());
    }

    @Test
    @DisplayName("Get buffer - Positive")
    void shouldGetBufferWhenValidRequest() {
        // Arrange
        BufferBLM bufferBLM = createValidBufferBLM();

        when(bufferRepository.findByUid(BUFFER_UUID)).thenReturn(bufferBLM);
        when(deviceKafkaClient.deviceExistsAndBelongsToClient(
                eq(bufferBLM.getDeviceUid()), eq(CLIENT_UUID))).thenReturn(true);
        setupAuthentication(CLIENT_UUID);

        // Act
        BufferBLM result = bufferService.getBufferByUid(BUFFER_UUID);

        // Assert
        assertThat(result).isNotNull();
        assertThat(result.getUid()).isEqualTo(BUFFER_UUID);
        verify(bufferRepository).findByUid(BUFFER_UUID);
        verify(deviceKafkaClient).deviceExistsAndBelongsToClient(bufferBLM.getDeviceUid(), CLIENT_UUID);
    }

    @Test
    @DisplayName("Get buffers by connection scheme - Positive")
    void shouldGetBuffersByConnectionSchemeWhenValidRequest() {
        // Arrange
        BufferBLM bufferBLM = createValidBufferBLM();
        List<BufferBLM> buffersBLM = Collections.singletonList(bufferBLM);

        when(connectionSchemeKafkaClient.connectionSchemeExistsAndBelongsToClient(
                eq(SCHEME_UUID), eq(CLIENT_UUID))).thenReturn(true);
        when(bufferRepository.findByConnectionSchemeUid(SCHEME_UUID)).thenReturn(buffersBLM);
        setupAuthentication(CLIENT_UUID);

        // Act
        List<BufferBLM> result = bufferService.getBuffersByConnectionScheme(SCHEME_UUID);

        // Assert
        assertThat(result).isNotEmpty();
        assertThat(result.get(0).getUid()).isEqualTo(BUFFER_UUID);
        verify(connectionSchemeKafkaClient).connectionSchemeExistsAndBelongsToClient(SCHEME_UUID, CLIENT_UUID);
        verify(bufferRepository).findByConnectionSchemeUid(SCHEME_UUID);
    }

    @Test
    @DisplayName("Get buffers by client - Positive")
    void shouldGetBuffersByClientWhenValidRequest() {
        // Arrange
        // Создаем DeviceDTO с правильной структурой на основе декомпилированного кода
        DeviceDTO deviceDTO = new DeviceDTO();
        deviceDTO.setUid(DEVICE_UUID.toString());
        deviceDTO.setClientUuid(CLIENT_UUID.toString());
        deviceDTO.setDeviceName("Test Device");
        deviceDTO.setDeviceDescription("Test Device Description");
        
        // Создаем DeviceBLM с правильным конструктором
        DeviceBLM deviceBLM = new DeviceBLM(DEVICE_UUID, CLIENT_UUID, "Test Device", "Test Device Description");
        List<DeviceDTO> deviceDTOs = Collections.singletonList(deviceDTO);
        
        BufferBLM bufferBLM = createValidBufferBLM();
        List<BufferBLM> buffersBLM = Collections.singletonList(bufferBLM);

        GetDevicesByClientResponse devicesResponse = GetDevicesByClientResponse.valid(
            "correlation-id", deviceDTOs
        );

        when(deviceKafkaClient.getDevicesByClient(eq(CLIENT_UUID), eq("buffer-service")))
            .thenReturn(CompletableFuture.completedFuture(devicesResponse));
        when(deviceConverter.toBLM(deviceDTO)).thenReturn(deviceBLM);
        when(deviceKafkaClient.deviceExistsAndBelongsToClient(eq(DEVICE_UUID), eq(CLIENT_UUID))).thenReturn(true);
        when(bufferRepository.findByDeviceUid(DEVICE_UUID)).thenReturn(buffersBLM);
        setupAuthentication(CLIENT_UUID);

        // Act
        List<BufferBLM> result = bufferService.getBuffersByClient(CLIENT_UUID);

        // Assert
        assertThat(result).isNotEmpty();
        assertThat(result.get(0).getUid()).isEqualTo(BUFFER_UUID);
        verify(deviceKafkaClient).getDevicesByClient(CLIENT_UUID, "buffer-service");
        verify(bufferRepository).findByDeviceUid(DEVICE_UUID);
    }

    @Test
    @DisplayName("Get buffers by device - Positive")
    void shouldGetBuffersByDeviceWhenValidRequest() {
        // Arrange
        BufferBLM bufferBLM = createValidBufferBLM();
        List<BufferBLM> buffersBLM = Collections.singletonList(bufferBLM);

        when(deviceKafkaClient.deviceExistsAndBelongsToClient(eq(DEVICE_UUID), eq(CLIENT_UUID))).thenReturn(true);
        when(bufferRepository.findByDeviceUid(DEVICE_UUID)).thenReturn(buffersBLM);
        setupAuthentication(CLIENT_UUID);

        // Act
        List<BufferBLM> result = bufferService.getBuffersByDevice(DEVICE_UUID);

        // Assert
        assertThat(result).isNotEmpty();
        assertThat(result.get(0).getUid()).isEqualTo(BUFFER_UUID);
        verify(deviceKafkaClient).deviceExistsAndBelongsToClient(DEVICE_UUID, CLIENT_UUID);
        verify(bufferRepository).findByDeviceUid(DEVICE_UUID);
    }

    @Test
    @DisplayName("Update buffer - Positive")
    void shouldUpdateBufferWhenValidData() {
        // Arrange
        BufferDTO bufferDTO = createValidBufferDTO();
        BufferBLM bufferBLM = createValidBufferBLM();
        BufferBLM existingBuffer = createValidBufferBLM();

        when(bufferRepository.findByUid(BUFFER_UUID)).thenReturn(existingBuffer);
        when(bufferConverter.toBLM(bufferDTO)).thenReturn(bufferBLM);
        when(deviceKafkaClient.deviceExistsAndBelongsToClient(
                eq(bufferBLM.getDeviceUid()), eq(CLIENT_UUID))).thenReturn(true);
        setupAuthentication(CLIENT_UUID);

        // Act
        BufferBLM result = bufferService.updateBuffer(BUFFER_UUID, bufferDTO);

        // Assert
        assertThat(result).isNotNull();
        verify(bufferValidator).validate(bufferDTO);
        verify(bufferRepository).update(bufferBLM);
    }

    @Test
    @DisplayName("Delete buffer - Positive")
    void shouldDeleteBufferWhenValidRequest() {
        // Arrange
        BufferBLM existingBuffer = createValidBufferBLM();

        when(bufferRepository.findByUid(BUFFER_UUID)).thenReturn(existingBuffer);
        when(deviceKafkaClient.deviceExistsAndBelongsToClient(
                eq(existingBuffer.getDeviceUid()), eq(CLIENT_UUID))).thenReturn(true);
        setupAuthentication(CLIENT_UUID);

        // Act
        bufferService.deleteBuffer(BUFFER_UUID);

        // Assert
        verify(bufferRepository).delete(BUFFER_UUID);
    }

    @Test
    @DisplayName("Delete all buffers from connection scheme - Positive")
    void shouldDeleteAllBuffersFromConnectionSchemeWhenValidRequest() {
        // Arrange
        BufferBLM bufferBLM = createValidBufferBLM();
        List<BufferBLM> buffersBLM = Collections.singletonList(bufferBLM);

        when(connectionSchemeKafkaClient.connectionSchemeExistsAndBelongsToClient(
                eq(SCHEME_UUID), eq(CLIENT_UUID))).thenReturn(true);
        when(bufferRepository.findByConnectionSchemeUid(SCHEME_UUID)).thenReturn(buffersBLM);
        setupAuthentication(CLIENT_UUID);

        // Act
        bufferService.deleteAllBuffersFromConnectionScheme(SCHEME_UUID);

        // Assert
        verify(bufferRepository).findByConnectionSchemeUid(SCHEME_UUID);
        verify(bufferRepository).removeBufferFromConnectionScheme(BUFFER_UUID, SCHEME_UUID);
    }

    @Test
    @DisplayName("Delete buffer from connection scheme - Positive")
    void shouldDeleteBufferFromConnectionSchemeWhenValidRequest() {
        // Arrange
        BufferBLM bufferBLM = createValidBufferBLM();
        List<BufferBLM> buffersBLM = Collections.singletonList(bufferBLM);

        when(connectionSchemeKafkaClient.connectionSchemeExistsAndBelongsToClient(
                eq(SCHEME_UUID), eq(CLIENT_UUID))).thenReturn(true);
        when(bufferRepository.findByConnectionSchemeUid(SCHEME_UUID)).thenReturn(buffersBLM);
        setupAuthentication(CLIENT_UUID);

        // Act
        bufferService.deleteBufferFromConnectionScheme(SCHEME_UUID, BUFFER_UUID);

        // Assert
        verify(bufferRepository).findByConnectionSchemeUid(SCHEME_UUID);
        verify(bufferRepository).removeBufferFromConnectionScheme(BUFFER_UUID, SCHEME_UUID);
    }

    @Test
    @DisplayName("Buffer exists - Positive")
    void shouldReturnTrueWhenBufferExists() {
        // Arrange
        BufferBLM bufferBLM = createValidBufferBLM();

        when(bufferRepository.exists(BUFFER_UUID)).thenReturn(true);
        when(bufferRepository.findByUid(BUFFER_UUID)).thenReturn(bufferBLM);
        when(deviceKafkaClient.deviceExistsAndBelongsToClient(
                eq(bufferBLM.getDeviceUid()), eq(CLIENT_UUID))).thenReturn(true);
        setupAuthentication(CLIENT_UUID);

        // Act
        boolean result = bufferService.bufferExists(BUFFER_UUID);

        // Assert
        assertThat(result).isTrue();
        verify(bufferRepository).exists(BUFFER_UUID);
        verify(deviceKafkaClient).deviceExistsAndBelongsToClient(bufferBLM.getDeviceUid(), CLIENT_UUID);
    }

    @Test
    @DisplayName("Buffer exists - Negative: Buffer not found")
    void shouldReturnFalseWhenBufferNotExists() {
        // Arrange
        when(bufferRepository.exists(BUFFER_UUID)).thenReturn(false);
        setupAuthentication(CLIENT_UUID);

        // Act
        boolean result = bufferService.bufferExists(BUFFER_UUID);

        // Assert
        assertThat(result).isFalse();
        verify(bufferRepository).exists(BUFFER_UUID);
    }

    @Test
    @DisplayName("Buffer exists - Negative: Device doesn't belong to client")
    void shouldReturnFalseWhenDeviceNotBelongsToClient() {
        // Arrange
        BufferBLM bufferBLM = createValidBufferBLM();

        when(bufferRepository.exists(BUFFER_UUID)).thenReturn(true);
        when(bufferRepository.findByUid(BUFFER_UUID)).thenReturn(bufferBLM);
        when(deviceKafkaClient.deviceExistsAndBelongsToClient(
                eq(bufferBLM.getDeviceUid()), eq(CLIENT_UUID))).thenReturn(false);
        setupAuthentication(CLIENT_UUID);

        // Act
        boolean result = bufferService.bufferExists(BUFFER_UUID);

        // Assert
        assertThat(result).isFalse();
        verify(bufferRepository).exists(BUFFER_UUID);
        verify(deviceKafkaClient).deviceExistsAndBelongsToClient(bufferBLM.getDeviceUid(), CLIENT_UUID);
    }

    @Test
    @DisplayName("Update buffer - Negative: Cannot change buffer UID")
    void shouldThrowExceptionWhenTryingToChangeBufferUid() {
        // Arrange
        BufferDTO bufferDTO = createValidBufferDTO();
        BufferBLM existingBuffer = createValidBufferBLM();
        // Создаем BLM с другим UID
        BufferBLM bufferBLM = new BufferBLM(
            UUID.randomUUID(), // другой UID
            SCHEME_UUID,
            1000,
            1024,
            "message prototype"
        );

        when(bufferRepository.findByUid(BUFFER_UUID)).thenReturn(existingBuffer);
        when(deviceKafkaClient.deviceExistsAndBelongsToClient(
                eq(existingBuffer.getDeviceUid()), eq(CLIENT_UUID))).thenReturn(true);
        when(bufferConverter.toBLM(bufferDTO)).thenReturn(bufferBLM);
        setupAuthentication(CLIENT_UUID);

        // Act & Assert
        assertThatThrownBy(() -> bufferService.updateBuffer(BUFFER_UUID, bufferDTO))
            .isInstanceOf(IllegalArgumentException.class)
            .hasMessageContaining("Cannot change buffer UID");

        verify(bufferValidator).validate(bufferDTO);
        verify(bufferRepository, never()).update(any());
    }

    @Test
    @DisplayName("Get buffers by client - Negative: Device service returns error")
    void shouldReturnEmptyListWhenDeviceServiceFails() throws Exception {
        // Arrange
        GetDevicesByClientResponse devicesResponse = GetDevicesByClientResponse.error(
            "correlation-id", "Service unavailable"
        );

        when(deviceKafkaClient.getDevicesByClient(eq(CLIENT_UUID), eq("buffer-service")))
            .thenReturn(CompletableFuture.completedFuture(devicesResponse));
        setupAuthentication(CLIENT_UUID);

        // Act
        List<BufferBLM> result = bufferService.getBuffersByClient(CLIENT_UUID);

        // Assert
        assertThat(result).isEmpty();
        verify(deviceKafkaClient).getDevicesByClient(CLIENT_UUID, "buffer-service");
    }

    @Test
    @DisplayName("Get buffers by client - Negative: Device service timeout")
    void shouldThrowExceptionWhenDeviceServiceTimeout() throws Exception {
        // Arrange
        CompletableFuture<GetDevicesByClientResponse> timeoutFuture = new CompletableFuture<>();
        timeoutFuture.completeExceptionally(new java.util.concurrent.TimeoutException("Timeout"));

        when(deviceKafkaClient.getDevicesByClient(eq(CLIENT_UUID), eq("buffer-service")))
            .thenReturn(timeoutFuture);
        setupAuthentication(CLIENT_UUID);

        // Act & Assert
        assertThatThrownBy(() -> bufferService.getBuffersByClient(CLIENT_UUID))
            .isInstanceOf(RuntimeException.class)
            .hasMessageContaining("Device service error");

        verify(deviceKafkaClient).getDevicesByClient(CLIENT_UUID, "buffer-service");
    }
}